<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Orville - Using JSON</title>
        <link rel="stylesheet" href="../css/syntax.css" />
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
      <section class="leftbar">
        <header>
          <h1 class="logo">
            <a href="../">
              <img alt="Orville Logo" src="../images/orville-waving-pennant.svg" />
            </a>
          </h1>
        </header>

        <nav>
          <h3><a href="../">Home</a></h3>

          <h3>Tutorials</h3>
          
            <a href="../tutorials/getting-started.html">Getting Started</a>
          
            <a href="../tutorials/using-sql-marshaller.html">Using SqlMarshaller</a>
          
            <a href="../tutorials/using-migrations.html">Using Migrations</a>
          
            <a href="../tutorials/using-plans.html">Using Plans</a>
          
            <a href="../tutorials/using-json.html">Using JSON</a>
          

          <h3>How-To Guides</h3>
          
            <a href="../how-tos/how-to-add-orville-to-your-application-monad.html">How To Add Orville to Your Application Monad</a>
          
            <a href="../how-tos/how-to-add-orville-to-an-existing-reader-context.html">How To Add Orville to an Existing Reader Context</a>
          
            <a href="../how-tos/how-to-marshall-a-haskell-record.html">How To Marshall a Haskell Record (Upcoming)</a>
          
            <a href="../how-tos/how-to-add-custom-marshalling-validations.html">How Add Custom Marshalling Validations (Upcoming)</a>
          
            <a href="../how-tos/how-to-marshall-a-haskell-sum-type.html">How To Marshall a Haskell Sum Type (Upcoming)</a>
          
            <a href="../how-tos/how-to-set-up-an-auto-incrementing-id-column.html">How To Set Up An Auto-incrementing Id Column (Upcoming)</a>
          
            <a href="../how-tos/how-to-execute-raw-sql.html">How To Execute Raw SQL (Upcoming)</a>
          

          <h3>Futher Explanation</h3>
          
            <a href="../explanations/the-monad-orville-typeclass.html">The MonadOrville Typeclass (Upcoming)</a>
          
            <a href="../explanations/building-sql-expressions.html">Building SQL Expressions (Upcoming)</a>
          
            <a href="../explanations/fighting-n-plus-one-queries-with-plans.html">Fighting N+1 Queries with Plans (Upcoming)</a>
          
            <a href="../explanations/handling-failure.html">Handling Failure (Upcoming)</a>
          

          <h3>API Reference</h3>
          <a href="https://hackage.haskell.org/package/orville-postgresql">See Hackage</a>

          <h3>Other Links</h3>
          <a href="../contact.html">Contact</a>
        </nav>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
      </section>

      <main role="main">
        <h1>Using JSON</h1>
        <article>
  <section>
    <p>You’ll need a Haskell project named <code>using-json</code> for this tutorial.
The setup is identical to the setup in <a href="getting-started.html">Getting Started</a>
aside from the package name, so we’ll avoid explaining it again here.</p>
<p>SQL has a rigid schema. Using JSON inside SQL allows for pockets of schemaless
data, that is still queryable using PostgreSQL’s built-in functionality.</p>
<p>This document explains how to use Orville with the JSONB data type that
PostgreSQL natively supports.</p>
<p>Project initialization is similar to previous tutorials, but additional
dependencies like Aeson have been added. Aeson is a JSON library for Haskell.</p>
<p>Here’s the beginning of our <code>src/Main.hs</code> file.</p>
<div class="codeblock-label">
src/Main.hs : haskell
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  ( main</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  ) <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Orville.PostgreSQL</span> <span class="kw">as</span> <span class="dt">O</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Orville.PostgreSQL.AutoMigration</span> <span class="kw">as</span> <span class="dt">AutoMigration</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Orville.PostgreSQL.Marshall</span> <span class="kw">as</span> <span class="dt">Marshall</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Orville.PostgreSQL.Raw.RawSql</span> <span class="kw">as</span> <span class="dt">RawSql</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Control.Monad.IO.Class</span> (<span class="dt">MonadIO</span>(liftIO))</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Aeson</span> (<span class="dt">Value</span>, eitherDecodeStrict')</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Aeson.Text</span> (encodeToLazyText)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Aeson</span> <span class="kw">as</span> <span class="dt">Aeson</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Int</span> <span class="kw">as</span> <span class="dt">Int</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Encoding</span> <span class="kw">as</span> <span class="dt">Enc</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">LazyText</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">Vector</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>Let’s suppose we have an example entity with an ID, and some arbitrary JSON
data in a column called ‘tags’.</p>
<p>Note how <code>fooTagsField</code> below uses the <code>Value</code> type from the Aeson library.</p>
<p>Remember that the <code>Value</code> contains its own <code>Null</code> constructor, which is
distinct from SQL’s <code>NULL</code>. So we can have JSON nulls in this field, but no SQL
nulls.</p>
<p>We could also use a custom type with <code>FromJSON</code>/<code>ToJSON</code> instances, since
<code>jsonb</code> allows for that too. Aeson is not the focus of this document though.</p>
<div class="codeblock-label">
src/Main.hs : haskell
</div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Foo</span> <span class="ot">=</span> <span class="dt">Foo</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> fooId ::</span> <span class="dt">Int</span><span class="op">.</span><span class="dt">Int32</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> fooTags ::</span> <span class="dt">Value</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="ot">fooIdField ::</span> <span class="dt">O.FieldDefinition</span> <span class="dt">O.NotNull</span> <span class="dt">Int</span><span class="op">.</span><span class="dt">Int32</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>fooIdField <span class="ot">=</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  O.integerField <span class="st">&quot;id&quot;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="ot">fooTagsField ::</span> <span class="dt">O.FieldDefinition</span> <span class="dt">O.NotNull</span> <span class="dt">Value</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>fooTagsField <span class="ot">=</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  aesonValueField <span class="st">&quot;tags&quot;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>Before we can define the corresponding <code>SqlMarshaller</code>, we’ll need to define the
<code>aesonValueField</code> helper function. This is done <code>tryConvertSqlType</code> along with
<code>jsonb</code> field to apply Aeson encoding and decode.</p>
<div class="codeblock-label">
src/Main.hs : haskell
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">aesonValueField ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">O.FieldDefinition</span> <span class="dt">O.NotNull</span> <span class="dt">Value</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>aesonValueField name <span class="ot">=</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  O.convertField</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    (O.tryConvertSqlType encodeJSON decodeJSON)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    (O.jsonbField name)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="ot">decodeJSON ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Value</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>decodeJSON <span class="ot">=</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  eitherDecodeStrict' <span class="op">.</span> Enc.encodeUtf8</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="ot">encodeJSON ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">T.Text</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>encodeJSON <span class="ot">=</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>  LazyText.toStrict <span class="op">.</span> encodeToLazyText</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>Let’s define the <code>SqlMarshaller</code> and the table. This is standard stuff, no
surprises here.</p>
<div class="codeblock-label">
src/Main.hs : haskell
</div>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fooMarshaller ::</span> <span class="dt">O.SqlMarshaller</span> <span class="dt">Foo</span> <span class="dt">Foo</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>fooMarshaller <span class="ot">=</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Foo</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;$&gt;</span> O.marshallField fooId fooIdField</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> O.marshallField fooTags fooTagsField</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="ot">table ::</span> <span class="dt">O.TableDefinition</span> (<span class="dt">O.HasKey</span> <span class="dt">Int</span><span class="op">.</span><span class="dt">Int32</span>) <span class="dt">Foo</span> <span class="dt">Foo</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>table <span class="ot">=</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  O.mkTableDefinition <span class="st">&quot;json_demo&quot;</span> (O.primaryKey fooIdField) fooMarshaller</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>With all definitions done, we can write <code>main</code>. Orville will also use the parts
of the <code>SqlType</code> during migration.</p>
<div class="codeblock-label">
src/Main.hs : haskell
</div>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  pool <span class="ot">&lt;-</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    O.createConnectionPool</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">O.ConnectionOptions</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>          { O.connectionString <span class="ot">=</span> <span class="st">&quot;host=localhost user=postgres password=postgres&quot;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>          , O.connectionNoticeReporting <span class="ot">=</span> <span class="dt">O.DisableNoticeReporting</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>          , O.connectionPoolStripes <span class="ot">=</span> <span class="dt">O.OneStripePerCapability</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>          , O.connectionPoolLingerTime <span class="ot">=</span> <span class="dv">10</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>          , O.connectionPoolMaxConnections <span class="ot">=</span> <span class="dt">O.MaxConnectionsPerStripe</span> <span class="dv">1</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>          }</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  O.runOrville pool <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    AutoMigration.autoMigrateSchema AutoMigration.defaultOptions [ <span class="dt">AutoMigration.SchemaTable</span> table ]</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">&lt;-</span> O.deleteEntity table <span class="dv">0</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>We’ll construct a JSON value using the Aeson library, which makes this look
fairly verbose. But imagine that the <code>Array</code> value below was read from a file,
or received over HTTP from a web browser.</p>
<div class="codeblock-label">
src/Main.hs : haskell
</div>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">&lt;-</span> O.insertEntity table <span class="dt">Foo</span> { fooId <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>                                  , fooTags <span class="ot">=</span> <span class="dt">Aeson.Array</span> <span class="op">$</span> Vector.fromList</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>                                      [ <span class="dt">Aeson.Number</span> <span class="dv">1</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>                                      , <span class="dt">Aeson.Number</span> <span class="dv">2</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>                                      , <span class="dt">Aeson.Number</span> <span class="dv">3</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>                                      ]</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>                                  }</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    liftIO <span class="op">.</span> <span class="fu">print</span> <span class="op">=&lt;&lt;</span> O.findEntity table <span class="dv">0</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>Using raw SQL, we can use PostgreSQL’s built-in JSONB functions. Let’s suppose
we want a row returned for each of the values in the <code>Array</code> above.</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Tag</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>We can use an <code>SqlMarshaller</code> to produce a result like this, even though there
is no table for the returned schema. The programmer must ensure correspondence
of the SQL and the <code>SqlMarshaller</code>. If they don’t match, an exception will be
thrown.</p>
<p>We’ll have the <code>SqlMarshaller</code> work with tuples and <code>marshallReadOnlyField</code>s.
These allow for succintly defining a quick one-off <code>SqlMarshaller</code>.</p>
<div class="codeblock-label">
src/Main.hs : haskell
</div>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">      marshaller ::</span> <span class="dt">O.SqlMarshaller</span> w (<span class="dt">Int</span><span class="op">.</span><span class="dt">Int32</span>, <span class="dt">Value</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>      marshaller <span class="ot">=</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        (,) <span class="op">&lt;$&gt;</span> O.marshallReadOnlyField fooIdField</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">&lt;*&gt;</span> O.marshallReadOnlyField (aesonValueField <span class="st">&quot;tag&quot;</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    readEntities <span class="ot">&lt;-</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>      O.executeAndDecode</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">O.SelectQuery</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        (RawSql.fromString <span class="st">&quot;SELECT id, jsonb_array_elements(tags) AS tag FROM json_demo&quot;</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        (Marshall.annotateSqlMarshallerEmptyAnnotation marshaller)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    liftIO <span class="op">$</span> <span class="fu">print</span> readEntities</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<h1 id="program-output-and-test">Program output and test</h1>
<p>This concludes this tutorial. You can build an execute this as usual:</p>
<div class="codeblock-label">
shell
</div>
<div class="sourceCode" id="cb8"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ex">stack</span> build</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ex">stack</span> exec using-json</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>And you should see the following output:</p>
<div class="codeblock-label">
output : plaintext
</div>
<div class="sourceCode" id="cb9"><pre class="sourceCode txt"><code class="sourceCode default"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>Just (Foo {fooId = 0, fooTags = Array [Number 1.0,Number 2.0,Number 3.0]})</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>[(0,Number 1.0),(0,Number 2.0),(0,Number 3.0)]</span></code></pre></div>
  </section>
</article>

      </main>
    </body>
</html>
