-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | ORM
--   
--   ORM library for PostgreSQL
@package orville-postgresql
@version 1.0.0.0


module Orville.PostgreSQL.ErrorDetailLevel

-- | <a>ErrorDetailLevel</a> provides a means to configure what elements of
--   information are included in error messages that originate from
--   decoding rows queried from the database. This can be specified either
--   my manually rendering the error message and providing the desired
--   configuration, or by setting the desired detail level in the
--   <tt>OrvilleState</tt> as a default.
--   
--   Information will be redacted from error messages for any of the fields
--   that are set to <tt>False</tt>.
data ErrorDetailLevel
ErrorDetailLevel :: Bool -> Bool -> Bool -> Bool -> ErrorDetailLevel
[includeErrorMessage] :: ErrorDetailLevel -> Bool
[includeSchemaNames] :: ErrorDetailLevel -> Bool
[includeRowIdentifierValues] :: ErrorDetailLevel -> Bool
[includeNonIdentifierValues] :: ErrorDetailLevel -> Bool

-- | A default <a>ErrorDetailLevel</a> that strikes balance of including
--   all <a>Generic</a> information such as the error message, schema names
--   and row identifiers, but avoids untentionally leaking non-identifier
--   values from the database by redacting them.
defaultErrorDetailLevel :: ErrorDetailLevel

-- | A minimal <a>ErrorDetailLevel</a> where everything all information
--   (including any situationally-specific error message!) is redacted from
--   error messages.
minimalErrorDetailLevel :: ErrorDetailLevel

-- | A maximal <a>ErrorDetailLevel</a> that redacts no information from the
--   error messages. Error messages will include values from the database
--   for any columns are involved in a decoding failure, including some
--   which you may not have intended to expose through error message. Use
--   with caution.
maximalErrorDetailLevel :: ErrorDetailLevel

-- | Redacts given the error message string if the <a>ErrorDetailLevel</a>
--   indicates that error messages should be redacted.
redactErrorMessage :: ErrorDetailLevel -> String -> String

-- | Redacts given the schema name string if the <a>ErrorDetailLevel</a>
--   indicates that schema names should be redacted.
redactSchemaName :: ErrorDetailLevel -> String -> String

-- | Redacts given the identifier value string if the
--   <a>ErrorDetailLevel</a> indicates that identifier values should be
--   redacted.
redactIdentifierValue :: ErrorDetailLevel -> String -> String

-- | Redacts given the non-identifier value string if the
--   <a>ErrorDetailLevel</a> indicates that non-identifier values should be
--   redacted.
redactNonIdentifierValue :: ErrorDetailLevel -> String -> String
instance GHC.Show.Show Orville.PostgreSQL.ErrorDetailLevel.ErrorDetailLevel


module Orville.PostgreSQL.Execution.QueryType

-- | A simple categorization of SQL queries that is used to provide a hint
--   to user callbacks about what kind of query is being run.
--   
--   See <a>addSqlExecutionCallback</a>
data QueryType
SelectQuery :: QueryType
InsertQuery :: QueryType
UpdateQuery :: QueryType
DeleteQuery :: QueryType
DDLQuery :: QueryType
CursorQuery :: QueryType
OtherQuery :: QueryType
instance GHC.Read.Read Orville.PostgreSQL.Execution.QueryType.QueryType
instance GHC.Show.Show Orville.PostgreSQL.Execution.QueryType.QueryType
instance GHC.Enum.Bounded Orville.PostgreSQL.Execution.QueryType.QueryType
instance GHC.Enum.Enum Orville.PostgreSQL.Execution.QueryType.QueryType
instance GHC.Classes.Eq Orville.PostgreSQL.Execution.QueryType.QueryType
instance GHC.Classes.Ord Orville.PostgreSQL.Execution.QueryType.QueryType


module Orville.PostgreSQL.Execution.ReturningOption

-- | Specifies whether or not a <tt>RETURNING</tt> clause should be
--   included when a query expression is built. This type is found as a
--   parameter on a number of the query building functions related to
--   <tt>TableDefinition</tt>. @since 1.0.0.0
data ReturningOption clause
[WithReturning] :: ReturningOption ReturningClause
[WithoutReturning] :: ReturningOption NoReturningClause

-- | A tag, used with <a>ReturningOption</a> to indicate a SQL Returning
--   clause.
data ReturningClause

-- | A tag, used with <a>ReturningOption</a> to indicate no SQL Returning
--   clause.
data NoReturningClause


module Orville.PostgreSQL.Plan.Explanation
data Explanation
noExplanation :: Explanation
explainStep :: String -> Explanation
explanationSteps :: Explanation -> [String]
instance GHC.Base.Semigroup Orville.PostgreSQL.Plan.Explanation.Explanation
instance GHC.Base.Monoid Orville.PostgreSQL.Plan.Explanation.Explanation


module Orville.PostgreSQL.Plan.Many

-- | A 'Many k a' represents a group of values keyed by list of parameters
--   and is used to return the results of executing an Orville Plan with a
--   list of input parameters. If you need to find the result of the query
--   associated with a particular input parameter, you can use
--   <a>lookup</a> to find it. If you don't care about the association with
--   particular inputs, you can simply use <a>elems</a> to get a list of
--   all the results.
data Many k a

-- | <a>NotAKey</a> is returned from various <a>Many</a> related functions
--   when presented with an input parameter that was not one of the
--   original inputs that the <a>Many</a> was constructed with.
data NotAKey
NotAKey :: NotAKey

-- | <a>fromKeys</a> constructs a <a>Many</a> value from a list of keys and
--   a function that maps them to their values. The order and duplication
--   of keys in the list will be preserved by the <a>Many</a> type in the
--   relevant functions. The mapping function provided should be a total
--   function -- i.e. it should not produce a runtime error. If it is not
--   possible to map every <tt>k</tt> (even those not in the input list
--   provided to <a>fromKeys</a>), the values should be wrapped in an
--   appropriate type such as <a>Maybe</a> so that an empty or default
--   value can be returned.
fromKeys :: [k] -> (k -> Either NotAKey a) -> Many k a

-- | <a>lookup</a> returns the value for the given parameter. If the given
--   <tt>k</tt> is not one of the original input values that the
--   <a>Many</a> was constructed with, the mapping function given at the
--   contructor will determine what value to return. Often this will be
--   whatever a reasonable empty or default value for the type <tt>a</tt>
--   is.
lookup :: k -> Many k a -> Either NotAKey a

-- | <a>keys</a> fetches the list of keys from a <a>Many</a>. Note that is
--   a list and not a set. <a>Many</a> preserves the order and duplication
--   of any key values that were in the key list at the time of
--   construction.
keys :: Many k a -> [k]

-- | <a>elems</a> returns all the values that correspond the keys of the
--   <a>Many</a>. The values will be returned in the same order that the
--   keys were present at the time of creation, though if you truly care
--   about this it's probably better to use <a>lookup</a> to make that
--   correspondence explicit.
elems :: Many k a -> [a]

-- | <a>map</a> calls a function on all the values found in a <a>Many</a>
--   collection.
map :: (a -> b) -> Many k a -> Many k b

-- | <a>toMap</a> converts the <a>Many</a> into a <tt>Map</tt> value. If
--   all you wanted to do was find the value for a specific key, you should
--   probably use <a>lookup</a> instead.
toMap :: Ord k => Many k a -> Map k a

-- | <a>apply</a> allows you to apply many functions to many values. The
--   function associated with each parameter is applied to the value
--   associated with the same paremeter.
--   
--   (If you're looking for <tt>pure</tt> or an <tt>Applicative</tt>
--   instance for <a>Many</a>, this is as good as it gets. <a>Many</a>
--   cannot be an <tt>Applicative</tt> because there is no correct
--   implementation of <tt>pure</tt> that we can reasonably provide).
apply :: Many param (a -> b) -> Many param a -> Many param b

-- | <a>compose</a> uses the values of a <a>Many</a> value as keys to a
--   second <a>Many</a> to create a <a>Many</a> mapping from the original
--   keys to the final values.
compose :: Many b c -> Many a b -> Many a c
instance GHC.Base.Functor (Orville.PostgreSQL.Plan.Many.Many k)


module Orville.PostgreSQL.Raw.PgTextFormatValue

-- | A <a>PgTextFormatValue</a> represents raw bytes that will be passed to
--   postgresql via libpq. These bytes must conform to the TEXT format of
--   values that postgresql expects. In all cases postgresql will be
--   allowed to infer the type of the value based on its usage in the
--   query.
--   
--   Note that postgresql does not allow NUL bytes in text values, and the
--   LibPQ C library expects text values to be given as NULL-terminated C
--   Strings, so 'NUL' bytes cannot be included in a
--   <a>PgTextFormatValue</a>. If <a>fromByteString</a> is used to
--   construct the <a>PgTextFormatValue</a> (normally what you should do),
--   an error will be raised before libpq is called to execute the query.
--   If <a>unsafeFromByteString</a> is used, the caller is expected to
--   ensure that no 'NUL' bytes are present. If a 'NUL' byte is included
--   with <a>unsafeFromByteString</a>, the value passed to the database
--   will be truncated at the 'NUL' byte because it will be interpreted as
--   the end of the C String by libpq.
data PgTextFormatValue
data NULByteFoundError
NULByteFoundError :: NULByteFoundError

-- | Constructs a <a>PgTextFormatValue</a> from the given bytes directly,
--   without checking whether any of the bytes are 'NUL' or not. If a
--   <a>ByteString</a> containing a 'NUL' byte is given, the value will be
--   truncated at the 'NUL' when it is passed to libpq.
--   
--   This function is only safe to use when you have generated the
--   bytestring in a way that guarantees no 'NUL' bytes are present, such
--   as when serializing an integer value to its decimal representation.
unsafeFromByteString :: ByteString -> PgTextFormatValue

-- | Constructs a <a>PgTextFormatValue</a> from the given bytes, which will
--   be checked to ensure none of them are 'NUL' before being passed to
--   libpq. If a 'NUL' byte is found an error will be raised.
fromByteString :: ByteString -> PgTextFormatValue

-- | Convents the <a>PgTextFormatValue</a> back to the bytes that were used
--   to construct it, losing the information about whether it would be
--   checked for 'NUL' bytes or not.
toByteString :: PgTextFormatValue -> ByteString

-- | Converts the <a>PgTextFormatValue</a> to bytes intended to be passed
--   to libpq. If any 'NUL' bytes are found, <tt>NULByteErrorFound</tt>
--   will be returned (unless <a>unsafeFromByteString</a> was used to
--   construct the value).
toBytesForLibPQ :: PgTextFormatValue -> Either NULByteFoundError ByteString
instance GHC.Show.Show Orville.PostgreSQL.Raw.PgTextFormatValue.PgTextFormatValue
instance GHC.Classes.Eq Orville.PostgreSQL.Raw.PgTextFormatValue.NULByteFoundError
instance GHC.Show.Show Orville.PostgreSQL.Raw.PgTextFormatValue.NULByteFoundError
instance GHC.Exception.Type.Exception Orville.PostgreSQL.Raw.PgTextFormatValue.NULByteFoundError
instance GHC.Classes.Eq Orville.PostgreSQL.Raw.PgTextFormatValue.PgTextFormatValue


module Orville.PostgreSQL.Raw.Connection

-- | An Orville handle for a LibPQ connection.
data Connection

-- | <a>createConnectionPool</a> allocates a pool of connections to a
--   PostgreSQL server.
createConnectionPool :: NoticeReporting -> Int -> NominalDiffTime -> Int -> ByteString -> IO (Pool Connection)

-- | An option for <a>createConnectionPool</a> than indicates whether the
--   LibPQ should print notice reports for warnings to the console
data NoticeReporting
EnableNoticeReporting :: NoticeReporting
DisableNoticeReporting :: NoticeReporting

-- | <a>executeRaw</a> runs a given SQL statement returning the raw
--   underlying result.
--   
--   All handling of stepping through the result set is left to the caller.
--   This potentially leaves connections open much longer than one would
--   expect if all of the results are not iterated through immediately
--   *and* the data copied. Use with caution.
executeRaw :: Connection -> ByteString -> [Maybe PgTextFormatValue] -> IO Result

-- | Escapes and quotes a string for use as a literal within a SQL command
--   that will be execute on the given connection. This uses the
--   <tt>PQescapeStringConn</tt> function from libpq, which takes the
--   character encoding of the connection into account. Not that while
--   <tt>PQescapeStringConn</tt> does not surround the literal with quotes,
--   this function does for the sake of symmetry with
--   <a>quoteIdentifier</a>.
--   
--   This function returns a <a>Buider</a> so that the result can be
--   included in a builder being constructed for the surrounding SQL
--   command without making an additional copy of the <a>Bytestring</a>
--   returned by LibPQ for the sake of adding the surrounding quotes.
quoteStringLiteral :: Connection -> ByteString -> IO Builder

-- | Escapes and quotes a string for use as an identifier within a SQL
--   command that will be execute on the given connection. This uses the
--   <tt>PQescapeIdentifier</tt> function from libpq, which takes the
--   character encoding of the connection into account and also applies the
--   quotes.
--   
--   Although this function does not need to copy the <a>ByteString</a>
--   returned by LibPQ to add the quotes (since LibPQ already added them),
--   it returns a <a>Builder</a> nonetheless to maintain symmetry with
--   <a>quoteStringLiteral</a>.
quoteIdentifier :: Connection -> ByteString -> IO Builder

-- | Orville throws as <a>ConnectionUsedAfterCloseError</a> if it attempts
--   to use a <a>Connection</a> value after it has already been closed. If
--   this occurs, it is a bug in Orville.
data ConnectionUsedAfterCloseError

-- | Orville throws a <a>ConnectionError</a> on an error reported by the
--   underlying LibPQ connection that does not come directly from executing
--   SQL. This could could represent an inability to open a new database
--   connection, but could also represent other errors such as an error
--   while quoting a database identifier.
data ConnectionError

-- | Orville throws a <a>SqlExecutionError</a> when an error is reported by
--   the underlying LibPQ connection during an attempt to execute SQL.
data SqlExecutionError
SqlExecutionError :: Maybe ExecStatus -> ByteString -> Maybe ByteString -> ByteString -> SqlExecutionError

-- | The underlying LibPQ execution status
[sqlExecutionErrorExecStatus] :: SqlExecutionError -> Maybe ExecStatus

-- | Error message reported by PostgreSQL
[sqlExecutionErrorMessage] :: SqlExecutionError -> ByteString

-- | Any SQL state value reported by PostgreSQL. This can be used to
--   programming determine what kind of error happening without needing to
--   parse the error message. See
--   <a>https://www.postgresql.org/docs/current/errcodes-appendix.html</a>
[sqlExecutionErrorSqlState] :: SqlExecutionError -> Maybe ByteString

-- | The SQL query that was being run when the error occurred.
[sqlExecutionErrorSqlQuery] :: SqlExecutionError -> ByteString
data () => Pool a
instance GHC.Show.Show Orville.PostgreSQL.Raw.Connection.SqlExecutionError
instance GHC.Show.Show Orville.PostgreSQL.Raw.Connection.ConnectionUsedAfterCloseError
instance GHC.Exception.Type.Exception Orville.PostgreSQL.Raw.Connection.ConnectionUsedAfterCloseError
instance GHC.Exception.Type.Exception Orville.PostgreSQL.Raw.Connection.SqlExecutionError
instance GHC.Show.Show Orville.PostgreSQL.Raw.Connection.ConnectionError
instance GHC.Exception.Type.Exception Orville.PostgreSQL.Raw.Connection.ConnectionError


module Orville.PostgreSQL.Raw.PgTime

-- | Renders a <a>Day</a> value to a textual representation for PostgreSQL
dayToPostgreSQL :: Day -> ByteString

-- | An Attoparsec parser for parsing <a>Day</a> from YYYY-MM-DD format.
--   Parsing fails if given an invalid day.
day :: Parser Day

-- | Renders a <a>UTCTime</a> value to a textual representation for
--   PostgreSQL
utcTimeToPostgreSQL :: UTCTime -> ByteString

-- | An Attoparsec parser for parsing <a>UTCTime</a> from an ISO 8601 style
--   datetime and timezone with a few postgresql specific exceptions. See
--   localTime for more details
utcTime :: Parser UTCTime

-- | Renders a 'Time.LocalTime value to a textual representation for
--   PostgreSQL
localTimeToPostgreSQL :: LocalTime -> ByteString

-- | An Attoparsec parser for parsing <a>LocalTime</a> from an ISO 8601
--   style datetime with a few exceptions. The seperator between the date
--   and time is always ' ' and never <tt>T</tt>.
localTime :: Parser LocalTime


-- | The funtions in this module are named with the intent that it is
--   imported qualified as <a>SqlValue</a>.
module Orville.PostgreSQL.Raw.SqlValue

-- | <a>SqlValue</a> represents a value that is in encoded format for use
--   with LibPQ. It is used both for values passed to LibPQ and values
--   parse from LibPQ. The conversions functions in
--   <a>Orville.PostgreSQL.Raw.SqlValue</a> can be used to convert to and
--   from the value.
data SqlValue

-- | Checks whether the <a>SqlValue</a> represents a sql NULL value in the
--   database.
isSqlNull :: SqlValue -> Bool

-- | A value of <a>SqlValue</a> that will be interpreted as a sql NULL
--   value when pasesed to the database.
sqlNull :: SqlValue

-- | Encodes an <a>Int8</a> value for usage with database
fromInt8 :: Int8 -> SqlValue

-- | Attempts to decode a <a>SqlValue</a> as a Haskell <a>Int8</a> value.
--   If decoding fails <a>Nothing</a> is returned.
toInt8 :: SqlValue -> Either String Int8

-- | Encodes an <a>Int16</a> value for usage with database
fromInt16 :: Int16 -> SqlValue

-- | Attempts to decode a <a>SqlValue</a> as a Haskell <a>Int16</a> value.
--   If decoding fails <a>Nothing</a> is returned.
toInt16 :: SqlValue -> Either String Int16

-- | Encodes an <a>Int32</a> value for usage with database
fromInt32 :: Int32 -> SqlValue

-- | Attempts to decode a <a>SqlValue</a> as a Haskell <a>Int32</a> value.
--   If decoding fails <a>Nothing</a> is returned.
toInt32 :: SqlValue -> Either String Int32

-- | Encodes an <a>Int64</a> value for usage with database
fromInt64 :: Int64 -> SqlValue

-- | Attempts to decode a <a>SqlValue</a> as a Haskell <a>Int</a> value. If
--   decoding fails <a>Nothing</a> is returned.
toInt64 :: SqlValue -> Either String Int64

-- | Encodes an <a>Int</a> value for usage with database
fromInt :: Int -> SqlValue

-- | Attempts to decode a <a>SqlValue</a> as a Haskell <a>Int</a> value. If
--   decoding fails <a>Nothing</a> is returned.
toInt :: SqlValue -> Either String Int

-- | Encodes an <a>Word8</a> value for usage with database
fromWord8 :: Word8 -> SqlValue

-- | Attempts to decode a <a>SqlValue</a> as a Haskell <a>Word8</a> value.
--   If decoding fails <a>Nothing</a> is returned.
toWord8 :: SqlValue -> Either String Word8

-- | Encodes an <a>Word16</a> value for usage with database
fromWord16 :: Word16 -> SqlValue

-- | Attempts to decode a <a>SqlValue</a> as a Haskell <a>Word16</a> value.
--   If decoding fails <a>Nothing</a> is returned.
toWord16 :: SqlValue -> Either String Word16

-- | Encodes an <a>Word32</a> value for usage with database
fromWord32 :: Word32 -> SqlValue

-- | Attempts to decode a <a>SqlValue</a> as a Haskell <a>Word32</a> value.
--   If decoding fails <a>Nothing</a> is returned.
toWord32 :: SqlValue -> Either String Word32

-- | Encodes an <a>Word64</a> value for usage with database
fromWord64 :: Word64 -> SqlValue

-- | Attempts to decode a <a>SqlValue</a> as a Haskell <a>Word64</a> value.
--   If decoding fails <a>Nothing</a> is returned.
toWord64 :: SqlValue -> Either String Word64

-- | Encodes an <a>Word</a> value for usage with database
fromWord :: Word -> SqlValue

-- | Attempts to decode a <a>SqlValue</a> as a Haskell <a>Word</a> value.
--   If decoding fails <a>Nothing</a> is returned.
toWord :: SqlValue -> Either String Word

-- | Encodes a <a>Double</a> value for usage with database
fromDouble :: Double -> SqlValue

-- | Attempts to decode a <a>SqlValue</a> as a Haskell <a>Double</a> value.
--   If decoding fails <a>Nothing</a> is returned.
toDouble :: SqlValue -> Either String Double

-- | Encodes a <a>Bool</a> value for usage with database
fromBool :: Bool -> SqlValue

-- | Attempts to decode a <a>SqlValue</a> as a Haskell <a>Bool</a> value.
--   If decoding fails <a>Nothing</a> is returned.
toBool :: SqlValue -> Either String Bool

-- | Encodes a <a>Text</a> value as utf8 so that it can be used with the
--   database.
fromText :: Text -> SqlValue

-- | Attempts to decode a <a>SqlValue</a> as UTF-8 text. If the decoding
--   fails, <a>Nothing</a> is returned.
--   
--   Note: This decoding _only_ fails if the bytes returned from the
--   database are not a value UTF-8 sequence of bytes. Otherwise it always
--   succeeds.
toText :: SqlValue -> Either String Text

-- | Encodes a <a>Day</a> value as text in YYYY-MM-DD format so that it can
--   be used with the database.
fromDay :: Day -> SqlValue

-- | Attempts to decode a <a>SqlValue</a> as into a <a>Day</a> value by
--   parsing it from YYYY-MM-DD format. If the decoding fails
--   <a>Nothing</a> is returned.
toDay :: SqlValue -> Either String Day

-- | Encodes a <a>UTCTime</a> in ISO 8601 format for usage with the
--   database.
fromUTCTime :: UTCTime -> SqlValue

-- | Attempts to decode a <a>SqlValue</a> as a <a>UTCTime</a> formatted in
--   iso8601 format with time zone. If the decoding fails, <a>Nothing</a>
--   is returned.
toUTCTime :: SqlValue -> Either String UTCTime

-- | Encodes a <a>LocalTime</a> in ISO 8601 format for usage with the
--   database.
fromLocalTime :: LocalTime -> SqlValue

-- | Attempts to decode a <a>SqlValue</a> as a <a>LocalTime</a> formatted
--   in iso8601 format in the default Local. If the decoding fails,
--   <a>Nothing</a> is returned.
toLocalTime :: SqlValue -> Either String LocalTime

-- | Creates a <a>SqlValue</a> from a raw byte string as if the bytes had
--   returned by the database. This function does not interpret the bytes
--   in any way, but the using decode functions on them might fail
--   depending on whether the bytes can be parsed as the requested type.
--   
--   Note: A value to represent a sql NULL cannot be constructed using this
--   function. See <a>fromRawBytesNullable</a> for how to represent a
--   nullable raw value.
fromRawBytes :: ByteString -> SqlValue

-- | Creates a <a>SqlValue</a> from a raw byte string. If <a>Nothing</a> is
--   specified as the input parameter then the resulting <a>SqlValue</a>
--   will represent a NULL value in sql. Otherwise the bytes given are used
--   in the same way as <a>fromRawBytes</a>
fromRawBytesNullable :: Maybe ByteString -> SqlValue

-- | Converts a <a>SqlValue</a> to its underlying raw bytes as it will be
--   represented when sent to the database. The output should be
--   recognizable as similar to to values you would write in query. If the
--   value represents a sql NULL value, <a>Nothing</a> is returned
toPgValue :: SqlValue -> Maybe PgTextFormatValue
instance GHC.Classes.Eq Orville.PostgreSQL.Raw.SqlValue.SqlValue


-- | The funtions in this module are named with the intent that it is
--   imported qualified as <a>RawSql</a>.
module Orville.PostgreSQL.Raw.RawSql

-- | <a>RawSql</a> provides a type for efficiently constructing raw sql
--   statements from smaller parts and then executing them. It also
--   supports using placeholder values to pass parameters with a query
--   without having to interpolate them as part of the actual sql state and
--   being exposed to sql injection.
data RawSql

-- | Includes an input parameter in the <a>RawSql</a> statement that will
--   be passed using placeholders (e.g. '$1') rather than being included
--   directly in the sql statement. This is the correct way to include
--   input from untrusted sources as part of a <a>RawSql</a> query. The
--   parameter must be formatted in a textual representation, which the
--   database will interpret. The database type for the value will be
--   inferred by the database based on its usage in the query.
parameter :: SqlValue -> RawSql

-- | Constructs a <a>RawSql</a> from a <a>String</a> value using utf8
--   encoding.
--   
--   Note that because the string is treated as raw sql it completely up to
--   the caller to protected againt sql-injections attacks when using this
--   function. Never use this function with input read from an untrusted
--   source.
fromString :: String -> RawSql

-- | Constructs a <a>RawSql</a> from a <tt>Text</tt> value using utf8
--   encoding.
--   
--   Note that because the text is treated as raw sql it completely up to
--   the caller to protected againt sql-injections attacks when using this
--   function. Never use this function with input read from an untrusted
--   source.
fromText :: Text -> RawSql

-- | Constructs a <a>RawSql</a> from a <tt>ByteString</tt> value, which is
--   assumed to be encoded sensibly for the database to handle.
--   
--   Note that because the string is treated as raw sql it completely up to
--   the caller to protected againt sql-injections attacks when using this
--   function. Never use this function with input read from an untrusted
--   source.
fromBytes :: ByteString -> RawSql

-- | Concatenates a list of <a>RawSql</a> values using another
--   <a>RawSql</a> value as the a separator between the items.
intercalate :: (SqlExpression sql, Foldable f) => RawSql -> f sql -> RawSql

-- | Executes a <a>RawSql</a> value using the <a>executeRaw</a> function.
--   Make sure to read the documentation of <a>executeRaw</a> for caveats
--   and warnings. Use with caution.
--   
--   Note that because this is done in <a>IO</a> no callback functions are
--   available to be called.
execute :: SqlExpression sql => Connection -> sql -> IO Result

-- | Executes a <a>RawSql</a> value using the <a>executeRawVoid</a>
--   function. Make sure to read the documentation of <a>executeRawVoid</a>
--   for caveats and warnings. Use with caution.
--   
--   Note that because this is done in <a>IO</a> no callback functions are
--   available to be called.
executeVoid :: SqlExpression sql => Connection -> sql -> IO ()

-- | Quoting done in IO based using the quoting functions provided by the
--   connection, which can apply quoting based on the specific connection
--   properties.
--   
--   If you don't have a connection available and are only planning on
--   using the SQL for explanatory or example purposes, see
--   <a>exampleQuoting</a>.
connectionQuoting :: Connection -> Quoting IO

-- | Just a plain old space, provided for convenience
space :: RawSql

-- | Just a plain old comma, provided for convenience
comma :: RawSql

-- | Comma space separator, provided for convenience
commaSpace :: RawSql

-- | Just a plain old left paren, provided for convenience
leftParen :: RawSql

-- | Just a plain old right paren, provided for convenience
rightParen :: RawSql

-- | Just a plain period, provided for convenience
dot :: RawSql

-- | Just a plain double quote, provided for convenience
doubleQuote :: RawSql

-- | Just two colons, provided for convenience
doubleColon :: RawSql

-- | Includes a bytestring value as string literal in the SQL statement.
--   The string literal will be quoted and escaped for you, the value
--   provided should not include surrounding quotes or quote special
--   characters.
--   
--   Note: It's better to use the <a>parameter</a> function where possible
--   to pass values to be used as input to a SQL statement. There are some
--   situations where PostgreSQL does not allow this, however (for
--   instance, in some DDL statements). This function is provided for those
--   situations.
stringLiteral :: ByteString -> RawSql

-- | Includes a bytestring value as an identifier in the SQL statement. The
--   identifier will be quoted and escaped for you, the value provided
--   should not include surrounding quotes or quote special characters.
identifier :: ByteString -> RawSql

-- | Constructs a <a>RawSql</a> by putting parentheses around an arbitrary
--   expression. The result is returned as a <a>RawSql</a>. It is up to the
--   caller to decide whether it should be wrapped in a more specific
--   expression type.
parenthesized :: SqlExpression sql => sql -> RawSql

-- | Constructs a <a>RawSql</a> from an <a>Int</a> value. The integral
--   value is included directly in the SQL string, not passed as a
--   parameter. When dealing with user input it is better to use
--   <a>parameter</a> rather whenever possible.
intDecLiteral :: Int -> RawSql

-- | Constructs a <a>RawSql</a> from an <a>Int8</a> value. The integral
--   value is included directly in the SQL string, not passed as a
--   parameter. When dealing with user input it is better to use
--   <a>parameter</a> rather whenever possible.
int8DecLiteral :: Int8 -> RawSql

-- | Constructs a <a>RawSql</a> from an <a>Int16</a> value. The integral
--   value is included directly in the SQL string, not passed as a
--   parameter. When dealing with user input it is better to use
--   <a>parameter</a> rather whenever possible.
int16DecLiteral :: Int16 -> RawSql

-- | Constructs a <a>RawSql</a> from an <a>Int32</a> value. The integral
--   value is included directly in the SQL string, not passed as a
--   parameter. When dealing with user input it is better to use
--   <a>parameter</a> rather whenever possible.
int32DecLiteral :: Int32 -> RawSql

-- | Constructs a <a>RawSql</a> from an <a>Int64</a> value. The integral
--   value is included directly in the SQL string, not passed as a
--   parameter. When dealing with user input it is better to use
--   <a>parameter</a> rather whenever possible.
int64DecLiteral :: Int64 -> RawSql

-- | <a>SqlExpression</a> provides a common interface for converting types
--   to and from <a>RawSql</a>, either via <a>toRawSql</a> and
--   <a>unsafeFromRawSql</a>, or the convenience function
--   <a>unsafeSqlExpression</a>. Orville defines a large number of types
--   that represent various fragments of SQL statements as well as
--   functions to help construct the safely. These funtions can be found in
--   the <a>Expr</a>. These types all provide <a>SqlExpression</a>
--   instances as an escape hatch to allow you to pass any SQL you wish in
--   place of what Orville directly supports. This should be use with great
--   care as Orville cannot guarantee that the SQL you pass can be used to
--   generate valid SQL in conjuction with the rest of the <a>Expr</a> API.
class SqlExpression a
toRawSql :: SqlExpression a => a -> RawSql
unsafeFromRawSql :: SqlExpression a => RawSql -> a

-- | A conveinence function for creating an arbitrary <a>SqlExpression</a>
--   from a <a>String</a>. Great care should be exercised in use of this
--   function as it cannot provide any sort of guarantee that the string
--   passed is usable to generate valid SQL via the rest of Orville's
--   <a>Expr</a> API as the whatever <a>SqlExpression</a> type is returned.
--   
--   For example, if one wanted build a boolean expression not support by
--   Orville, you can do it like so
--   
--   <pre>
--   import qualified Orville.PostgreSQL.Expr as Expr
--   
--   a :: Expr.BooleanExpr
--   a RawSql.unsafeSqlExpression "foo BETWEEN 1  AND 3"
--   </pre>
unsafeSqlExpression :: SqlExpression a => String -> a

-- | Constructs the actual SQL bytestring and parameter values that will be
--   passed to the database to execute a <a>RawSql</a> query. Any string
--   literals thar are included in the SQL expression will be quoting using
--   the given quoting directive.
toBytesAndParams :: (SqlExpression sql, Monad m) => Quoting m -> sql -> m (ByteString, [Maybe PgTextFormatValue])

-- | Builds the bytes that represent the raw sql. These bytes may not be
--   executable on their own, because they may contain placeholders that
--   must be filled in, but can be useful for inspecting sql queries.
toExampleBytes :: SqlExpression sql => sql -> ByteString

-- | Provides procedures for quoting parts of a raw SQL query so that they
--   can be safely executed. Quoting may be done in some <a>Monad</a> m,
--   allowing for the use of quoting operations provided by
--   <a>Connection</a>, which operates in the <a>IO</a> monad.
--   
--   See <a>connectionQuoting</a> and <a>exampleQuoting</a>.
data Quoting m
Quoting :: (ByteString -> m Builder) -> (ByteString -> m Builder) -> Quoting m
[quoteStringLiteral] :: Quoting m -> ByteString -> m Builder
[quoteIdentifier] :: Quoting m -> ByteString -> m Builder

-- | Quoting done in pure Haskell that is suitable for showing SQL
--   examples, but is not guaranteed to be sufficient for all database
--   connections. For quoting that is based on the actual connection to the
--   database, see <a>connectionQuoting</a>.
exampleQuoting :: Quoting Identity
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Raw.RawSql.RawSql
instance GHC.Base.Semigroup Orville.PostgreSQL.Raw.RawSql.RawSql
instance GHC.Base.Monoid Orville.PostgreSQL.Raw.RawSql.RawSql


-- | This module provides the very basics for <a>sqlcommenter</a> support.
module Orville.PostgreSQL.Raw.SqlCommenter

-- | The representation of <a>Text</a> key/value pairs for supporting the
--   sqlcommenter specification. This allows you to attach key/values of
--   <a>Text</a> that supporting systems can use for advanced metrics. See
--   <a>sqlcommenter</a> for details of the specification.
type SqlCommenterAttributes = Map Text Text

-- | Adds a given <tt>SqlCommenter</tt> set of key/value <a>Text</a> pairs
--   to a <a>SqlExpression</a>. This performs all of the required
--   serialization for the given values. Note that no values are
--   automatically added here, so any that you may wish to add can be
--   freely set without a name clash of any kind from this function itself.
addSqlCommenterAttributes :: SqlExpression a => SqlCommenterAttributes -> a -> a


module Orville.PostgreSQL.Expr.Select

-- | Type to represent the <tt>SELECT</tt> part of SQL query E.G.
--   
--   <pre>
--   SELECT
--   </pre>
--   
--   or
--   
--   <pre>
--   SELECT DISTINCT
--   </pre>
--   
--   <a>SelectClause</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data SelectClause

-- | Constructs a <a>SelectClause</a> using the given <a>SelectExpr</a>,
--   which may indicate that this is a <tt>DISTINCT</tt> select.
selectClause :: SelectExpr -> SelectClause

-- | Type to represent the any expression modifying the <tt>SELECT</tt>
--   part of a SQL. E.G.
--   
--   <pre>
--   DISTINCT
--   </pre>
--   
--   <a>SelectExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data SelectExpr

-- | Constructs a <a>SelectExpr</a> that may or may not make the
--   <tt>SELECT</tt> distinct, dependending on whether 'Just Distinct' is
--   passed or not.
selectExpr :: Maybe Distinct -> SelectExpr

-- | A simple value type used to indicate that a <tt>SELECT</tt> should be
--   distinct when constructing a <a>SelectExpr</a>
data Distinct
Distinct :: Distinct
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Select.SelectClause
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Select.SelectExpr


module Orville.PostgreSQL.Expr.Name

-- | Type to represent a SQL table name. <a>TableName</a> values
--   constructed via the <a>tableName</a> function will be properly escaped
--   as part of the generated SQL. E.G.
--   
--   <pre>
--   "some_table_name"
--   </pre>
--   
--   <a>TableName</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data TableName

-- | Construct a <a>TableName</a> from a <a>String</a> with proper escaping
--   as part of the generated SQL.
tableName :: String -> TableName

-- | Type to represent a SQL sequence name. <a>SequenceName</a> values
--   constructed via the <a>sequenceName</a> function will be properly
--   escaped as part of the generated SQL. E.G.
--   
--   <pre>
--   "some_sequence_name"
--   </pre>
--   
--   <a>SequenceName</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data SequenceName

-- | Construct a <a>SequenceName</a> from a <a>String</a> with proper
--   escaping as part of the generated SQL.
sequenceName :: String -> SequenceName

-- | Type to represent a SQL schema name. <a>SchemaName</a> values
--   constructed via the <a>schemaName</a> function will be properly
--   escaped as part of the generated SQL. E.G.
--   
--   <pre>
--   "some_schema_name"
--   </pre>
--   
--   <a>SchemaName</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data SchemaName

-- | Construct a <tt>ColumnName</tt> from a <a>String</a> with proper
--   escaping as part of the generated SQL.
schemaName :: String -> SchemaName

-- | Type to represent a SQL savepoint name. <a>SavepointName</a> values
--   constructed via the <a>savepointName</a> function will be properly
--   escaped as part of the generated SQL. E.G.
--   
--   <pre>
--   "some_savepoint_name"
--   </pre>
--   
--   <a>SavepointName</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data SavepointName

-- | Construct a <a>SavepointName</a> from a <a>String</a> with proper
--   escaping as part of the generated SQL.
savepointName :: String -> SavepointName

-- | Type to represent a qualified SQL name. E.G.
--   
--   <pre>
--   "some_schema_name"."some_table_name"
--   </pre>
--   
--   <a>Qualified</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data Qualified name

-- | Optionally qualifies a <a>TableName</a> with a <a>SchemaName</a>.
--   Generally you would want the higher level function
--   <tt>tableIdQualifiedName</tt>.
qualifyTable :: Maybe SchemaName -> TableName -> Qualified TableName

-- | Optionally qualifies a <a>SequenceName</a> with a <a>SchemaName</a>.
--   Generally you would want the higher level function
--   <tt>sequenceIdQualifiedName</tt>.
qualifySequence :: Maybe SchemaName -> SequenceName -> Qualified SequenceName

-- | Qualifies a <a>ColumnName</a> with a <a>TableName</a> and, optionally,
--   a <a>SchemaName</a>. This should be used to refer to the column in SQL
--   queries where a qualified reference is appropriate.
qualifyColumn :: Maybe SchemaName -> TableName -> ColumnName -> Qualified ColumnName

-- | Type to represent a SQL index name. <a>IndexName</a> values
--   constructed via the <a>indexName</a> function will be properly escaped
--   as part of the generated SQL. E.G.
--   
--   <pre>
--   "some_index_name"
--   </pre>
--   
--   <a>IndexName</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data IndexName

-- | Construct a <a>IndexName</a> from a <a>String</a> with proper escaping
--   as part of the generated SQL.
indexName :: String -> IndexName

-- | Type to represent a SQL identifier. <a>Identifier</a> values
--   constructed via the <a>identifier</a> function will be properly
--   escaped as part of the generated SQL. E.G.
--   
--   <pre>
--   "some_identifier"
--   </pre>
--   
--   <tt>Identifer</tt> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data Identifier

-- | Construct an <a>Identifier</a> from a <a>String</a> with proper
--   escaping as part of the generated SQL.
identifier :: String -> Identifier

-- | Construct an <a>Identifier</a> from a <a>ByteString</a> with proper
--   escaping as part of the generated SQL.
identifierFromBytes :: ByteString -> Identifier

-- | This class aids in giving additional polymorphism and so that many
--   different identifiers can be created without being forced to only use
--   the <a>Identifier</a> type.
class IdentifierExpression name

toIdentifier :: IdentifierExpression name => name -> Identifier

fromIdentifier :: IdentifierExpression name => Identifier -> name

-- | Type to represent a SQL function name. <a>FunctionName</a> values
--   constructed via the <a>functionName</a> function will be properly
--   escaped as part of the generated SQL. E.G.
--   
--   <pre>
--   "some_function_name"
--   </pre>
--   
--   <a>FunctionName</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data FunctionName

-- | Construct a <a>FunctionName</a> from a <a>String</a> with proper
--   escaping as part of the generated SQL.
functionName :: String -> FunctionName

-- | Type to represent a SQL cursor name. <a>CursorName</a> values
--   constructed via the <a>cursorName</a> function will be properly
--   escaped as part of the generated SQL. E.G.
--   
--   <pre>
--   "some_cursor_name"
--   </pre>
--   
--   <a>CursorName</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data CursorName

-- | Construct a <a>CursorName</a> from a <a>String</a> with proper
--   escaping as part of the generated SQL.
cursorName :: String -> CursorName

-- | Type to represent a SQL constraint name. <a>ConstraintName</a> values
--   constructed via the <a>constraintName</a> function will be properly
--   escaped as part of the generated SQL. E.G.
--   
--   <pre>
--   "some_constraint_name"
--   </pre>
--   
--   <a>ConstraintName</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data ConstraintName

-- | Construct a <a>ConstraintName</a> from a <a>String</a> with proper
--   escaping as part of the generated SQL.
constraintName :: String -> ConstraintName

-- | Type to represent a SQL column name. <a>ColumnName</a> values
--   constructed via the <a>columnName</a> function will be properly
--   escaped as part of the generated SQL. E.G.
--   
--   <pre>
--   "some_column_name"
--   </pre>
--   
--   <a>ColumnName</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data ColumnName

-- | Construct a <a>ColumnName</a> from a <a>String</a> with proper
--   escaping as part of the generated SQL.
columnName :: String -> ColumnName


module Orville.PostgreSQL.Expr.Transaction

-- | Type to represent the name of a begin transaction statement. E.G.
--   
--   <pre>
--   BEGIN TRANSACTION
--   </pre>
--   
--   <a>BeginTransactionExpr</a> provides a <a>SqlExpression</a> instance.
--   See <a>unsafeSqlExpression</a> for how to construct a value with your
--   own custom SQL.
data BeginTransactionExpr

-- | Constructs a <a>BeginTransactionExpr</a> that will begin a transaction
--   using the specified mode, if any.
beginTransaction :: Maybe TransactionMode -> BeginTransactionExpr

-- | Type to represent the a transaction mode. E.G.
--   
--   <pre>
--   ISOLATION LEVEL SERIALIZABLE
--   </pre>
--   
--   <a>TransactionMode</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data TransactionMode

-- | The <tt>READ WRITE</tt> transaction mode.
readWrite :: TransactionMode

-- | The <tt>READ ONLY</tt> transaction mode.
readOnly :: TransactionMode

-- | The <tt>DEFERRABLE</tt> transaction mode.
deferrable :: TransactionMode

-- | The <tt>NOT DEFERRABLE</tt> transaction mode.
notDeferrable :: TransactionMode

-- | An <tt>ISOLATION LEVEL</tt> transaction mode with the given
--   <a>IsolationLevel</a>.
isolationLevel :: IsolationLevel -> TransactionMode

-- | Type to represent the a transaction isolation level. E.G.
--   
--   <pre>
--   SERIALIZABLE
--   </pre>
--   
--   <a>IsolationLevel</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data IsolationLevel

-- | The <tt>SERIALIZABLE</tt> isolation level.
serializable :: IsolationLevel

-- | The <tt>REPEATABLE READ</tt> isolation level.
repeatableRead :: IsolationLevel

-- | The <tt>READ COMMITTED</tt> isolation level.
readCommitted :: IsolationLevel

-- | The <tt>READ UNCOMMITTED</tt> isolation level.
readUncommitted :: IsolationLevel

-- | Type to represent the transaction commit statement. E.G.
--   
--   <pre>
--   COMMIT
--   </pre>
--   
--   <a>CommitExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data CommitExpr

-- | A <tt>COMMIT</tt> transaction statement
commit :: CommitExpr

-- | Type to represent the transaction rollback statement. E.G.
--   
--   <pre>
--   ROLLBACK
--   </pre>
--   
--   <a>RollbackExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data RollbackExpr

-- | A <tt>ROLLBACK</tt> transaction statement
rollback :: RollbackExpr

-- | A <tt>ROLLBACK TO</tt> transaction statement that will rollback to the
--   specified savepoint.
rollbackTo :: SavepointName -> RollbackExpr

-- | Type to represent the transaction savepoint statement. E.G.
--   
--   <pre>
--   SAVEPOINT foo
--   </pre>
--   
--   <a>SavepointExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data SavepointExpr

-- | A <tt>SAVEPOINT</tt> statement that will create a savepoint with the
--   given name.
savepoint :: SavepointName -> SavepointExpr

-- | Type to represent the transaction release savepoint statement. E.G.
--   
--   <pre>
--   RELEASE SAVEPOINT foo
--   </pre>
--   
--   <a>ReleaseSavepointExpr</a> provides a <a>SqlExpression</a> instance.
--   See <a>unsafeSqlExpression</a> for how to construct a value with your
--   own custom SQL.
data ReleaseSavepointExpr

-- | A <tt>RELEASE SAVEPOINT</tt> statement that will release the specified
--   savepoint.
releaseSavepoint :: SavepointName -> ReleaseSavepointExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Transaction.BeginTransactionExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Transaction.TransactionMode
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Transaction.IsolationLevel
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Transaction.CommitExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Transaction.RollbackExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Transaction.SavepointExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Transaction.ReleaseSavepointExpr


module Orville.PostgreSQL.Expr.TableReferenceList

-- | Type to represent the tables references in the <tt>FROM</tt> clause of
--   a @SELECT statement. E.G. just the
--   
--   <pre>
--   foo
--   </pre>
--   
--   in
--   
--   <pre>
--   FROM foo
--   </pre>
--   
--   <a>TableReferenceList</a> provides a <a>SqlExpression</a> instance.
--   See <a>unsafeSqlExpression</a> for how to construct a value with your
--   own custom SQL.
data TableReferenceList

-- | Constructs a <a>TableReferenceList</a> consisting of just the
--   specified table name.
referencesTable :: Qualified TableName -> TableReferenceList
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.TableReferenceList.TableReferenceList


module Orville.PostgreSQL.Expr.TableConstraint

-- | Type to represent a table constraint that would be part of a
--   <tt>CREATE TABLE</tt> or <tt>ALTER TABLE</tt> statement. For
--   instances, the <tt>UNIQUE</tt> constraint in
--   
--   <pre>
--   CREATE TABLE FOO
--    ( id integer
--    , UNIQUE id
--    )
--   </pre>
--   
--   <a>TableConstraint</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data TableConstraint

-- | Constructs a <a>TableConstraint</a> will create a <tt>UNIQUE</tt>
--   constraint on the given columns.
uniqueConstraint :: NonEmpty ColumnName -> TableConstraint

-- | Constructs a <a>TableConstraint</a> that represent a <tt>FOREIGN
--   KEY</tt> constraint
foreignKeyConstraint :: NonEmpty ColumnName -> Qualified TableName -> NonEmpty ColumnName -> Maybe ForeignKeyUpdateActionExpr -> Maybe ForeignKeyDeleteActionExpr -> TableConstraint

-- | Type to represent a foreign key action on a <tt>FOREIGN KEY</tt>
--   constraint. E.G. the <tt>CASCADE</tt> in
--   
--   <pre>
--   FOREIGN KEY (foo_id) REFERENCES foo (id) ON DELETE CASCADE
--   </pre>
--   
--   <a>ForeignKeyActionExpr</a> provides a <a>SqlExpression</a> instance.
--   See <a>unsafeSqlExpression</a> for how to construct a value with your
--   own custom SQL.
data ForeignKeyActionExpr

-- | The foreign key action <tt>RESTRICT</tt>.
restrictExpr :: ForeignKeyActionExpr

-- | The foreign key action <tt>CASCADE</tt>.
cascadeExpr :: ForeignKeyActionExpr

-- | The foreign key action <tt>SET NULL</tt>.
setNullExpr :: ForeignKeyActionExpr

-- | The foreign key action <tt>SET DEFAULT</tt>.
setDefaultExpr :: ForeignKeyActionExpr

-- | Type to represent an foreign key update action on a <tt>FOREIGN
--   KEY</tt> constraint. E.G. the <tt>ON DELETE RESTRICT</tt> in
--   
--   <pre>
--   FOREIGN KEY (foo_id) REFERENCES foo (id) ON DELETE RESTRICT
--   </pre>
--   
--   <a>ForeignKeyDeleteActionExpr</a> provides a <a>SqlExpression</a>
--   instance. See <a>unsafeSqlExpression</a> for how to construct a value
--   with your own custom SQL.
data ForeignKeyDeleteActionExpr

-- | Constructs a <a>ForeignKeyActionExpr</a> that use the given
--   <a>ForeignKeyActionExpr</a> in an <tt>ON UPDATE</tt> clause for a
--   foreign key.
foreignKeyDeleteActionExpr :: ForeignKeyActionExpr -> ForeignKeyDeleteActionExpr

-- | Type to represent an foreign key update action on a <tt>FOREIGN
--   KEY</tt> constraint. E.G. the <tt>ON UPDATE RESTRICT</tt> in
--   
--   <pre>
--   FOREIGN KEY (foo_id) REFERENCES foo (id) ON UPDATE RESTRICT
--   </pre>
--   
--   <a>ForeignKeyUpdateActionExpr</a> provides a <a>SqlExpression</a>
--   instance. See <a>unsafeSqlExpression</a> for how to construct a value
--   with your own custom SQL.
data ForeignKeyUpdateActionExpr

-- | Constructs a <a>ForeignKeyActionExpr</a> that use the given
--   <a>ForeignKeyActionExpr</a> in an <tt>ON UPDATE</tt> clause for a
--   foreign key.
foreignKeyUpdateActionExpr :: ForeignKeyActionExpr -> ForeignKeyUpdateActionExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.TableConstraint.TableConstraint
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.TableConstraint.ForeignKeyActionExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.TableConstraint.ForeignKeyUpdateActionExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.TableConstraint.ForeignKeyDeleteActionExpr


module Orville.PostgreSQL.Expr.OrderBy

-- | Type to represent a SQL order by clause. E.G.
--   
--   <pre>
--   ORDER BY foo, bar
--   </pre>
--   
--   <a>OrderByClause</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data OrderByClause
orderByClause :: OrderByExpr -> OrderByClause

-- | Type to represent a SQL order by expression (the part that follows the
--   <tt>ORDER BY</tt> in sql). E.G.
--   
--   <pre>
--   foo, bar
--   </pre>
--   
--   <a>OrderByExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data OrderByExpr

-- | Combines two <a>OrderByExpr</a>s with a comma between them.
appendOrderByExpr :: OrderByExpr -> OrderByExpr -> OrderByExpr
orderByColumnName :: ColumnName -> OrderByDirection -> OrderByExpr

-- | Create a <a>OrderByExpr</a> from some <tt>RawSql</tt> and a
--   <a>OrderByDirection</a>. Note that it is up to the caller to ensure
--   that the given value can actually be used for a <a>OrderByExpr</a>
orderByExpr :: RawSql -> OrderByDirection -> OrderByExpr

-- | Create a <a>OrderByExpr</a> for <a>ColumnName</a> and
--   <a>OrderByDirection</a> pairs, ensuring commas as needed.
orderByColumnsExpr :: NonEmpty (ColumnName, OrderByDirection) -> OrderByExpr

-- | Type to represent a SQL order by direction expression. E.G.
--   
--   <pre>
--   ASC
--   </pre>
--   
--   <a>OrderByDirection</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data OrderByDirection

-- | Type to represent the ordering of Null, intended to be used with
--   <a>OrderByDirection</a>.
data NullsOrder
NullsFirst :: NullsOrder
NullsLast :: NullsOrder

-- | The SQL ASC order direction.
ascendingOrder :: OrderByDirection

-- | The SQL DESC order direction.
descendingOrder :: OrderByDirection

-- | The SQL ASC order direction with NULLs ordered as given.
ascendingOrderWith :: NullsOrder -> OrderByDirection

-- | The SQL DESC order direction with NULLs ordered as given.
descendingOrderWith :: NullsOrder -> OrderByDirection
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.OrderBy.OrderByClause
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.OrderBy.OrderByExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.OrderBy.OrderByDirection
instance GHC.Enum.Bounded Orville.PostgreSQL.Expr.OrderBy.NullsOrder
instance GHC.Enum.Enum Orville.PostgreSQL.Expr.OrderBy.NullsOrder
instance GHC.Classes.Ord Orville.PostgreSQL.Expr.OrderBy.NullsOrder
instance GHC.Show.Show Orville.PostgreSQL.Expr.OrderBy.NullsOrder
instance GHC.Classes.Eq Orville.PostgreSQL.Expr.OrderBy.NullsOrder
instance GHC.Base.Semigroup Orville.PostgreSQL.Expr.OrderBy.OrderByExpr


module Orville.PostgreSQL.Expr.Index

-- | Type to represent a SQL "CREATE INDEX" statement. E.G.
--   
--   <pre>
--   CREATE INDEX ON table (foo, bar, baz)
--   </pre>
--   
--   <a>CreateIndexExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data CreateIndexExpr

-- | Construct a SQL CREATE INDEX from an indicator of if the index should
--   be unique, a table, and corresponding collection of
--   <a>ColumnName</a>s.
createIndexExpr :: IndexUniqueness -> Maybe ConcurrentlyExpr -> Qualified TableName -> NonEmpty ColumnName -> CreateIndexExpr

-- | Type to represent if an index should be unique.
data IndexUniqueness
UniqueIndex :: IndexUniqueness
NonUniqueIndex :: IndexUniqueness

-- | Type to represent if the body of an index definition E.G.
--   
--   <pre>
--   (foo, bar)
--   </pre>
--   
--   in
--   
--   <pre>
--   CREATE some_index ON some_table (foo, bar)
--   </pre>
--   
--   <a>IndexBodyExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data IndexBodyExpr

-- | Creates an <a>IndexBodyExpr</a> for the given column names. The
--   resulting SQL looks like <tt>(column1, column2, ...)</tt>.
indexBodyColumns :: NonEmpty ColumnName -> IndexBodyExpr

-- | Type to represent the <tt>CONCURRENTLY</tt> keyword for index
--   creation. E.G.
--   
--   <pre>
--   CONCURRENTLY
--   </pre>
--   
--   <a>ConcurrentlyExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data ConcurrentlyExpr

-- | The <tt>CONCURRENTLY</tt> keyword indicates to PostgreSQL that an
--   index should be create concurrently.
concurrently :: ConcurrentlyExpr

-- | Type to represent a SQL "DROP INDEX" statement. E.G.
--   
--   <pre>
--   DROP INDEX foo
--   </pre>
--   
--   <a>DropIndexExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data DropIndexExpr

-- | Construct a SQL DROP INDEX for a given <a>IndexName</a>.
dropIndexExpr :: IndexName -> DropIndexExpr

-- | Construct a SQL CREATE INDEX from an indicator of if the index should
--   be unique, a table, a name for the index, and some sql representing
--   the rest of the index creation.
createNamedIndexExpr :: IndexUniqueness -> Maybe ConcurrentlyExpr -> Qualified TableName -> IndexName -> IndexBodyExpr -> CreateIndexExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Index.CreateIndexExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Index.ConcurrentlyExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Index.IndexBodyExpr
instance GHC.Show.Show Orville.PostgreSQL.Expr.Index.IndexUniqueness
instance GHC.Classes.Ord Orville.PostgreSQL.Expr.Index.IndexUniqueness
instance GHC.Classes.Eq Orville.PostgreSQL.Expr.Index.IndexUniqueness
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Index.DropIndexExpr


module Orville.PostgreSQL.Expr.IfExists

-- | Type to represent a SQL "IF EXISTS" expression. E.G.
--   
--   <pre>
--   IF EXISTS
--   </pre>
--   
--   <a>IfExists</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data IfExists

-- | A value of the SQL "IF EXISTS"
ifExists :: IfExists
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.IfExists.IfExists


module Orville.PostgreSQL.Expr.GroupBy

-- | Type to represent a SQL group by clause. E.G.
--   
--   <pre>
--   GROUP BY team_name
--   </pre>
--   
--   <a>GroupByClause</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data GroupByClause

-- | Create a full sql GROUP BY clause with the given expression.
groupByClause :: GroupByExpr -> GroupByClause

-- | Type to represent a SQL group by expression (the part that follows the
--   <tt>GROUP BY</tt> in sql). E.G.
--   
--   <pre>
--   team_name
--   </pre>
--   
--   <a>GroupByExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data GroupByExpr

-- | Combines two <a>GroupByExpr</a>s with a comma between them.
appendGroupByExpr :: GroupByExpr -> GroupByExpr -> GroupByExpr

-- | Create a <a>GroupByExpr</a> from some <tt>RawSql</tt>. Note that it is
--   up to the caller to ensure that the given value can actually be used
--   for a <a>GroupByExpr</a>
groupByExpr :: RawSql -> GroupByExpr

-- | Create a <a>GroupByExpr</a> from the given <a>ColumnName</a>s.
groupByColumnsExpr :: NonEmpty ColumnName -> GroupByExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.GroupBy.GroupByClause
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.GroupBy.GroupByExpr
instance GHC.Base.Semigroup Orville.PostgreSQL.Expr.GroupBy.GroupByExpr


module Orville.PostgreSQL.Expr.DataType

-- | Type to represent any SQL data type expression. E.G.
--   
--   <pre>
--   INTEGER
--   </pre>
--   
--   <a>DataType</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data DataType

-- | A <a>DataType</a> that represents the PostgreSQL "TIMESTAMP with time
--   zone" data type.
--   
--   See <a>postgresql documentation</a> for more information.
timestampWithZone :: DataType

-- | A <a>DataType</a> that represents the PostgreSQL "TIMESTAMP without
--   time zone" data type.
--   
--   See <a>postgresql documentation</a> for more information.
timestampWithoutZone :: DataType

-- | A <a>DataType</a> that represents the PostgreSQL <a>DATE</a> data
--   type.
--   
--   See <a>postgresql documentation</a> for more information.
date :: DataType

-- | A <a>DataType</a> that represents the PostgreSQL <a>TSVECTOR</a> data
--   type.
--   
--   See <a>postgresql documentation</a> for more information.
tsvector :: DataType

-- | A <a>DataType</a> that represents the PostgreSQL "VARCHAR(n)" data
--   type.
--   
--   See <a>postgresql documentation</a> for more information.
varchar :: Int32 -> DataType

-- | A <a>DataType</a> that represents the PostgreSQL "CHAR(n)" data type.
--   
--   See <a>postgresql documentation</a> for more information.
char :: Int32 -> DataType

-- | A <a>DataType</a> that represents the PostgreSQL <a>TEXT</a> data
--   type.
--   
--   See <a>postgresql documentation</a> for more information.
text :: DataType

-- | A <a>DataType</a> that represents the PostgreSQL <a>UUID</a> data
--   type.
--   
--   See <a>postgresql documentation</a> for more information.
uuid :: DataType

-- | A <a>DataType</a> that represents the PostgreSQL <a>BOOLEAN</a> data
--   type.
--   
--   See <a>postgresql documentation</a> for more information.
boolean :: DataType

-- | A <a>DataType</a> that represents the PostgreSQL "DOUBLE PRECISION"
--   data type.
--   
--   See <a>postgresql documentation</a> for more information.
doublePrecision :: DataType

-- | A <a>DataType</a> that represents the PostgreSQL <a>BIGSERIAL</a> data
--   type.
--   
--   See <a>postgresql documentation</a> for more information.
bigSerial :: DataType

-- | A <a>DataType</a> that represents the PostgreSQL <a>BIGINT</a> data
--   type.
--   
--   See <a>postgresql documentation</a> for more information.
bigInt :: DataType

-- | A <a>DataType</a> that represents the PostgreSQL <a>SERIAL</a> data
--   type.
--   
--   See <a>postgresql documentation</a> for more information.
serial :: DataType

-- | A <a>DataType</a> that represents the PostgreSQL <a>INT</a> data type.
--   
--   See <a>postgresql documentation</a> for more information.
int :: DataType

-- | A <a>DataType</a> that represents the PostgreSQL <a>SMALLINT</a> data
--   type.
--   
--   See <a>postgresql documentation</a> for more information.
smallint :: DataType

-- | A <a>DataType</a> that represents the PostgreSQL <a>JSONB</a> data
--   type.
--   
--   See <a>postgresql documentation</a> for more information.
jsonb :: DataType

-- | A <a>DataType</a> that represents the PostgreSQL <a>OID</a> data type.
--   
--   See <a>postgresql documentation</a> for more information.
oid :: DataType
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.DataType.DataType


module Orville.PostgreSQL.Marshall.MarshallError

-- | A <a>MarshallError</a> may be returned from
--   <tt>marshallResultFromSql</tt> when a row being decoded from the
--   database doesn't meet the expectations of the <tt>SqlMarshaller</tt>
--   that is decoding it.
data MarshallError
MarshallError :: ErrorDetailLevel -> [(ByteString, SqlValue)] -> MarshallErrorDetails -> MarshallError

-- | The level of details that will be used to render this error as a
--   message if <a>show</a> is called
[marshallErrorDetailLevel] :: MarshallError -> ErrorDetailLevel

-- | The identifier of the row that caused the error. This is a list of
--   pairs of column name and value in their raw form from the database to
--   avoid further possible decoding errors when reading the values
[marshallErrorRowIdentifier] :: MarshallError -> [(ByteString, SqlValue)]

-- | The detailed information about the error that occurred during decoding
[marshallErrorDetails] :: MarshallError -> MarshallErrorDetails

-- | Renders a <a>MarshallError</a> to a string using the specified
--   <a>ErrorDetailLevel</a>.
--   
--   This ingores any <a>ErrorDetailLevel</a> that was captured by default
--   from the Orville context and uses the specified level of detail
--   instead.
--   
--   You may want to use this function to render certain with a higher
--   level of detail that you consider safe for (for example) you
--   application logs while using a lower default error detail level to be
--   used with the <a>Show</a> instance of <tt>MarhallError</tt> in case an
--   exception is handled in a more visible section of code that return
--   information more publicly (e.g. a request handler for a public
--   endpoint).
renderMarshallError :: ErrorDetailLevel -> MarshallError -> String

-- | A <a>MarshallErrorDetails</a> may be returned from
--   <tt>marshallFromSql</tt> if the result set being decoded from the
--   database doesn't meet the expectations of the <tt>SqlMarshaller</tt>
--   that is decoding it.
data MarshallErrorDetails

-- | Indicates that a one ore more values in a columns could not be
--   decoded, either individually or as a group
DecodingError :: DecodingErrorDetails -> MarshallErrorDetails

-- | Indicates that an expected column was not found in the result set
MissingColumnError :: MissingColumnErrorDetails -> MarshallErrorDetails

-- | Renders a <a>MarshallErrorDetails</a> to a <a>String</a> with a
--   specified <a>ErrorDetailLevel</a>.
renderMarshallErrorDetails :: ErrorDetailLevel -> MarshallErrorDetails -> String

-- | Details about an error that occurred while decoding values found a SQL
--   result set.
data DecodingErrorDetails
DecodingErrorDetails :: [(ByteString, SqlValue)] -> String -> DecodingErrorDetails
[decodingErrorValues] :: DecodingErrorDetails -> [(ByteString, SqlValue)]
[decodingErrorMessage] :: DecodingErrorDetails -> String

-- | Renders a 'DecodingErrorDetails to a <a>String</a> with a specified
--   <a>ErrorDetailLevel</a>.
renderDecodingErrorDetails :: ErrorDetailLevel -> DecodingErrorDetails -> String

-- | Details about an column that was found to be missing in a SQL result
--   set during decoding.
data MissingColumnErrorDetails
MissingColumnErrorDetails :: ByteString -> Set ByteString -> MissingColumnErrorDetails
[missingColumnName] :: MissingColumnErrorDetails -> ByteString
[actualColumnNames] :: MissingColumnErrorDetails -> Set ByteString

-- | Renders a <a>MissingColumnErrorDetails</a> to a <a>String</a> with a
--   specified <a>ErrorDetailLevel</a>.
renderMissingColumnErrorDetails :: ErrorDetailLevel -> MissingColumnErrorDetails -> String
instance GHC.Show.Show Orville.PostgreSQL.Marshall.MarshallError.MarshallError
instance GHC.Exception.Type.Exception Orville.PostgreSQL.Marshall.MarshallError.MarshallError


module Orville.PostgreSQL.Expr.ValueExpression

-- | Type to represent an arbitrary value in a SQL expression. This could
--   be a constant value, a column reference or any arbitrary calculated
--   expression. E.G.
--   
--   <pre>
--   (foo + bar) &gt; 20
--   </pre>
--   
--   <a>ValueExpression</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data ValueExpression

-- | Performs a SQL type cast to the specified type on the given
--   <a>ValueExpression</a>. E.G.
--   
--   <pre>
--   foo :: integer
--   </pre>
cast :: ValueExpression -> DataType -> ValueExpression

-- | Type to represent the name of a name parameter in PostgreSQL function
--   call. E.G.
--   
--   <pre>
--   foo
--   </pre>
--   
--   in
--   
--   <pre>
--   some_func(foo =&gt; 1)
--   </pre>
--   
--   <a>ParameterName</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data ParameterName

-- | Uses a <a>ColumnName</a> to reference a column as a
--   <a>ValueExpression</a>. This is the equivalent of simply writing the
--   column name as the expression. E.G.
--   
--   <pre>
--   foo
--   </pre>
columnReference :: ColumnName -> ValueExpression

-- | Uses the given <a>SqlValue</a> as a constant expression. The value
--   will be passed as a statement parameter, not as a literal expression,
--   so there is not need to worry about escaping. However, there are a few
--   places (usually in DDL) where PostgreSQL does not support values
--   passed as paremeters where this cannot be used.
valueExpression :: SqlValue -> ValueExpression

-- | Constructs a PostgreSQL row value expression from the given list of
--   expressions. E.G.
--   
--   <pre>
--   (foo, bar, now())
--   </pre>
rowValueConstructor :: NonEmpty ValueExpression -> ValueExpression

-- | Constructs a <a>ValueExpression</a> that will call the specified
--   PostgreSQL function with the given arguments passed as position
--   parameters. E.G.
--   
--   <pre>
--   nextval(sequence_name)
--   </pre>
functionCall :: FunctionName -> [ValueExpression] -> ValueExpression

-- | Constructs a <a>ValueExpression</a> that will call the specified
--   PostgreSQL function with the given arguments passed as named
--   parameters. E.G.
--   
--   <pre>
--   make_interval(years =&gt; 1)
--   </pre>
functionCallNamedParams :: FunctionName -> [(ParameterName, ValueExpression)] -> ValueExpression
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.ValueExpression.ValueExpression
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.ValueExpression.ParameterName


module Orville.PostgreSQL.Expr.Time

-- | The value of the current time as returned by the PostgreSQL function
--   <tt>now()</tt>.
now :: ValueExpression

-- | Constructs a <a>ValueExpression</a> whose value in PostgreSQL is the
--   result of calling <tt>make_interval</tt> with the specified time
--   intervals passed as named arguments.
makeInterval :: [(IntervalArgument, ValueExpression)] -> ValueExpression

-- | Type to represent the name of a time interval argument to the
--   PostgreSQL <tt>make_interval</tt> function. E.G.
--   
--   <pre>
--   years
--   </pre>
--   
--   <a>IntervalArgument</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data IntervalArgument

-- | The <tt>years</tt> argument to <tt>make_interval</tt>.
years :: IntervalArgument

-- | The <tt>months</tt> argument to <tt>make_interval</tt>.
months :: IntervalArgument

-- | The <tt>weeks</tt> argument to <tt>make_interval</tt>.
weeks :: IntervalArgument

-- | The <tt>days</tt> argument to <tt>make_interval</tt>.
days :: IntervalArgument

-- | The <tt>hours</tt> argument to <tt>make_interval</tt>.
hours :: IntervalArgument

-- | The <tt>mins</tt> argument to <tt>make_interval</tt>.
minutes :: IntervalArgument

-- | The <tt>secs</tt> argument to <tt>make_interval</tt>.
seconds :: IntervalArgument
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Time.IntervalArgument


module Orville.PostgreSQL.Expr.Count

-- | Given a <a>ValueExpression</a>, use it as the argument to the SQL
--   <tt>count</tt>
count :: ValueExpression -> ValueExpression

-- | The SQL <tt>count</tt> function
countFunction :: FunctionName

-- | The SQL <tt>count(1)</tt>
count1 :: ValueExpression

-- | Use a given column as the argument to the SQL <tt>count</tt>
countColumn :: ColumnName -> ValueExpression


module Orville.PostgreSQL.Expr.ColumnDefinition

-- | Represent a complete definition of a column. E.G.
--   
--   <pre>
--   foo INTEGER
--   </pre>
--   
--   <a>ColumnDefinition</a> provides' a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data ColumnDefinition

-- | Smart constructor for ensuring a <a>ColumnDefinition</a> is setup
--   correctly.
columnDefinition :: ColumnName -> DataType -> Maybe ColumnConstraint -> Maybe ColumnDefault -> ColumnDefinition

-- | Represent constraints, such as nullability, on a column. E.G.
--   
--   <pre>
--   NOT NULL
--   </pre>
--   
--   <a>ColumnConstraint</a> provides' a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data ColumnConstraint

-- | Express that a column may not contain NULL.
notNullConstraint :: ColumnConstraint

-- | Express that a column may contain NULL.
nullConstraint :: ColumnConstraint

-- | Represents the default value of a column. E.G.
--   
--   <pre>
--   now()
--   </pre>
--   
--   <a>ColumnDefault</a> provides' a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data ColumnDefault

-- | Given a <a>ValueExpression</a> use that as a <a>ColumnDefault</a>.
--   This is the preferred path to creating a column default. Note that it
--   is up to the caller to ensure the <a>ValueExpression</a> makes sense
--   for the resulting <a>ColumnDefinition</a> this will be a part of.
columnDefault :: ValueExpression -> ColumnDefault
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.ColumnDefinition.ColumnDefinition
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.ColumnDefinition.ColumnConstraint
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.ColumnDefinition.ColumnDefault


module Orville.PostgreSQL.Expr.TableDefinition

-- | Type to represent a <tt>CREATE TABLE</tt> statement. E.G.
--   
--   <pre>
--   CREATE TABLE foo (id integer)
--   </pre>
--   
--   <a>CreateTableExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data CreateTableExpr

-- | Constructs a <a>CreateTableExpr</a> with the given options.
createTableExpr :: Qualified TableName -> [ColumnDefinition] -> Maybe PrimaryKeyExpr -> [TableConstraint] -> CreateTableExpr

-- | Type to represent a the primary key of a table. E.G.
--   
--   <pre>
--   PRIMARY KEY (id)
--   </pre>
--   
--   <a>PrimaryKeyExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data PrimaryKeyExpr

-- | Constructs a <a>PrimaryKeyExpr</a> with the given columns
primaryKeyExpr :: NonEmpty ColumnName -> PrimaryKeyExpr

-- | Type to represent a <tt>ALTER TABLE</tt> statement. E.G.
--   
--   <pre>
--   ALTER TABLE foo ADD COLUMN bar integer
--   </pre>
--   
--   <a>AlterTableExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data AlterTableExpr

-- | Constructs an <a>AlterTableExpr</a> with the given alter table
--   actions.
alterTableExpr :: Qualified TableName -> NonEmpty AlterTableAction -> AlterTableExpr

-- | Type to represent an action as part of an <tt>ALTER TABLE</tt>
--   statement. E.G.
--   
--   <pre>
--   ADD COLUMN bar integer
--   </pre>
--   
--   <a>AlterTableAction</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data AlterTableAction

-- | Constructs an <a>AlterTableAction</a> that will add the specified
--   column to the table.
addColumn :: ColumnDefinition -> AlterTableAction

-- | Constructs an <a>AlterTableAction</a> that will drop the specified
--   column from the table.
dropColumn :: ColumnName -> AlterTableAction

-- | Constructs an <a>AlterTableAction</a> that will add the specified
--   constraint to the table.
addConstraint :: TableConstraint -> AlterTableAction

-- | Constructs an <a>AlterTableAction</a> that will drop the specified
--   constraint from the table.
dropConstraint :: ConstraintName -> AlterTableAction

-- | Constructs an <a>AlterTableAction</a> that will alter the type of the
--   specified column.
alterColumnType :: ColumnName -> DataType -> Maybe UsingClause -> AlterTableAction

-- | Constructs an <a>AlterTableAction</a> that will use <tt>SET
--   DEFAULT</tt> to set the default value of the specified column.
alterColumnSetDefault :: SqlExpression valueExpression => ColumnName -> valueExpression -> AlterTableAction

-- | Constructs an <a>AlterTableAction</a> that will use <tt>DROP
--   DEFAULT</tt> to drop the default value of the specified column.
alterColumnDropDefault :: ColumnName -> AlterTableAction

-- | Type to represent a <tt>USING</tt> clause as part of an <tt>ALTER
--   COLUMN</tt> when changing the type of a column. E.G.
--   
--   <pre>
--   USING id :: integer
--   </pre>
--   
--   <a>UsingClause</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data UsingClause

-- | Constructs a <a>UsingClause</a> that will cast the column to the
--   specified type.
usingCast :: ColumnName -> DataType -> UsingClause

-- | Constructs an <a>AlterTableAction</a> that will alter the nullability
--   of the column.
alterColumnNullability :: ColumnName -> AlterNotNull -> AlterTableAction

-- | Type to represent an action to alter the nullability of a column. E.G.
--   
--   <pre>
--   SET NOT NULL
--   </pre>
--   
--   <a>AlterNotNull</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data AlterNotNull

-- | Sets the column to not null via <tt>SET NOT NULL</tt>
setNotNull :: AlterNotNull

-- | Sets the column to allow null via <tt>DROP NOT NULL</tt>
dropNotNull :: AlterNotNull

-- | Type to represent a <tt>DROP TABLE</tt> statement. E.G.
--   
--   <pre>
--   DROP TABLE FOO
--   </pre>
--   
--   <a>DropTableExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data DropTableExpr

-- | Constructs an <a>DropTableExpr</a> that will drop the specified table.
dropTableExpr :: Maybe IfExists -> Qualified TableName -> DropTableExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.TableDefinition.CreateTableExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.TableDefinition.PrimaryKeyExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.TableDefinition.AlterTableExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.TableDefinition.AlterTableAction
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.TableDefinition.UsingClause
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.TableDefinition.AlterNotNull
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.TableDefinition.DropTableExpr


-- | Provides a type representing sql operators with exactly two arguments,
--   as well as values of that type for many common operators.
module Orville.PostgreSQL.Expr.BinaryOperator

-- | Type to represent any SQL operator of two arguments. E.G.
--   
--   <pre>
--   AND
--   </pre>
--   
--   <a>BinaryOperator</a> provides' a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data BinaryOperator

-- | Construct a binary operator, note that this does not include any check
--   to determine if the operator is valid either by being a native SQL
--   operator, or a custom defined operator in the database.
binaryOperator :: String -> BinaryOperator

-- | Apply a binary operator to two <a>ValueExpression</a>s resulting in
--   some <a>SqlExpression</a>. Note that this does *NOT* extend
--   typechecking to the <a>ValueExpression</a>s being used with the
--   <a>BinaryOperator</a>. It is left to the caller to ensure that the
--   operator makes sense with the arguments being passed.
binaryOpExpression :: SqlExpression sql => BinaryOperator -> ValueExpression -> ValueExpression -> sql

-- | The SQL equal binary operator.
equalsOp :: BinaryOperator

-- | The SQL not equal binary operator.
notEqualsOp :: BinaryOperator

-- | The SQL strictly greater than binary operator.
greaterThanOp :: BinaryOperator

-- | The SQL strictly less than binary operator.
lessThanOp :: BinaryOperator

-- | The SQL greater than or equal binary operator.
greaterThanOrEqualsOp :: BinaryOperator

-- | The SQL less than or equal binary operator.
lessThanOrEqualsOp :: BinaryOperator

-- | The SQL LIKE binary operator.
likeOp :: BinaryOperator

-- | The SQL ILIKE binary operator.
iLikeOp :: BinaryOperator

-- | The SQL logical or binary operator.
orOp :: BinaryOperator

-- | The SQL logical and binary operator.
andOp :: BinaryOperator

-- | The SQL + binary operator.
plusOp :: BinaryOperator

-- | The SQL - binary operator.
minusOp :: BinaryOperator

-- | The SQL * binary operator.
multiplicationOp :: BinaryOperator

-- | The SQL / binary operator.
divisionOp :: BinaryOperator

-- | The SQL % binary operator.
moduloOp :: BinaryOperator

-- | The SQL ^ binary operator.
exponentiationOp :: BinaryOperator

-- | The SQL bitwise and (a.k.a &amp;) binary operator.
bitwiseAndOp :: BinaryOperator

-- | The SQL bitwise or (a.k.a |) binary operator.
bitwiseOrOp :: BinaryOperator

-- | The SQL bitwise exclusive or (a.k.a #) binary operator.
bitwiseXorOp :: BinaryOperator

-- | The SQL bitwise left shift (a.k.a &lt;&lt;) binary operator.
bitwiseShiftLeftOp :: BinaryOperator

-- | The SQL bitwise right shift (a.k.a &gt;&gt;) binary operator.
bitwiseShiftRightOp :: BinaryOperator
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.BinaryOperator.BinaryOperator


module Orville.PostgreSQL.Expr.WhereClause

-- | Type to represent a <tt>WHERE</tt> clause restriction an a
--   <tt>SELECT</tt>, <tt>UPDATE</tt> or <tt>DELETE</tt> statement. E.G.
--   
--   <pre>
--   WHERE (foo &gt; 10)
--   </pre>
--   
--   <a>WhereClause</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data WhereClause

-- | Constructs a <tt>WHERE</tt> clause from the given <a>BooleanExpr</a>.
--   E.G.
--   
--   <pre>
--   WHERE &lt;boolean expr&gt;
--   </pre>
whereClause :: BooleanExpr -> WhereClause

-- | Type to represent a SQL value expression that evaluates to a boolean
--   and thereforce can used with boolean logic functions. E.G.
--   
--   <pre>
--   foo &gt; 10
--   </pre>
--   
--   <a>BooleanExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data BooleanExpr

-- | Constructs a <a>BooleanExpr</a> whose value the SQL literal
--   <tt>TRUE</tt> or <tt>FALSE</tt> depending on the argument given.
literalBooleanExpr :: Bool -> BooleanExpr

-- | The SQL <tt>AND</tt> operator. The arguments will be surrounded with
--   parentheses to ensure that the associativity of expression in the
--   resulting SQL matches the associtivity implied by this Haskell
--   function.
andExpr :: BooleanExpr -> BooleanExpr -> BooleanExpr

-- | The SQL <tt>AND</tt> operator (alias for <a>andExpr</a>)
(.&&) :: BooleanExpr -> BooleanExpr -> BooleanExpr
infixr 8 .&&

-- | The SQL <tt>OR</tt> operator. The arguments will be surrounded with
--   parentheses to ensure that the associativity of expression in the
--   resulting SQL matches the associtivity implied by this Haskell
--   function.
orExpr :: BooleanExpr -> BooleanExpr -> BooleanExpr

-- | The SQL <tt>OR</tt> operator (alias for <a>orExpr</a>)
(.||) :: BooleanExpr -> BooleanExpr -> BooleanExpr
infixr 8 .||

-- | Surrounds the given <a>BooleanExpr</a> with parentheses.
parenthesized :: BooleanExpr -> BooleanExpr

-- | The SQL <tt>=</tt> operator.
equals :: ValueExpression -> ValueExpression -> BooleanExpr

-- | The SQL <tt>&lt;&gt;</tt> operator.
notEquals :: ValueExpression -> ValueExpression -> BooleanExpr

-- | The SQL <tt>&gt;</tt> operator.
greaterThan :: ValueExpression -> ValueExpression -> BooleanExpr

-- | The SQL <tt>&lt;</tt> operator.
lessThan :: ValueExpression -> ValueExpression -> BooleanExpr

-- | The SQL <tt>&gt;=</tt> operator.
greaterThanOrEqualTo :: ValueExpression -> ValueExpression -> BooleanExpr

-- | The SQL <tt>&lt;=</tt> operator.
lessThanOrEqualTo :: ValueExpression -> ValueExpression -> BooleanExpr

-- | The SQL <tt>LIKE</tt> operator.
like :: ValueExpression -> ValueExpression -> BooleanExpr

-- | The SQL <tt>ILIKE</tt> operator.
likeInsensitive :: ValueExpression -> ValueExpression -> BooleanExpr

-- | The SQL <tt>IS NULL</tt> condition.
isNull :: ValueExpression -> BooleanExpr

-- | The SQL <tt>IS NOT NULL</tt> condition.
isNotNull :: ValueExpression -> BooleanExpr

-- | The SQL <tt>IN</tt> operator. The result will be <tt>TRUE</tt> if the
--   given value appears in the list of values given.
valueIn :: ValueExpression -> NonEmpty ValueExpression -> BooleanExpr

-- | The SQL <tt>IN</tt> operator. The result will be <tt>TRUE</tt> if the
--   given value does not appear in the list of values given.
valueNotIn :: ValueExpression -> NonEmpty ValueExpression -> BooleanExpr

-- | The SQL <tt>IN</tt> operator, like <a>valueIn</a>, but for when you
--   want to construct a tuple in SQL and check if it is in a list of
--   tuples. It is up to the caller to ensure that all the tuples given
--   have the same arity.
tupleIn :: NonEmpty ValueExpression -> NonEmpty (NonEmpty ValueExpression) -> BooleanExpr

-- | The SQL <tt>NOT IN</tt> operator, like <a>valueNotIn</a>, but for when
--   you want to construct a tuple in SQL and check if it is not in a list
--   of tuples. It is up to the caller to ensure that all the tuples given
--   have the same arity.
tupleNotIn :: NonEmpty ValueExpression -> NonEmpty (NonEmpty ValueExpression) -> BooleanExpr

-- | Type to represent the right hand side of an <tt>IN</tt> or <tt>NOT
--   IN</tt> expression. E.G.
--   
--   <pre>
--   (10,12,13)
--   </pre>
--   
--   <a>InValuePredicate</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data InValuePredicate

-- | Lowel lever access to the the SQL <tt>IN</tt> operator. This takes any
--   <a>ValueExpression</a> and <a>InValuePredicate</a>. It is up to the
--   caller to ensure the expressions given makes sense together.
inPredicate :: ValueExpression -> InValuePredicate -> BooleanExpr

-- | Lowel lever access to the the SQL <tt>NOT IN</tt> operator. This takes
--   any <a>ValueExpression</a> and <a>InValuePredicate</a>. It is up to
--   the caller to ensure the expressions given makes sense together.
notInPredicate :: ValueExpression -> InValuePredicate -> BooleanExpr

-- | Constructs an <a>InValuePredicate</a> from the given list of
--   <a>ValueExpression</a>
inValueList :: NonEmpty ValueExpression -> InValuePredicate
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.WhereClause.WhereClause
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.WhereClause.BooleanExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.WhereClause.InValuePredicate


module Orville.PostgreSQL.Expr.Math

-- | Apply a SQL + to the <a>ValueExpression</a>s. It is left to the caller
--   to ensure that the operator makes sense with the arguments being
--   passed.
plus :: ValueExpression -> ValueExpression -> ValueExpression

-- | Apply a SQL - to the <a>ValueExpression</a>s. It is left to the caller
--   to ensure that the operator makes sense with the arguments being
--   passed.
minus :: ValueExpression -> ValueExpression -> ValueExpression

-- | Apply a SQL * to the <a>ValueExpression</a>s. It is left to the caller
--   to ensure that the operator makes sense with the arguments being
--   passed.
multiply :: ValueExpression -> ValueExpression -> ValueExpression

-- | Apply a SQL / to the <a>ValueExpression</a>s. It is left to the caller
--   to ensure that the operator makes sense with the arguments being
--   passed.
divide :: ValueExpression -> ValueExpression -> ValueExpression

-- | Apply a SQL % to the <a>ValueExpression</a>s. It is left to the caller
--   to ensure that the operator makes sense with the arguments being
--   passed.
modulo :: ValueExpression -> ValueExpression -> ValueExpression

-- | Apply a SQL ^ to the <a>ValueExpression</a>s. It is left to the caller
--   to ensure that the operator makes sense with the arguments being
--   passed.
exponentiate :: ValueExpression -> ValueExpression -> ValueExpression

-- | Apply a SQL &amp; to the <a>ValueExpression</a>s. It is left to the
--   caller to ensure that the operator makes sense with the arguments
--   being passed.
bitwiseAnd :: ValueExpression -> ValueExpression -> ValueExpression

-- | Apply a SQL | to the <a>ValueExpression</a>s. It is left to the caller
--   to ensure that the operator makes sense with the arguments being
--   passed.
bitwiseOr :: ValueExpression -> ValueExpression -> ValueExpression

-- | Apply a SQL # to the <a>ValueExpression</a>s. It is left to the caller
--   to ensure that the operator makes sense with the arguments being
--   passed.
bitwiseXor :: ValueExpression -> ValueExpression -> ValueExpression

-- | Apply a SQL &lt;&lt; to the <a>ValueExpression</a>s. It is left to the
--   caller to ensure that the operator makes sense with the arguments
--   being passed.
bitwiseShiftLeft :: ValueExpression -> ValueExpression -> ValueExpression

-- | Apply a SQL &gt;&gt; to the <a>ValueExpression</a>s. It is left to the
--   caller to ensure that the operator makes sense with the arguments
--   being passed.
bitwiseShiftRight :: ValueExpression -> ValueExpression -> ValueExpression


module Orville.PostgreSQL.Expr.SequenceDefinition

-- | Type to represent a <tt>CREATE SEQUENCE</tt> statement. E.G.
--   
--   <pre>
--   CREATE SEQUENCE foo INCREMENT 2
--   </pre>
--   
--   <a>CreateSequenceExpr</a> provides a <a>SqlExpression</a> instance.
--   See <a>unsafeSqlExpression</a> for how to construct a value with your
--   own custom SQL.
data CreateSequenceExpr

-- | Constructs a <a>CreateSequenceExpr</a> with the given sequence
--   options.
createSequenceExpr :: Qualified SequenceName -> Maybe IncrementByExpr -> Maybe MinValueExpr -> Maybe MaxValueExpr -> Maybe StartWithExpr -> Maybe CacheExpr -> Maybe CycleExpr -> CreateSequenceExpr

-- | Type to represent a <tt>CREATE SEQUENCE</tt> statement. E.G.
--   
--   <pre>
--   ALTER SEQUENCE foo START WITH 0
--   </pre>
--   
--   <a>AlterSequenceExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data AlterSequenceExpr

-- | Constructs an <a>AlterSequenceExpr</a> with the given sequence
--   options.
alterSequenceExpr :: Qualified SequenceName -> Maybe IncrementByExpr -> Maybe MinValueExpr -> Maybe MaxValueExpr -> Maybe StartWithExpr -> Maybe CacheExpr -> Maybe CycleExpr -> AlterSequenceExpr

-- | Type to represent a <tt>INCREMENT BY</tt> expression for sequences.
--   E.G.
--   
--   <pre>
--   INCREMENT BY 0
--   </pre>
--   
--   <a>IncrementByExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data IncrementByExpr

-- | Constructs an <a>IncrementByExpr</a> that will make the sequence
--   increment by the given value
incrementBy :: Int64 -> IncrementByExpr

-- | Type to represent a <tt>MINVALUE</tt> expression for sequences. E.G.
--   
--   <pre>
--   MINVALUE 0
--   </pre>
--   
--   <a>MinValueExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data MinValueExpr

-- | Constructs an <a>MinValueExpr</a> which gives the sequence the
--   specified minimum value
minValue :: Int64 -> MinValueExpr

-- | Constructs an <a>MinValueExpr</a> which gives the sequence no minimum
--   value (i.e. <tt>NO MINVALUE</tt>)
noMinValue :: MinValueExpr

-- | Type to represent a <tt>MAXVALUE</tt> expression for sequences. E.G.
--   
--   <pre>
--   MAXVALUE 1000000
--   </pre>
--   
--   <a>MaxValueExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data MaxValueExpr

-- | Constructs an <tt>maxValueExpr</tt> which gives the sequence the
--   specified maximum value
maxValue :: Int64 -> MaxValueExpr

-- | Constructs an <a>MinValueExpr</a> which gives the sequence no maximum
--   value (i.e. <tt>NO MAXVALUE</tt>)
noMaxValue :: MaxValueExpr

-- | Type to represent a <tt>START WITH</tt> expression for sequences. E.G.
--   
--   <pre>
--   START WITH 1
--   </pre>
--   
--   <a>StartWithExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data StartWithExpr

-- | Constructs a <a>StartWithExpr</a> which gives the sequence the
--   specified start value
startWith :: Int64 -> StartWithExpr

-- | Type to represent a <tt>CACHE </tt> expression for sequences. E.G.
--   
--   <pre>
--   CACHE 16
--   </pre>
--   
--   <a>CacheExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data CacheExpr

-- | Constructs a <a>CacheExpr</a> that will make the sequence pre-allocate
--   the specified number of sequence values.
cache :: Int64 -> CacheExpr

-- | Type to represent a <tt>CYCLE</tt> expression for sequences. E.G.
--   
--   <pre>
--   CYCLE
--   </pre>
--   
--   or
--   
--   <pre>
--   NO CYCLE
--   </pre>
--   
--   <a>CycleExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data CycleExpr

-- | Constructs a <a>CycleExpr</a> that indicate that the sequence should
--   cycle.
cycle :: CycleExpr

-- | Constructs a <a>CycleExpr</a> that indicate that the sequence should
--   not cycle.
noCycle :: CycleExpr

-- | Constructs a <a>CycleExpr</a> will cause the sequence to cycle if the
--   flag passed is <tt>True</tt>.
cycleIfTrue :: Bool -> CycleExpr

-- | Type to represent a <tt>DROP SEQUENCE</tt> statement. E.G.
--   
--   <pre>
--   DROP SEQUENCE foo
--   </pre>
--   
--   <a>DropSequenceExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data DropSequenceExpr

-- | Constructs a <a>DropSequenceExpr</a> that will drop sequence with the
--   given name. You maybe specific an <a>IfExists</a> argument if you want
--   to include an <tt>IF EXISTS</tt> condition in the statement.
dropSequenceExpr :: Maybe IfExists -> Qualified SequenceName -> DropSequenceExpr

-- | Constructs a <a>ValueExpression</a> that will use the <tt>nextval</tt>
--   PostgreSQL function to get the next value from the given sequence. If
--   you're trying to construct your own <tt>SELECT</tt> to get the value
--   of the sequnce, you can use the constructed <a>ValueExpression</a>
--   with <a>deriveColumnAs</a> to build the item to select.
nextVal :: Qualified SequenceName -> ValueExpression

-- | The <tt>nextval</tt> PostgreSQL function.
nextValFunction :: FunctionName

-- | Constructs a <a>ValueExpression</a> that will use the <tt>currval</tt>
--   PostgreSQL function to get the current value from the given sequence.
--   If you're trying to construct your own <tt>SELECT</tt> to get the
--   value of the sequnce, you can use the constructed
--   <a>ValueExpression</a> with <a>deriveColumnAs</a> to build the item to
--   select.
currVal :: Qualified SequenceName -> ValueExpression

-- | The <tt>currval</tt> PostgreSQL function.
currValFunction :: FunctionName

-- | Constructs a <a>ValueExpression</a> that will use the <tt>setval</tt>
--   PostgreSQL function to set the value from the given sequence. If
--   you're trying to construct your own <tt>SELECT</tt> to set the value
--   of the sequnce, you can use the constructed <a>ValueExpression</a>
--   with <a>deriveColumnAs</a> to build the item to select.
setVal :: Qualified SequenceName -> Int64 -> ValueExpression

-- | The <tt>setval</tt> PostgreSQL function.
setValFunction :: FunctionName
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.SequenceDefinition.CreateSequenceExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.SequenceDefinition.AlterSequenceExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.SequenceDefinition.IncrementByExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.SequenceDefinition.MinValueExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.SequenceDefinition.MaxValueExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.SequenceDefinition.StartWithExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.SequenceDefinition.CacheExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.SequenceDefinition.CycleExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.SequenceDefinition.DropSequenceExpr


module Orville.PostgreSQL.Expr.OffsetExpr

-- | Type to represent a SQL offset expression. E.G.
--   
--   <pre>
--   OFFSET 10
--   </pre>
--   
--   <a>OffsetExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data OffsetExpr

-- | Create an <a>OffsetExpr</a> for the given <a>Int</a>. This ensures
--   that the input value is used as parameters in the generated SQL.
offsetExpr :: Int -> OffsetExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.OffsetExpr.OffsetExpr


module Orville.PostgreSQL.Expr.LimitExpr

-- | Type to represent a SQL limit expression. E.G.
--   
--   <pre>
--   LIMIT 10
--   </pre>
--   
--   <a>LimitExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data LimitExpr

-- | Create a <a>LimitExpr</a> for the given <a>Int</a>. This ensures that
--   the input value is used as parameters in the generated SQL.
limitExpr :: Int -> LimitExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.LimitExpr.LimitExpr


module Orville.PostgreSQL.Expr.Query

-- | Type to represent a SQL query, E.G.
--   
--   <pre>
--   SELECT id FROM some_table
--   </pre>
--   
--   <a>QueryExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data QueryExpr

-- | Builds a <a>QueryExpr</a> from the given <a>SelectClause</a>,
--   <a>SelectList</a> and <a>TableExpr</a>. The resulting <a>QueryExpr</a>
--   is suitable execution via the SQL execution functions in
--   <a>Orville.PostgreSQL.Execution</a> and
--   <a>Orville.PostgreSQL.Raw.RawSql</a>.
queryExpr :: SelectClause -> SelectList -> Maybe TableExpr -> QueryExpr

-- | Type to represent the list of items to be selected in a
--   <tt>SELECT</tt> clause. E.G. the
--   
--   <pre>
--   foo, bar, baz
--   </pre>
--   
--   in
--   
--   <pre>
--   SELECT foo, bar, baz FROM some_table
--   </pre>
--   
--   <a>SelectList</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data SelectList

-- | Constructs a <a>SelectList</a> that will select the specified column
--   names. This is a special case of <a>selectDerivedColumns</a> where all
--   the items to be selected are simple column references.
selectColumns :: [ColumnName] -> SelectList

-- | Type to represent an individual item in a list of selected items. E.G.
--   
--   <pre>
--   now() as current_time
--   </pre>
--   
--   <a>DerivedColumn</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data DerivedColumn

-- | Constructs a <a>DerivedColumn</a> that will select the given value. No
--   name will be given to the value in the result set. See
--   <a>deriveColumnAs</a> to give the value a name in the result set.
deriveColumn :: ValueExpression -> DerivedColumn

-- | Constructs a <a>DerivedColumn</a> that will select the given value and
--   give it the specified column name in the result set.
deriveColumnAs :: ValueExpression -> ColumnName -> DerivedColumn

-- | Constructs a <a>SelectList</a> that will select the specified items,
--   which may be column references or other expressions as allowed by
--   <a>DerivedColumn</a>. See also <a>selectColumns</a> the simpler case
--   of selecting a list of column names.
selectDerivedColumns :: [DerivedColumn] -> SelectList

-- | Constructs a <a>SelectList</a> that will select all colums (i.e. the
--   <tt>*</tt> in <tt>SELECT *</tt>").
selectStar :: SelectList

-- | Type to represent a table expression (including its associated
--   options) in a <tt>SELECT</tt>. This is the part that would appear
--   *after* the word <tt>FROM</tt>. E.G.
--   
--   <pre>
--   foo
--   WHERE id &gt; 100
--   ORDER BY id
--   LIMIT 1
--   OFFSET 2
--   </pre>
--   
--   <a>TableExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data TableExpr

-- | Constructs a <a>TableExpr</a> with the given options.
tableExpr :: TableReferenceList -> Maybe WhereClause -> Maybe GroupByClause -> Maybe OrderByClause -> Maybe LimitExpr -> Maybe OffsetExpr -> TableExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Query.QueryExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Query.SelectList
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Query.DerivedColumn
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Query.TableExpr


module Orville.PostgreSQL.Expr.ReturningExpr

-- | Type to represent a <tt>RETURNING</tt> clause in a SQL <tt>SELECT</tt>
--   statement. E.G.
--   
--   <pre>
--   RETURNING (id)
--   </pre>
--   
--   <a>ReturningExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data ReturningExpr

-- | Constructs a <a>ReturningExpr</a> that returns the items given in the
--   <a>SelectList</a>. Essentialy this retults <tt>RETURNING
--   <a>items</a></tt>
returningExpr :: SelectList -> ReturningExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.ReturningExpr.ReturningExpr


module Orville.PostgreSQL.Expr.Update

-- | Type to represent the transaction a SQL <tt>UPDATE</tt> statement.
--   E.G.
--   
--   <pre>
--   UPDATE foo
--   SET id = 1
--   WHERE id &lt;&gt; 1
--   </pre>
--   
--   <a>UpdateExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data UpdateExpr

-- | Constructs an <a>UpdateExpr</a> with the given options.
updateExpr :: Qualified TableName -> SetClauseList -> Maybe WhereClause -> Maybe ReturningExpr -> UpdateExpr

-- | Type to represent the list of updates to be made in a <tt>UPDATE</tt>
--   statament. E.G.
--   
--   <pre>
--   foo = 1,
--   bar = 2
--   </pre>
--   
--   <a>SetClauseList</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data SetClauseList

-- | Constructs a <a>SetClauseList</a> with the specified set clauses
setClauseList :: NonEmpty SetClause -> SetClauseList

-- | Type to represent a single updates to be made in a <tt>UPDATE</tt>
--   statament. E.G.
--   
--   <pre>
--   foo = 1
--   </pre>
--   
--   <a>SetClause</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data SetClause

-- | Constructs a <a>SetClause</a> that will set the specified column to
--   the specified value.
setColumn :: ColumnName -> SqlValue -> SetClause
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Update.UpdateExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Update.SetClauseList
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Update.SetClause


-- | Provides a type representing SQL DELETE and construction of that type.
module Orville.PostgreSQL.Expr.Delete

-- | Type to represent a SQL delete statement. E.G.
--   
--   <pre>
--   DELETE FROM foo WHERE id &lt; 10
--   </pre>
--   
--   <a>DeleteExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data DeleteExpr

-- | Construct a SQL DELETE from a table, optionally limiting with a
--   <a>WhereClause</a> and optionally returning a <a>ReturningExpr</a>.
deleteExpr :: Qualified TableName -> Maybe WhereClause -> Maybe ReturningExpr -> DeleteExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Delete.DeleteExpr


module Orville.PostgreSQL.Expr.Cursor

-- | <a>DeclareExpr</a> corresponds to the SQL DECLARE statement, for
--   declaring and opening cursors. E.G.
--   
--   <pre>
--   DECLARE FOO CURSOR FOR SELECT * FROM BAR
--   </pre>
--   
--   See PostgreSQL <a>cursor declare documentation</a> for more
--   information.
--   
--   <a>DeclareExpr</a> provides' a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data DeclareExpr

-- | A smart constructor for setting up a <a>DeclareExpr</a>. This, along
--   with other functions provided allow to more safely declare a cursor.
declare :: CursorName -> Maybe ScrollExpr -> Maybe HoldExpr -> QueryExpr -> DeclareExpr

-- | <a>ScrollExpr</a> is used to determine if a cursor should be able to
--   fetch nonsequentially. E.G.
--   
--   <pre>
--   NO SCROLL
--   </pre>
--   
--   Note that the default in at least PostgreSQL versions 11-15 is to
--   allow nonsequential fetches under some, but not all, circumstances.
--   
--   See PostgreSQL <a>cursor declare documentation</a> for more
--   information.
--   
--   <a>ScrollExpr</a> provides' a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data ScrollExpr

-- | Allow a cursor to be used to fetch rows nonsequentially.
scroll :: ScrollExpr

-- | Only allow a cursor to be used to fetch rows sequentially.
noScroll :: ScrollExpr

-- | <a>HoldExpr</a> is used to determine if a cursor should be available
--   for use after the transaction that created it has been comitted. E.G.
--   
--   <pre>
--   WITH HOLD
--   </pre>
--   
--   See PostgreSQL <a>cursor documentation</a> for more information.
--   
--   <a>HoldExpr</a> provides' a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data HoldExpr

-- | Allow a cursor to be used after the transaction creating it is
--   committed.
withHold :: HoldExpr

-- | Do not allow a cursor to be used after the transaction creating it is
--   committed.
withoutHold :: HoldExpr

-- | <a>CloseExpr</a> corresponds to the SQL CLOSE statement. E.G.
--   
--   <pre>
--   CLOSE ALL
--   </pre>
--   
--   See PostgreSQL <a>close documentation</a> for more information.
--   
--   <a>HoldExpr</a> provides' a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data CloseExpr

-- | A smart constructor for setting up a <a>CloseExpr</a> either closing
--   all cursors or the given named cursor.
close :: Either AllCursors CursorName -> CloseExpr

-- | <a>AllCursors</a> corresponds to the ALL keyword in a CLOSE statement.
--   E.G.
--   
--   <pre>
--   ALL
--   </pre>
--   
--   <a>AllCursors</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data AllCursors

-- | Specify closing all open cursors, for use with a <a>CloseExpr</a>
allCursors :: AllCursors

-- | <a>FetchExpr</a> corresponds to the SQL FETCH statement, for
--   retrieving rows from a previously created cursor. E.G.
--   
--   <pre>
--   FETCH NEXT FOO
--   </pre>
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
--   
--   <a>FetchExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data FetchExpr

-- | Construct a <a>FetchExpr</a>, for a given cursor and optionally a
--   direction to fetch.
fetch :: Maybe CursorDirection -> CursorName -> FetchExpr

-- | <a>MoveExpr</a> corresponds to the SQL MOVE statement, for positioning
--   a previously created cursor, <i>without</i> retrieving any rows. E.G.
--   
--   <pre>
--   MOVE NEXT FOO
--   </pre>
--   
--   <a>MoveExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data MoveExpr

-- | Construct a <a>MoveExpr</a>, for a given cursor and optionally a
--   direction to move.
move :: Maybe CursorDirection -> CursorName -> MoveExpr

-- | <a>CursorDirection</a> corresponds to the direction argument to the
--   SQL FETCH and MOVE statements. E.G.
--   
--   <pre>
--   BACKWARD
--   </pre>
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
--   
--   <a>CursorDirection</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data CursorDirection

-- | Specify a direction of the next single row. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
next :: CursorDirection

-- | Specify a direction of the prior single row. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
prior :: CursorDirection

-- | Specify a direction of the first single row. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
first :: CursorDirection

-- | Specify a direction of the last single row. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
last :: CursorDirection

-- | Specify a direction of the single row at an absolute position within
--   the cursor. Primarily for use with <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
absolute :: Int -> CursorDirection

-- | Specify a direction of the single row relative to the cursor's current
--   position. Primarily for use with <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
relative :: Int -> CursorDirection

-- | Specify a direction of the next n rows. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
rowCount :: Int -> CursorDirection

-- | Specify a direction of all the next rows. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
fetchAll :: CursorDirection

-- | Specify a direction of the next single row. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
forward :: CursorDirection

-- | Specify a direction of the next n rows. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
forwardCount :: Int -> CursorDirection

-- | Specify a direction of all the next rows. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
forwardAll :: CursorDirection

-- | Specify a direction of the prior single row. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
backward :: CursorDirection

-- | Specify a direction of the prior n rows. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
backwardCount :: Int -> CursorDirection

-- | Specify a direction of all the prior rows. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
backwardAll :: CursorDirection
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Cursor.DeclareExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Cursor.ScrollExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Cursor.HoldExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Cursor.CloseExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Cursor.AllCursors
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Cursor.FetchExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Cursor.MoveExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Cursor.CursorDirection


module Orville.PostgreSQL.Expr.Insert

-- | Type to represent a SQL <a>INSERT</a> statement. E.G.
--   
--   <pre>
--   INSERT INTO foo (id) VALUES (1),(3),(3)
--   </pre>
--   
--   <a>InsertExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data InsertExpr

-- | Create an <a>InsertExpr</a> for the given <a>TableName</a>, limited to
--   the specific columns if given. Callers of this likely want to use a
--   function to create the <a>InsertSource</a> to ensure the input values
--   are correctly used as parameters. This function does not include that
--   protection itself.
insertExpr :: Qualified TableName -> Maybe InsertColumnList -> InsertSource -> Maybe ReturningExpr -> InsertExpr

-- | Type to represent the SQL columns list for an insert statement. E.G.
--   
--   <pre>
--   (foo,bar,baz)
--   </pre>
--   
--   <a>InsertColumnList</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data InsertColumnList

-- | Create an <a>InsertColumnList</a> for the given <a>ColumnName</a>s,
--   making sure the columns are wrapped in parens and commas are used to
--   separate.
insertColumnList :: [ColumnName] -> InsertColumnList

-- | Type to represent the SQL for the source of data for an insert
--   statement E.G.
--   
--   <pre>
--   VALUES ('Bob',32),('Cindy',33)
--   </pre>
--   
--   <a>InsertSource</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data InsertSource

-- | Create an <a>InsertSource</a> for the given <tt>SqlValues</tt>. This
--   ensures that all input values are used as parameters and comma
--   separated in the generated SQL.
insertSqlValues :: [[SqlValue]] -> InsertSource

-- | Type to represent a SQL row literal. For example, a single row to
--   insert in a <tt>VALUES</tt> clause. E.G.
--   
--   <pre>
--   ('Cindy',33)
--   </pre>
--   
--   <a>RowValues</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data RowValues

-- | Create a <a>RowValues</a> for the given <tt>SqlValues</tt>. This
--   ensures that all input values are used as parameters and comma
--   separated in the generated SQL.
rowValues :: [SqlValue] -> RowValues
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Insert.InsertExpr
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Insert.InsertColumnList
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Insert.InsertSource
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.Expr.Insert.RowValues


-- | This module provides access to functions and types intended to help
--   build SQL statements directly in a relatively safe manner while also
--   always providing a way to write exactly the SQL you need. The SQL
--   construction functions all require specific types as their arguments
--   to communicate what particular fragment of SQL they expect to take as
--   an argument. These types generally provide a <a>SqlExpression</a>
--   instance, however, meaning that if Orville does not support
--   constructing the exact SQL fragment you want to pass for that argument
--   directly you can always use <a>unsafeSqlExpression</a> to construct a
--   value of the required type. This means you can use as many of the
--   "safe" construction functions provided here as possible while
--   substituting in hand-written SQL at only the exact points you need.
--   
--   For instance, the following code snippet shows how you could construct
--   a <tt>BEGIN TRANSACTION ISOLATION LEVEL SOME NEW ISOLATION LEVEL</tt>
--   statement if PostgreSQL added <tt>SOME NEW ISOLATION LEVEL</tt> and
--   Orville did not yet support it.
--   
--   <pre>
--   import qualified Orville.PostgreSQL.Expr as Expr
--   import qualified Orville.PostgreSQL.Raw.RawSql as RawSql
--   
--   customerBeginTransaction :: Expr.BeginTransactionExpr
--   customerBeginTransaction =
--     Expr.beginTransaction
--       (Just (Expr.isolationLevel (RawSql.unsafeSqlExpression "SOME NEW ISOLATION LEVEL")))
--   </pre>
module Orville.PostgreSQL.Expr


-- | This module provides functions and types for describing a
--   single-column data type that exists in PostgreSQL so that Orville can
--   determine how to serialize Haskell values to and from the SQL type. If
--   you need to use a SQL type that Orville does not provide support for
--   here, you can construct your own <a>SqlType</a> value and use
--   <a>fieldOfType</a> to build the required <a>FieldDefinition</a>.
module Orville.PostgreSQL.Marshall.SqlType

-- | SqlType defines the mapping of a Haskell type (<tt>a</tt>) to a SQL
--   column type in the database. This includes both how to convert the
--   type to and from the raw values read from the database as well as the
--   schema information required to create and migrate columns using the
--   type.
data SqlType a
SqlType :: DataType -> Maybe DataType -> Oid -> Maybe Int32 -> (a -> SqlValue) -> (SqlValue -> Either String a) -> Bool -> SqlType a

-- | The sql data type expression to use when creating/migrating columns of
--   this type
[sqlTypeExpr] :: SqlType a -> DataType

-- | The sql data type experession to use when creating/migrating columns
--   with foreign keys to this type. This is used foreignRefType to build a
--   new SqlType when making foreign key fields
[sqlTypeReferenceExpr] :: SqlType a -> Maybe DataType

-- | The Oid for the type in postgresql. This will be used during
--   migrations to determine whether the column type needs to be altered.
[sqlTypeOid] :: SqlType a -> Oid

-- | The maximum length for lengths that take a type parameter (such as
--   <tt>char</tt> and <tt>varchar</tt>). This will be used during
--   migration to determine whether the column type needs to be altered.
[sqlTypeMaximumLength] :: SqlType a -> Maybe Int32

-- | A function for converting Haskell values of this type into values to
--   be stored in the database.
[sqlTypeToSql] :: SqlType a -> a -> SqlValue

-- | A function for converting values of this are stored in the database
--   into Haskell values. This function should return <a>Nothing</a> to
--   indicate an error if the conversion is impossible. Otherwise it should
--   return <a>Just</a> the corresponding <tt>a</tt> value.
[sqlTypeFromSql] :: SqlType a -> SqlValue -> Either String a

-- | The SERIAL and BIGSERIAL PostgreSQL types are really pesudo types that
--   create an implicit default value. This flag tells Orville's auto
--   migration logic to ignore the default value rather than drop it as it
--   normally would.
[sqlTypeDontDropImplicitDefaultDuringMigrate] :: SqlType a -> Bool

-- | <a>integer</a> defines a 32-bit integer type. This corresponds to the
--   <a>INTEGER</a> type in SQL.
integer :: SqlType Int32

-- | <a>serial</a> defines a 32-bit auto-incrementing column type. This
--   corresponds to the <a>SERIAL</a> type in PostgreSQL.
serial :: SqlType Int32

-- | <a>bigInteger</a> defines a 64-bit integer type. This corresponds to
--   the <a>BIGINT</a> type in SQL.
bigInteger :: SqlType Int64

-- | <a>bigSerial</a> defines a 64-bit auto-incrementing column type. This
--   corresponds to the <a>BIGSERIAL</a> type in PostgresSQL.
bigSerial :: SqlType Int64

-- | <a>smallInteger</a> defines a 16-bit integer type. This corresponds to
--   the <a>SMALLINT</a> type in SQL.
smallInteger :: SqlType Int16

-- | <a>double</a> defines a floating point numeric type. This corresponds
--   to the "DOUBLE PRECISION" type in SQL.
double :: SqlType Double

-- | <a>boolean</a> defines a True/False boolean type. This corresponds to
--   the <a>BOOLEAN</a> type in SQL.
boolean :: SqlType Bool

-- | <a>unboundedText</a> defines a unbounded length text field type. This
--   corresponds to a <a>TEXT</a> type in PostgreSQL.
unboundedText :: SqlType Text

-- | <a>fixedText</a> defines a fixed length text field type. This
--   corresponds to a "CHAR(len)" type in PostgreSQL.
fixedText :: Int32 -> SqlType Text

-- | <a>boundedText</a> defines a variable length text field type. This
--   corresponds to a "VARCHAR(len)" type in PostgreSQL.
boundedText :: Int32 -> SqlType Text

-- | <a>textSearchVector</a> defines a type for indexed text searching. It
--   corresponds to the <a>TSVECTOR</a> type in PostgreSQL.
textSearchVector :: SqlType Text

-- | <a>uuid</a> defines a UUID type. It corresponds to the <a>UUID</a>
--   type in PostgreSQL.
uuid :: SqlType UUID

-- | <a>date</a> defines a type representing a calendar date (without time
--   zone). It corresponds to the <a>DATE</a> type in SQL.
date :: SqlType Day

-- | <a>timestamp</a> defines a type representing a particular point in
--   time without time zone information, but can be constructed with a time
--   zone offset. It corresponds to the "TIMESTAMP with time zone" type in
--   SQL.
--   
--   Note: This is NOT a typo. The "TIMESTAMP with time zone" type in SQL
--   does not include any actual time zone information. For an excellent
--   explanation of the complexities involving this type, please see Chris
--   Clark's blog post about it:
--   <a>http://blog.untrod.com/2016/08/actually-understanding-timezones-in-postgresql.html</a>
timestamp :: SqlType UTCTime

-- | <a>timestampWithoutZone</a> defines a type representing a particular
--   point in time (without time zone). It corresponds to the "TIMESTAMP
--   without time zone" type in SQL.
--   
--   
--   <a>http://blog.untrod.com/2016/08/actually-understanding-timezones-in-postgresql.html</a>
timestampWithoutZone :: SqlType LocalTime

-- | <a>jsonb</a> represents any type that can be converted To and From
--   JSON. This corresponds to the <a>JSONB</a> type in PostgreSQL.
jsonb :: SqlType Text

-- | <a>oid</a> corresponds to the type used in PostgreSQL for identifying
--   system objects
oid :: SqlType Oid

-- | <a>foreignRefType</a> creates a <a>SqlType</a> suitable for columns
--   will be foreign keys referencing a column of the given <a>SqlType</a>.
--   For most types the underlying sql type with be identical, but for
--   special types (such as autoincrementing primary keys), the type
--   construted by <a>foreignRefType</a> with have regular underlying sql
--   type. Each <a>SqlType</a> definition must specify any special handling
--   required when creating foreign reference types by setting the
--   <a>sqlTypeReferenceExpr</a> field to an appropriate value.
foreignRefType :: SqlType a -> SqlType a

-- | <a>convertSqlType</a> changes the Haskell type used by a
--   <a>SqlType</a> in the same manner as <a>tryConvertSqlType</a> in cases
--   where an <tt>a</tt> can always be converted to a <tt>b</tt>.
convertSqlType :: (b -> a) -> (a -> b) -> SqlType a -> SqlType b

-- | <a>tryConvertSqlType</a> changes the Haskell type used by a
--   <a>SqlType</a> which changing the column type that will be used in the
--   database schema. The functions given will be used to convert the now
--   Haskell type to and from the original type when reading and writing
--   values from the database. When reading an <tt>a</tt> value from the
--   database, the conversion function should produce 'Left with an error
--   message if the value cannot be successfully converted to a <tt>b</tt>
tryConvertSqlType :: (b -> a) -> (a -> Either String b) -> SqlType a -> SqlType b


module Orville.PostgreSQL.Marshall.DefaultValue

-- | A <a>DefaultValue</a> is a SQL expression that can be attached to a
--   field definition to give a default value for a column at the database
--   level. The default value will be used if an insert is done and the
--   column is not provided.
--   
--   This is useful if you want to add a new column to a table that is
--   already in production without breaking a previous version of your
--   application that is running (e.g. during a zero-down-time deployment)
--   and without needing to make the new column nullable. Default values
--   can also be used to create database-assigned values such as using
--   'now()' to set a <tt>created_at</tt> column on a row automatically in
--   the database.
data DefaultValue a

-- | Builds a default value from an <a>Int32</a> for use with integer
--   fields.
--   
--   This is a specialization of <a>integerDefault</a>.
integerDefault :: Int32 -> DefaultValue Int32

-- | Builds a default value from an <a>Int16</a> for use with small integer
--   fields.
--   
--   This is a specialization of <a>integerDefault</a>.
smallIntegerDefault :: Int16 -> DefaultValue Int16

-- | Builds a default value from an <a>Int16</a> for use with big integer
--   fields.
--   
--   This is a specialization of <a>integerDefault</a>.
bigIntegerDefault :: Int64 -> DefaultValue Int64

-- | Builds a default value for any <a>Integral</a> type <tt>n</tt> by
--   converting it an <a>Integer</a>.
integralDefault :: Integral n => n -> DefaultValue n

-- | Builds a default value from a <a>Double</a> field with double fields.
doubleDefault :: Double -> DefaultValue Double

-- | Builds a default value from a <a>Bool</a>, for use with boolean
--   fields.
booleanDefault :: Bool -> DefaultValue Bool

-- | Builds a default value from a <a>Text</a>, for use with unbounded,
--   bounded and fixed-length text fields.
textDefault :: Text -> DefaultValue Text

-- | Builds a default value from a <a>Day</a> for use with date fields.
dateDefault :: Day -> DefaultValue Day

-- | Builds a default value that will default to the current date (i.e. the
--   date at which the database populates the default value on a given
--   row).
--   
--   For use with date fields.
currentDateDefault :: DefaultValue Day

-- | Builds a default value from a <a>UTCTime</a> for use with utc
--   timestamp fields.
utcTimestampDefault :: UTCTime -> DefaultValue UTCTime

-- | Builds a default value that will default to the current utc time (i.e.
--   the time at which the database populates the default value on a given
--   row).
--   
--   For use with utc timestamp fields.
currentUTCTimestampDefault :: DefaultValue UTCTime

-- | Builds a default value from a <a>LocalTime</a> for use with local
--   timestamp fields.
localTimestampDefault :: LocalTime -> DefaultValue LocalTime

-- | Builds a default value that will default to the current local time
--   (i.e. the time at which the database populates the default value on a
--   given row).
--   
--   Note: "local" time here will be determined by the database itself,
--   subject to whatever timezone offset has been configured in its
--   settings.
--   
--   For use with local timestamp fields.
currentLocalTimestampDefault :: DefaultValue LocalTime

-- | Coerce's a <a>DefaultValue</a> so that it can be used with field
--   definitions of a different Haskell type. The coercion will always
--   succeed, and is safe as far as Haskell itself it concerned. As long as
--   the <a>DefaultValue</a> is used with a column whose database type is
--   the same as the one the <a>DefaultValue</a> was originally intended
--   for, everything will work as expected.
coerceDefaultValue :: DefaultValue a -> DefaultValue b

-- | Returns database value expression for the default value
defaultValueExpression :: DefaultValue a -> ValueExpression

-- | Constructs a default value from a <tt>ValueExpression</tt>. You can
--   use this to construct default values for any SQL expression that
--   Orville does not support directly.
--   
--   Note: If you are using auto migrations, the <a>ValueExpression</a>
--   that you pass here must match what is returned by the PostgreSQL
--   <tt>pg_get_expr</tt> function. <tt>pg_get_expr</tt> decompiles the
--   compiled version of the default experssion back to source text,
--   sometimes in non-obvious ways. Orville's auto migration compares
--   expression given in the field definition with the decompiled
--   expression from the database to determine whether the default value
--   needs to be updated in the schema or not. If the expression given by a
--   <a>DefaultValue</a> is logically equivalent but does not match the
--   decompiled form, auto migration will continue to execute SQL
--   statements to update the schema even when it does not need to.
rawSqlDefault :: ValueExpression -> DefaultValue a


module Orville.PostgreSQL.OrvilleState

-- | <a>OrvilleState</a> is used to manange opening connections to the
--   database, transactions, etc. <a>newOrvilleState</a> should be used to
--   create an appopriate initial state for your monad's context.
data OrvilleState

-- | Creates a appropriate initial <a>OrvilleState</a> that will use the
--   connection pool given to initiate connections to the database.
newOrvilleState :: ErrorDetailLevel -> Pool Connection -> OrvilleState

-- | Creates a new initial <a>OrvilleState</a> using the connection pool
--   from the provide state. You might need to use this if you are spawning
--   one Orville monad from another and they should not share the same
--   connection and transaction state.
resetOrvilleState :: OrvilleState -> OrvilleState

-- | Get the connection pool being used for the <a>OrvilleState</a>
orvilleConnectionPool :: OrvilleState -> Pool Connection

-- | The <a>ErrorDetailLevel</a> controls how much information Orville
--   includes in error messages it generates when data cannot be decoded
--   rows in the database.
orvilleErrorDetailLevel :: OrvilleState -> ErrorDetailLevel

-- | Orville will call the transaction callback any time a transaction
--   event occurrs. You can register a callback with
--   <tt>addTransactionCallBack</tt>.
orvilleTransactionCallback :: OrvilleState -> TransactionEvent -> IO ()

-- | The SqlCommenter attributes that Orville will include with queries.
--   These can be modified with <a>addSqlCommenterAttributes</a>. See
--   <a>https://google.github.io/sqlcommenter/</a>.
orvilleSqlCommenterAttributes :: OrvilleState -> Maybe SqlCommenterAttributes

-- | Registers a callback to be invoked during transactions.
--   
--   The callback given will be called after the SQL statement
--   corresponding to the given event has finished executing. Callbacks
--   will be called in the order the are added.
--   
--   Note: There is no specialized error handling for these callbacks. This
--   means that if a callback raises an exception no further callbacks will
--   be called and the exception will propagate up until it caught
--   elsewhere. In particular, if an exception is raised by a callback upon
--   opening the transaction it will cause the transaction to be
--   rolled-back the same as any other exception that might happen during
--   the transaction. In general, we recommend only using callbacks that
--   either raise no exceptions or can handle their own exceptions cleanly.
addTransactionCallback :: (TransactionEvent -> IO ()) -> OrvilleState -> OrvilleState

-- | Describes an event in the lifecycle of a database transaction. You can
--   use <tt>addTransactionCallBack</tt> to register a callback to respond
--   to these events. The callback will be called after the even in
--   question has been succesfully executed.
data TransactionEvent

-- | Indicates a new transaction has been started
BeginTransaction :: TransactionEvent

-- | Indicates that a new savepoint has been saved within a transaction
NewSavepoint :: Savepoint -> TransactionEvent

-- | Indicates that a previous savepoint has been released. It can no
--   longer be rolled back to.
ReleaseSavepoint :: Savepoint -> TransactionEvent

-- | Indicates that rollbac was performed to a prior savepoint.
--   
--   Note: It is possible to rollback to a savepoint prior to the most
--   recent one without releasing or rolling back to intermediate
--   savepoints. Doing so destroys any savepoints created after given
--   savepoint. Although Orville currently always matches
--   <a>NewSavepoint</a> with either <a>ReleaseSavepoint</a> or
--   <a>RollbackToSavepoint</a>, it is recommended that you do not rely on
--   this behavior.
RollbackToSavepoint :: Savepoint -> TransactionEvent

-- | Indicates that the transaction has been committed.
CommitTransaction :: TransactionEvent

-- | Indicates that the transaction has been rolled back.
RollbackTransaction :: TransactionEvent

-- | An internal Orville identifier for a savepoint in a PostgreSQL
--   transaction.
data Savepoint

-- | Indicates how many levels of nested savepoints the given
--   <a>Savepoint</a> identifier represents.
savepointNestingLevel :: Savepoint -> Int

-- | The initial identifier Orville uses to track the first savepoint
--   within a transaction.
initialSavepoint :: Savepoint

-- | Determines identifier for the next savepoint in a transaction after
--   the given saveponit&gt;
nextSavepoint :: Savepoint -> Savepoint

-- | The callback Orville will call whenever it wants to run SQL. You can
--   register a callback using <a>addSqlExecutionCallback</a>.
orvilleSqlExecutionCallback :: OrvilleState -> forall a. QueryType -> RawSql -> IO a -> IO a

-- | Adds a callback to be called when an Orville operation executes a SQL
--   statement. The callback is given the IO action that will perform the
--   query execution and must call that action for the query to be run. In
--   particular, you can use this to time query and log any that are slow.
--   
--   Calls to any previously added callbacks will also be execute as part
--   of the IO action passed to the new callback. Thus the newly added
--   callback happens "around" the previously added callback.
--   
--   There is no special exception handling done for these callbacks beyond
--   what they implement themelves. Any callbacks should allow for the
--   possibility that the IO action they are given may raise an exception.
addSqlExecutionCallback :: (forall a. QueryType -> RawSql -> IO a -> IO a) -> OrvilleState -> OrvilleState

-- | The SQL expression that Orville will use to begin a transaction. You
--   can set this via <a>setBeginTransactionExpr</a> to have fine grained
--   control over the transaction parameters, such as isolation level.
orvilleBeginTransactionExpr :: OrvilleState -> BeginTransactionExpr

-- | Sets the SQL expression that Orville will use to begin transactions.
--   You can control the transaction isolation level by building your own
--   <a>BeginTransactionExpr</a> with the desired isolation level.
setBeginTransactionExpr :: BeginTransactionExpr -> OrvilleState -> OrvilleState

-- | Sets the SqlCommenterAttributes that Orville will then add to any
--   following statement executions.
setSqlCommenterAttributes :: SqlCommenterAttributes -> OrvilleState -> OrvilleState

-- | Adds the SqlCommenterAttributes to the already existing that Orville
--   will then add to any following statement executions.
addSqlCommenterAttributes :: SqlCommenterAttributes -> OrvilleState -> OrvilleState


module Orville.PostgreSQL.Monad.HasOrvilleState

-- | <a>HasOrvilleState</a> is the typeclass that Orville uses to access
--   and manange the connection pool and state tracking when it is being
--   executed inside an unknown Monad. It is a specialized version of the
--   Reader interface so that it can easily implemented by application
--   Monads that already have a Reader context and want to simply add
--   <a>OrvilleState</a> as an attribute to that context, like so
--   
--   <pre>
--   data MyApplicationState =
--     MyApplicationState
--       { appConfig :: MyAppConfig
--       , appOrvilleState :: OrvilleState
--       }
--   
--   newtype MyApplicationMonad a =
--     MyApplicationMonad (ReaderT MyApplicationState IO) a
--   
--   instance HasOrvilleState MyApplicationMonad where
--     askOrvilleState =
--       MyApplicationMonad (asks appOrvilleState)
--   
--     localOrvilleState f (MyApplicationMonad reader) =
--       MyApplicationMonad $
--         local
--           (state -&gt; state { appOrvilleState = f (appOrvilleState state))
--           reader
--   
--   </pre>
--   
--   An instance for 'ReaderT OrvilleState m' is provided as a convenience
--   in the case that your application has no extra context to track.
class HasOrvilleState m

-- | Fetches the current <a>OrvilleState</a> from the host Monad context.
--   The equivalent of <a>ask</a> for 'ReaderT OrvilleState'
askOrvilleState :: HasOrvilleState m => m OrvilleState

-- | Applies a modification to the <a>OrvilleState</a> that is local to the
--   given monad operation. Calls to <a>askOrvilleState</a> made within the
--   'm a' provided must return the modified state. The modified state must
--   only apply to the given 'm a' and not persisted beyond it. The
--   equivalent of <a>local</a> for 'ReaderT OrvilleState'
localOrvilleState :: HasOrvilleState m => (OrvilleState -> OrvilleState) -> m a -> m a
instance GHC.Base.Monad m => Orville.PostgreSQL.Monad.HasOrvilleState.HasOrvilleState (Control.Monad.Trans.Reader.ReaderT Orville.PostgreSQL.Internal.OrvilleState.OrvilleState m)
instance (GHC.Base.Monad m, Orville.PostgreSQL.Monad.HasOrvilleState.HasOrvilleState m) => Orville.PostgreSQL.Monad.HasOrvilleState.HasOrvilleState (Control.Monad.Trans.Reader.ReaderT r m)


module Orville.PostgreSQL.Monad.MonadOrville

-- | <a>MonadOrville</a> is the typeclass that most Orville operations
--   require to do anything that connects to the database.
--   <a>MonadOrville</a> itself is empty, but it lists all the required
--   typeclasses as superclass contraints so that it can be used instead of
--   listing all the constraints on every function.
--   
--   If you want to be able to run Orville operations directly in your own
--   application's Monad stack, a good starting place is to add
--   
--   <pre>
--   instance MonadOrville MyApplicationMonad
--   
--   </pre>
--   
--   to your module and then let the compiler tell you what instances you
--   are missing from the superclasses.
class (HasOrvilleState m, MonadOrvilleControl m, MonadIO m) => MonadOrville m

-- | <a>MonadOrvilleControl</a> presents the interface that Orville will
--   used to lift low-level IO operations that cannot be lifted via
--   <tt>liftIO</tt> (i.e. those where the IO parameter is contravriant
--   rather than covariant).
--   
--   For application monads built using only <a>ReaderT</a> and <a>IO</a>,
--   this can be trivially implemented (or derived), using the
--   <a>ReaderT</a> instance that is provided here. If you monad stack is
--   sufficiently complicated, you may need to use the <tt>unliftio</tt>
--   package as a stepping stone to implementing
--   <a>MonadOrvilleControl</a>. If your monad uses features that
--   <tt>unliftio</tt> cannot support (e.g. the State monad or
--   continuations), then you may need to use 'monad-control' instead.
--   
--   See <a>UnliftIO</a> for functions that can be used as the
--   implementation of the methods below for monads that implement
--   <tt>MonadUnliftIO</tt>.
class MonadOrvilleControl m

-- | Orville will use this function to lift the acquisition of connections
--   from the resource pool into the application monad.
liftWithConnection :: MonadOrvilleControl m => (forall a. (Connection -> IO a) -> IO a) -> (Connection -> m b) -> m b

-- | Orville will use this function to lift exception catches into the
--   application monad.
liftCatch :: (MonadOrvilleControl m, Exception e) => (forall a. IO a -> (e -> IO a) -> IO a) -> m b -> (e -> m b) -> m b

-- | Orville will use this function to lift <tt>mask</tt> calls into the
--   application monad to guarantee resource cleanup is executed even when
--   asynchrouns exceptions are thrown.
liftMask :: MonadOrvilleControl m => (forall b. ((forall a. IO a -> IO a) -> IO b) -> IO b) -> ((forall a. m a -> m a) -> m c) -> m c

-- | <a>withConnection</a> should be used to receive a <a>Connection</a>
--   handle for executing queries against the database from within an
--   application monad using Orville. For the "outermost" call of
--   <a>withConnection</a>, a connection will be acquired from the resource
--   pool. Additional calls to <a>withConnection</a> that happen inside the
--   'm a' that uses the connection will return the same <a>Connection</a>
--   the same connection. When the 'm a' finishes the connection will be
--   returned to the pool. If 'm a' throws an exception the pool's
--   exception handling will take effect, generally destroying the
--   connection in case it was the source of the error.
withConnection :: MonadOrville m => (Connection -> m a) -> m a

-- | <a>withConnection_</a> is a convenience version of
--   <a>withConnection</a> for those that don't need the actual connection
--   handle. You might want to use this function even without using the
--   handle because it ensures that all the Orville operations performed by
--   the action passed to it occur on the same connection. Orville uses
--   connection pooling, so unless you use either <a>withConnection</a> or
--   <tt>withTransaction</tt> each database operation may be performed on a
--   different connection.
withConnection_ :: MonadOrville m => m a -> m a

-- | INTERNAL: This in an internal version of <a>withConnection</a> that
--   gives access to the entire <a>ConnectedState</a> value to allow for
--   transaction management.
withConnectedState :: MonadOrville m => (ConnectedState -> m a) -> m a
instance (Orville.PostgreSQL.Monad.MonadOrville.MonadOrvilleControl m, Control.Monad.IO.Class.MonadIO m) => Orville.PostgreSQL.Monad.MonadOrville.MonadOrville (Control.Monad.Trans.Reader.ReaderT Orville.PostgreSQL.Internal.OrvilleState.OrvilleState m)
instance Orville.PostgreSQL.Monad.MonadOrville.MonadOrvilleControl GHC.Types.IO
instance Orville.PostgreSQL.Monad.MonadOrville.MonadOrvilleControl m => Orville.PostgreSQL.Monad.MonadOrville.MonadOrvilleControl (Control.Monad.Trans.Reader.ReaderT state m)


module Orville.PostgreSQL.Monad.Orville

-- | The <a>Orville</a> Monad provides a easy starter implementation of
--   <tt>MonadOrville</tt> when you don't have a monad specific to your
--   application that you need to use.
--   
--   If you want add Orville capabilities to your own monad, take a look at
--   <tt>MonadOrville</tt> to learn what needs to be done.
data Orville a

-- | Runs an <a>Orville</a> operation in the <a>IO</a> monad using the
--   given connection pool.
--   
--   This will run the <a>Orville</a> operation with the
--   <tt>ErrorDetailLevel</tt> set to the default. If want to run with a
--   different detail level, you can use <a>newOrvilleState</a> to create a
--   state with the desired detail level and then use
--   <a>runOrvilleWithState</a>.
runOrville :: Pool Connection -> Orville a -> IO a

-- | Runs an <a>Orville</a> operation in the <a>IO</a> monad, starting from
--   the provided <tt>OrvilleState</tt>.
--   
--   Caution: If you harvest an <tt>OrvilleState</tt> from inside a
--   <a>MonadOrville</a> monad using <a>askOrvilleState</a>, you may pick
--   up connection tracking state that you didn't intend to. You may want
--   to use <a>resetOrvilleState</a> in this situation to get a new initial
--   state before passing it to <a>runOrvilleWithState</a>.
--   
--   On the other hand, if you know that you want to pass the existing
--   connection state from another monad into the <a>Orville</a> monad,
--   this is how you do it.
runOrvilleWithState :: OrvilleState -> Orville a -> IO a
instance Control.Monad.Catch.MonadCatch Orville.PostgreSQL.Monad.Orville.Orville
instance Control.Monad.Catch.MonadThrow Orville.PostgreSQL.Monad.Orville.Orville
instance Orville.PostgreSQL.Monad.HasOrvilleState.HasOrvilleState Orville.PostgreSQL.Monad.Orville.Orville
instance Orville.PostgreSQL.Monad.MonadOrville.MonadOrville Orville.PostgreSQL.Monad.Orville.Orville
instance Orville.PostgreSQL.Monad.MonadOrville.MonadOrvilleControl Orville.PostgreSQL.Monad.Orville.Orville
instance Control.Monad.IO.Class.MonadIO Orville.PostgreSQL.Monad.Orville.Orville
instance GHC.Base.Monad Orville.PostgreSQL.Monad.Orville.Orville
instance GHC.Base.Applicative Orville.PostgreSQL.Monad.Orville.Orville
instance GHC.Base.Functor Orville.PostgreSQL.Monad.Orville.Orville


-- | You can import <a>Orville.PostgreSQL.Monad</a> to get access to all
--   the functions related to managing Orville context within an
--   application Monad. This includes a number of lowel-level items not
--   exported by <a>Orville.PostgreSQL</a> that give you more control (and
--   therefore responsibility) over the Monad context.
module Orville.PostgreSQL.Monad


module Orville.PostgreSQL.Execution.SelectOptions

-- | A <a>SelectOptions</a> is a set of options that can be used to change
--   the way a basic query function works by adding <tt>WHERE</tt>, 'ORDER
--   BY', 'GROUP BY', etc. Functions are provided to construct
--   <a>SelectOptions</a> for individual options, which may then be
--   combined via <a>&lt;&gt;</a> (also exposed as
--   <a>appendSelectOptions</a>).
data SelectOptions

-- | A set of empty <a>SelectOptions</a> that will not change how a query
--   is run.
emptySelectOptions :: SelectOptions

-- | Combines multple select options together, unioning the options
--   together where possible. For options where this is not possible, (e.g.
--   <tt>LIMIT</tt>), the one on the left is preferred.
appendSelectOptions :: SelectOptions -> SelectOptions -> SelectOptions

-- | Builds the <a>SelectClause</a> that should be used to include the
--   <a>distinct</a>s from the <a>SelectOptions</a> on a query.
selectDistinct :: SelectOptions -> SelectClause

-- | Builds the <a>WhereClause</a> that should be used to include the
--   <tt>WhereCondition</tt>s from the <a>SelectOptions</a> on a query.
--   This will be <a>Nothing</a> where no <tt>WhereCondition</tt>s have
--   been specified.
selectWhereClause :: SelectOptions -> Maybe WhereClause

-- | Builds the <a>OrderByClause</a> that should be used to include the
--   <tt>OrderByClause</tt>s from the <a>SelectOptions</a> on a query. This
--   will be <a>Nothing</a> where no <tt>OrderByClause</tt>s have been
--   specified.
selectOrderByClause :: SelectOptions -> Maybe OrderByClause

-- | Builds the <a>GroupByClause</a> that should be used to include the
--   <tt>GroupByClause</tt>s from the <a>SelectOptions</a> on a query. This
--   will be <a>Nothing</a> where no <tt>GroupByClause</tt>s have been
--   specified.
selectGroupByClause :: SelectOptions -> Maybe GroupByClause

-- | Builds a <a>LimitExpr</a> that will limit the query results to the
--   number specified in the <a>SelectOptions</a> (if any)
selectLimitExpr :: SelectOptions -> Maybe LimitExpr

-- | Builds a <a>OffsetExpr</a> that will limit the query results to the
--   number specified in the <a>SelectOptions</a> (if any)
selectOffsetExpr :: SelectOptions -> Maybe OffsetExpr

-- | Constructs a <a>SelectOptions</a> with just <a>distinct</a> set to
--   <a>True</a>.
distinct :: SelectOptions

-- | Constructs a <a>SelectOptions</a> with just the given
--   <tt>WhereCondition</tt>.
where_ :: BooleanExpr -> SelectOptions

-- | Constructs a <a>SelectOptions</a> with just the given
--   <a>OrderByExpr</a>.
orderBy :: OrderByExpr -> SelectOptions

-- | Constructs a <a>SelectOptions</a> that will apply the given limit.
limit :: Int -> SelectOptions

-- | Constructs a <a>SelectOptions</a> that will apply the given offset.
offset :: Int -> SelectOptions

-- | Constructs a <a>SelectOptions</a> with just the given
--   <tt>GroupByClause</tt>.
groupBy :: GroupByExpr -> SelectOptions

-- | Builds a <tt>QueryExpr</tt> that will use the specified
--   <a>SelectList</a> when building the <tt>SELECT</tt> statement to
--   execute. It it up to the caller to make sure that the
--   <a>SelectList</a> expression makes sens for the table being queried,
--   and that the names of the columns in the result set match those
--   expected by the given <tt>SqlMarshaller</tt>, which will be used to
--   decode it.
--   
--   This function is useful for building more advanced queries that need
--   to select things other than simple columns from the table, such as
--   using aggregate functions. The <a>SelectList</a> can be built however
--   the caller desires. If Orville does not support building the
--   <a>SelectList</a> you need using any of the expression building
--   functions, you can resort to <tt>RawSql.fromRawSql</tt> as an escape
--   hatch to build the <a>SelectList</a> here.
selectOptionsQueryExpr :: SelectList -> TableReferenceList -> SelectOptions -> QueryExpr
instance GHC.Base.Semigroup Orville.PostgreSQL.Execution.SelectOptions.SelectOptions
instance GHC.Base.Monoid Orville.PostgreSQL.Execution.SelectOptions.SelectOptions


module Orville.PostgreSQL.Execution.ExecutionResult

-- | <a>ExecutionResult</a> is a common interface for types that represent
--   a result set returned from the database. For real, live database
--   interactions this the concrete type will be a <a>Result</a>, but the
--   <a>FakeLibPQResult</a> may be useful as well if you are writing custom
--   code for decoding result sets and want to test aspects of the decoding
--   that don't require a real database.
class ExecutionResult result
maxRowNumber :: ExecutionResult result => result -> IO (Maybe Row)
maxColumnNumber :: ExecutionResult result => result -> IO (Maybe Column)
columnName :: ExecutionResult result => result -> Column -> IO (Maybe ByteString)
getValue :: ExecutionResult result => result -> Row -> Column -> IO SqlValue

-- | A trivial wrapper for <a>Int</a> to help keep track of column vs row
--   number
newtype Column
Column :: Int -> Column

-- | A trivial wrapper for <a>Int</a> to help keep track of column vs row
--   number
newtype Row
Row :: Int -> Row

-- | Read the rows of an <a>ExecutionResult</a> a list of column name,
--   <a>SqlValue</a> pairs. You're almost always better off using a
--   <a>SqlMarshaller</a> instead, but this function is provided for cases
--   where you really want to decode the rows yourself but don't want to
--   use the <a>ExecutionResult</a> api to read each row of each column
--   directly.
readRows :: ExecutionResult result => result -> IO [[(Maybe ByteString, SqlValue)]]

-- | <a>FakeLibPQResult</a> provides a fake, in memory implementation of
--   <a>ExecutionResult</a>. This is mostly useful for writing automated
--   tests that can assume a result set has been loaded and just need to
--   test decoding the results.
data FakeLibPQResult

-- | Constructs a <a>FakeLibPQResult</a>. The column names given as
--   associated with the values for each row by their position in list. Any
--   missing values (e.g. because a row is shorter than the heeader list)
--   are treated as a SQL Null value.
mkFakeLibPQResult :: [ByteString] -> [[SqlValue]] -> FakeLibPQResult
instance GHC.Num.Num Orville.PostgreSQL.Execution.ExecutionResult.Column
instance GHC.Enum.Enum Orville.PostgreSQL.Execution.ExecutionResult.Column
instance GHC.Classes.Ord Orville.PostgreSQL.Execution.ExecutionResult.Column
instance GHC.Classes.Eq Orville.PostgreSQL.Execution.ExecutionResult.Column
instance GHC.Num.Num Orville.PostgreSQL.Execution.ExecutionResult.Row
instance GHC.Enum.Enum Orville.PostgreSQL.Execution.ExecutionResult.Row
instance GHC.Classes.Ord Orville.PostgreSQL.Execution.ExecutionResult.Row
instance GHC.Classes.Eq Orville.PostgreSQL.Execution.ExecutionResult.Row
instance Orville.PostgreSQL.Execution.ExecutionResult.ExecutionResult Orville.PostgreSQL.Execution.ExecutionResult.FakeLibPQResult
instance Orville.PostgreSQL.Execution.ExecutionResult.ExecutionResult Database.PostgreSQL.LibPQ.Result


module Orville.PostgreSQL.Schema.SequenceIdentifier

-- | An identifier used by Orville to identify a particular sequence in a
--   particular schema.
data SequenceIdentifier

-- | Constructs a <a>SequenceIdentifier</a> where the sequence's name will
--   not be qualified by a particular schema.
unqualifiedNameToSequenceId :: String -> SequenceIdentifier

-- | Sets the schema of the <a>SequenceIdentifier</a>. Wherever applicable,
--   references to the sequence will be qualified by the given scheme name.
setSequenceIdSchema :: String -> SequenceIdentifier -> SequenceIdentifier

-- | Returns the 'Expr.Qualified Expr.SequenceName' that should be used to
--   refer to the sequence in SQL queries.
sequenceIdQualifiedName :: SequenceIdentifier -> Qualified SequenceName

-- | Returns the unqualified <a>SequenceName</a> that should be used to
--   refer to the sequence in SQL queries where an unqualified reference is
--   appropriate.
sequenceIdUnqualifiedName :: SequenceIdentifier -> SequenceName

-- | Returns the <a>SchemaName</a> (if any) that should be used to qualify
--   references to the sequence in SQL queries.
sequenceIdSchemaName :: SequenceIdentifier -> Maybe SchemaName

-- | Converts a <a>SequenceIdentifier</a> for a string for descriptive
--   purposes. The name will be qualified if a schema name has been set for
--   the identifier.
--   
--   Note: You should not use this function for building SQL expressions.
--   Use <a>sequenceIdQualifiedName</a> instead for that.
sequenceIdToString :: SequenceIdentifier -> String

-- | Retrieves the unqualified name of the sequence as a string.
sequenceIdUnqualifiedNameString :: SequenceIdentifier -> String

-- | Retrieves the schema name of the sequence as a string
sequenceIdSchemaNameString :: SequenceIdentifier -> Maybe String
instance GHC.Show.Show Orville.PostgreSQL.Schema.SequenceIdentifier.SequenceIdentifier
instance GHC.Classes.Ord Orville.PostgreSQL.Schema.SequenceIdentifier.SequenceIdentifier
instance GHC.Classes.Eq Orville.PostgreSQL.Schema.SequenceIdentifier.SequenceIdentifier


module Orville.PostgreSQL.Schema.SequenceDefinition

-- | Contains the definition of a SQL sequence for Orville to use when
--   creating the sequence and fetching values from it. You can create a
--   <a>SequenceDefinition</a> with default values via
--   <a>mkSequenceDefinition</a> and then use the various set functions
--   that are provided if you need to set specific attributes on the
--   sequence.
data SequenceDefinition

-- | Constructs an ascending <a>SequenceDefinition</a> with increment 1 and
--   cache 1 that does not cycle. The sequence will start at 1 and count to
--   the largest <a>Int64</a> value.
mkSequenceDefinition :: String -> SequenceDefinition

-- | Sets the sequence's schema to the name in the given string, which will
--   be treated as a SQL identifier. If a sequence has a schema name set,
--   it will be included as a qualified on the sequence name for all
--   queries involving the sequence.
setSequenceSchema :: String -> SequenceDefinition -> SequenceDefinition

-- | Retrieves the <a>SequenceIdentifier</a> for this sequence, which is
--   set by the name provided to <a>mkSequenceDefinition</a> and any calls
--   make to <a>setSequenceSchema</a> thereafter.
sequenceIdentifier :: SequenceDefinition -> SequenceIdentifier

-- | Retrieves the <a>Qualified</a> <a>SequenceName</a> for the sequence
--   that should be used to build SQL expressions involving it.
sequenceName :: SequenceDefinition -> Qualified SequenceName

-- | Retrieves the increment value for the sequence.
sequenceIncrement :: SequenceDefinition -> Int64

-- | Sets the increment value for the sequence. The increment cannot be set
--   to <tt>0</tt> (PostgreSQL will raise an error when trying to create or
--   modify the sequence in this case).
--   
--   If the increment is negative the sequence will be descending. When no
--   explicit start is set a descending sequence begins at the max value.
setSequenceIncrement :: Int64 -> SequenceDefinition -> SequenceDefinition

-- | Retrieves the min value of the sequence. If no explicit minimum has
--   been set this returns <tt>1</tt> for ascending sequences and
--   <a>minBound</a> for <a>Int64</a> for descending sequences.
sequenceMinValue :: SequenceDefinition -> Int64

-- | Sets the min value for the sequence.
setSequenceMinValue :: Int64 -> SequenceDefinition -> SequenceDefinition

-- | Retrieves the max value of the sequence. If no explicit maximum has
--   been set this returns <a>maxBound</a> for <a>Int64</a> for ascending
--   sequences and <tt>-1</tt> descending sequences.
sequenceMaxValue :: SequenceDefinition -> Int64

-- | Sets the max value for the sequence.
setSequenceMaxValue :: Int64 -> SequenceDefinition -> SequenceDefinition

-- | Retrieves the start value for the sequence. If no explicit start value
--   has been set this returns <a>sequenceMinValue</a> for ascending
--   sequences and <a>sequenceMaxValue</a> for descending sequences.
sequenceStart :: SequenceDefinition -> Int64

-- | Sets the sequence start value. The start value must be at least the
--   minimum value and no greater than the max value.
setSequenceStart :: Int64 -> SequenceDefinition -> SequenceDefinition

-- | Retrieves the number of sequence values that will be pre-allocated by
--   PostgreSQL.
sequenceCache :: SequenceDefinition -> Int64

-- | Sets the number of sequence values that will be pre-allocated by
--   PostgreSQL.
setSequenceCache :: Int64 -> SequenceDefinition -> SequenceDefinition

-- | Indicates whether the sequence will wrap around when it reaches the
--   maximum value (for ascending sequences) or minimum value (for
--   descending sequences). When <a>False</a>, any attempts to get the next
--   value of the sequence while at the limit will result in an error.
sequenceCycle :: SequenceDefinition -> Bool

-- | Sets the <a>sequenceCycle</a> value for the sequence. <a>True</a>
--   indicates that the sequence will cycle. <a>False</a> will cause an
--   error to be raised if the next sequence value is requested while
--   already at the limit.
setSequenceCycle :: Bool -> SequenceDefinition -> SequenceDefinition

-- | Builds a <a>CreateSequenceExpr</a> that will create a SQL sequence
--   matching the given <a>SequenceDefinition</a> when it is executed.
mkCreateSequenceExpr :: SequenceDefinition -> CreateSequenceExpr
instance GHC.Show.Show Orville.PostgreSQL.Schema.SequenceDefinition.SequenceDefinition
instance GHC.Classes.Eq Orville.PostgreSQL.Schema.SequenceDefinition.SequenceDefinition


module Orville.PostgreSQL.Schema.TableIdentifier

-- | An identifier used by Orville to identify a particular table in a
--   particular schema.
data TableIdentifier

-- | Constructs a <a>TableIdentifier</a> where the table's name will not be
--   qualified by a particular schema.
unqualifiedNameToTableId :: String -> TableIdentifier

-- | Sets the schema of the <a>TableIdentifier</a>. Wherever applicable,
--   references to the table will be qualified by the given scheme name.
setTableIdSchema :: String -> TableIdentifier -> TableIdentifier

-- | Returns the 'Expr.Qualified Expr.TableName' that should be used to
--   refer to the table in SQL queries.
tableIdQualifiedName :: TableIdentifier -> Qualified TableName

-- | Returns the unqualified <a>TableName</a> that should be used to refer
--   to the table in SQL queries where an unqualified reference is
--   appropriate.
tableIdUnqualifiedName :: TableIdentifier -> TableName

-- | Returns the <a>SchemaName</a> (if any) that should be used to qualify
--   references to the table in SQL queries.
tableIdSchemaName :: TableIdentifier -> Maybe SchemaName

-- | Converts a <a>TableIdentifier</a> for a string for descriptive
--   purposes. The name will be qualified if a schema name has been set for
--   the identifier.
--   
--   Note: You should not use this function for building SQL expressions.
--   Use <a>tableIdQualifiedName</a> instead for that.
tableIdToString :: TableIdentifier -> String

-- | Retrieves the unqualified name of the table as a string.
tableIdUnqualifiedNameString :: TableIdentifier -> String

-- | Retrieves the schema name of the table as a string
tableIdSchemaNameString :: TableIdentifier -> Maybe String
instance GHC.Show.Show Orville.PostgreSQL.Schema.TableIdentifier.TableIdentifier
instance GHC.Classes.Ord Orville.PostgreSQL.Schema.TableIdentifier.TableIdentifier
instance GHC.Classes.Eq Orville.PostgreSQL.Schema.TableIdentifier.TableIdentifier


module Orville.PostgreSQL.Schema.ConstraintDefinition

-- | Defines a constraint that can be added to a <a>TableDefinition</a>.
--   Use one of the constructor functions below (such as
--   <a>uniqueConstraint</a>) to construct the constraint definition you
--   wish to have and then use <a>addTableConstraints</a>. to add them to
--   your table definition. Orville will then add the constraint next time
--   you run auto-migrations.
data ConstraintDefinition

-- | Constructs a <a>ConstraintDefinition</a> for a <tt>UNIQUE</tt>
--   constraint on the given columns.
uniqueConstraint :: NonEmpty FieldName -> ConstraintDefinition

-- | Builds a <a>ConstraintDefinition</a> for a <tt>FOREIGN KEY</tt>
--   constraint.
foreignKeyConstraint :: TableIdentifier -> NonEmpty ForeignReference -> ConstraintDefinition

-- | Builds a <a>ConstraintDefinition</a> for a <tt>FOREIGN KEY</tt>
--   constraint, with ON UPDATE and ON DELETE actions.
foreignKeyConstraintWithOptions :: TableIdentifier -> NonEmpty ForeignReference -> ForeignKeyOptions -> ConstraintDefinition

-- | A <a>ForeignReference</a> represents one part of a foreign key. The
--   entire foreign key may comprise multiple columns. The
--   <a>ForeignReference</a> defines a single column in the key and which
--   column it references in the foreign table.
data ForeignReference
ForeignReference :: FieldName -> FieldName -> ForeignReference
[localFieldName] :: ForeignReference -> FieldName
[foreignFieldName] :: ForeignReference -> FieldName

-- | Constructs a <a>ForeignReference</a>
foreignReference :: FieldName -> FieldName -> ForeignReference

-- | The key used by Orville to determine whether a constraint should be
--   added to a table when performing auto migrations. For most use cases
--   the constructor functions that build a <a>ConstraintDefinition</a>
--   will create this automatically for you.
data ConstraintMigrationKey
ConstraintMigrationKey :: ConstraintKeyType -> Maybe [FieldName] -> Maybe TableIdentifier -> Maybe [FieldName] -> Maybe ForeignKeyAction -> Maybe ForeignKeyAction -> ConstraintMigrationKey
[constraintKeyType] :: ConstraintMigrationKey -> ConstraintKeyType
[constraintKeyColumns] :: ConstraintMigrationKey -> Maybe [FieldName]
[constraintKeyForeignTable] :: ConstraintMigrationKey -> Maybe TableIdentifier
[constraintKeyForeignColumns] :: ConstraintMigrationKey -> Maybe [FieldName]
[constraintKeyForeignKeyOnUpdateAction] :: ConstraintMigrationKey -> Maybe ForeignKeyAction
[constraintKeyForeignKeyOnDeleteAction] :: ConstraintMigrationKey -> Maybe ForeignKeyAction

-- | The kind of constraint that is described by a
--   <a>ConstraintMigrationKey</a> (e.g. unique, foreign key).
data ConstraintKeyType
UniqueConstraint :: ConstraintKeyType
ForeignKeyConstraint :: ConstraintKeyType

-- | Gets the <a>ConstraintMigrationKey</a> for the
--   <a>ConstraintDefinition</a>
constraintMigrationKey :: ConstraintDefinition -> ConstraintMigrationKey

-- | Gets the SQL expression that will be used to add the constraint to the
--   table.
constraintSqlExpr :: ConstraintDefinition -> TableConstraint

-- | The actions that can be set on <a>ForeignKeyOptions</a>.
data ForeignKeyAction
NoAction :: ForeignKeyAction
Restrict :: ForeignKeyAction
Cascade :: ForeignKeyAction
SetNull :: ForeignKeyAction
SetDefault :: ForeignKeyAction

-- | Defines the options for a foreign key constraint. To construct
--   <a>ForeignKeyOptions</a>, perform a record update on
--   <a>defaultForeignKeyOptions</a>.
data ForeignKeyOptions

-- | The default <a>ForeignKeyOptions</a>, containing <a>NoAction</a> for
--   both <a>foreignKeyOptionsOnUpdate</a> and
--   <a>foreignKeyOptionsOnDelete</a>.
defaultForeignKeyOptions :: ForeignKeyOptions

-- | A collection of constraints to be able to a table. This collection is
--   indexed by <a>ConstraintMigrationKey</a>. If multiple constraints with
--   the same <a>ConstraintMigrationKey</a> are added the most recently
--   added one will be kept and the previous one dropped.
data TableConstraints

-- | Constructs an empty <a>TableConstraints</a>
emptyTableConstraints :: TableConstraints

-- | Adds a <a>ConstraintDefinition</a> to an existing
--   <a>TableConstraints</a>. If a constraint already exists with the same
--   <a>ConstraintMigrationKey</a> it is replaced with the new constraint.
addConstraint :: ConstraintDefinition -> TableConstraints -> TableConstraints

-- | Gets the list of <a>ConstraintDefinition</a>s that have been added to
--   the <a>TableConstraints</a>
tableConstraintDefinitions :: TableConstraints -> [ConstraintDefinition]

-- | Gets the list of <a>ConstraintDefinition</a>s that have been added to
--   the <a>TableConstraints</a>
tableConstraintKeys :: TableConstraints -> Set ConstraintMigrationKey
instance GHC.Show.Show Orville.PostgreSQL.Schema.ConstraintDefinition.ConstraintKeyType
instance GHC.Classes.Ord Orville.PostgreSQL.Schema.ConstraintDefinition.ConstraintKeyType
instance GHC.Classes.Eq Orville.PostgreSQL.Schema.ConstraintDefinition.ConstraintKeyType
instance GHC.Classes.Ord Orville.PostgreSQL.Schema.ConstraintDefinition.ForeignKeyAction
instance GHC.Classes.Eq Orville.PostgreSQL.Schema.ConstraintDefinition.ForeignKeyAction
instance GHC.Show.Show Orville.PostgreSQL.Schema.ConstraintDefinition.ForeignKeyAction
instance GHC.Show.Show Orville.PostgreSQL.Schema.ConstraintDefinition.ConstraintMigrationKey
instance GHC.Classes.Ord Orville.PostgreSQL.Schema.ConstraintDefinition.ConstraintMigrationKey
instance GHC.Classes.Eq Orville.PostgreSQL.Schema.ConstraintDefinition.ConstraintMigrationKey
instance GHC.Base.Monoid Orville.PostgreSQL.Schema.ConstraintDefinition.TableConstraints
instance GHC.Base.Semigroup Orville.PostgreSQL.Schema.ConstraintDefinition.TableConstraints


-- | This module provides functions for working with Orville
--   <a>FieldDefinition</a> values. <a>FieldDefinition</a> is use to
--   determine the column name and data type that a Haskell field is mapped
--   to via a <a>SqlMarshaller</a>. It is also used for constructing
--   boolean conditions for matching rows in queries.
module Orville.PostgreSQL.Marshall.FieldDefinition

-- | <a>FieldDefinition</a> determines the SQL constsruction of a column in
--   the database, comprising the name, SQL type and whether the field is
--   nullable. A <a>FieldDefinition</a> is matched to a particular Haskell
--   type, which it knows how to marshall to and from the database
--   representation of SQL type for the field.
data FieldDefinition nullability a

-- | The name used in database queries to reference the field.
fieldName :: FieldDefinition nullability a -> FieldName

-- | Returns the description that was passed to <a>setFieldDescription</a>,
--   if any.
fieldDescription :: FieldDefinition nullability a -> Maybe String

-- | Sets the description for the field. This description not currently
--   used anywhere by Orville itself, but users can retrieve the
--   description via <a>fieldDescription</a> for their own purposes (e.g.
--   generating documentation).
setFieldDescription :: String -> FieldDefinition nullability a -> FieldDefinition nullability a

-- | The <tt>SqlType</tt> for the <a>FieldDefinition</a> determines the
--   PostgreSQL data type used to define the field as well as how to
--   mashall Haskell values to and from the database.
fieldType :: FieldDefinition nullability a -> SqlType a

-- | Indicates whether a field is nullable.
fieldIsNotNullable :: FieldDefinition nullability a -> Bool

-- | Returns the default value definition for the field, if any has been
--   set.
fieldDefaultValue :: FieldDefinition nullability a -> Maybe (DefaultValue a)

-- | Resolves the <tt>nullablity</tt> of a field to a concrete type, which
--   is returned via the <a>FieldNullability</a> type. You can pattern
--   match on this type to then extract the either <a>Nullable</a> or
--   <a>NotNull</a> not field for cases where you may require different
--   logic based on the nullability of a field.
fieldNullability :: FieldDefinition nullability a -> FieldNullability a

-- | A list a table constraints that will be included on any table that
--   uses this field definition.
fieldTableConstraints :: FieldDefinition nullability a -> TableConstraints

-- | Adds the given table constraints to the field definition. These
--   constraints will then be included on any table where the field is
--   used. The constraints are passed a functions that will take the name
--   of the field definition an construct the constraints. This allows the
--   <tt>ConstraintDefinition</tt>s to use the correct name of the field in
--   the case where <tt>setFieldName</tt> is used after constraints are
--   added.
--   
--   Note: If multiple constraints are added with the same
--   <tt>ConstraintMigrationKey</tt>, only the last one that is added will
--   be part of the <tt>TableDefinition</tt>. Any previously added
--   constraint with the same key is replaced by the new one.
addFieldTableConstraints :: [FieldName -> ConstraintDefinition] -> FieldDefinition nullability a -> FieldDefinition nullability a

-- | Adds a <tt>FOREIGN KEY</tt> constraint to the <a>FieldDefinition</a>
--   (using <a>addFieldTableConstraints</a>). This constraint will be
--   included on any table that uses the field definition.
addForeignKeyConstraint :: TableIdentifier -> FieldName -> FieldDefinition nullability a -> FieldDefinition nullability a

-- | Adds a <tt>FOREIGN KEY</tt> constraint to the <a>FieldDefinition</a>.
--   This constraint will be included on any table that uses the field
--   definition.
addForeignKeyConstraintWithOptions :: TableIdentifier -> FieldName -> ForeignKeyOptions -> FieldDefinition nullability a -> FieldDefinition nullability a

-- | Adds a <tt>UNIQUE</tt> constraint to the <a>FieldDefinition</a>. This
--   constraint will be included on any table that uses the field
--   definition.
addUniqueConstraint :: FieldDefinition nullability a -> FieldDefinition nullability a

-- | Checks that the value in a field equals a particular value.
fieldEquals :: FieldDefinition nullability a -> a -> BooleanExpr

-- | Operator alias for <a>fieldEquals</a>
(.==) :: FieldDefinition nullability a -> a -> BooleanExpr
infixl 9 .==

-- | Checks that the value in a field does not equal a particular value.
fieldNotEquals :: FieldDefinition nullability a -> a -> BooleanExpr

-- | Operator alias for <a>fieldNotEquals</a>
(./=) :: FieldDefinition nullability a -> a -> BooleanExpr
infixl 9 ./=

-- | Checks that the value in a field is greater than a particular value.
fieldGreaterThan :: FieldDefinition nullability a -> a -> BooleanExpr

-- | Operator alias for <a>fieldGreaterThan</a>
(.>) :: FieldDefinition nullability a -> a -> BooleanExpr
infixl 9 .>

-- | Checks that the value in a field is less than a particular value.
fieldLessThan :: FieldDefinition nullability a -> a -> BooleanExpr

-- | Operator alias for <a>fieldLessThan</a>
(.<) :: FieldDefinition nullability a -> a -> BooleanExpr
infixl 9 .<

-- | Checks that the value in a field is greater than or equal to a
--   particular value.
fieldGreaterThanOrEqualTo :: FieldDefinition nullability a -> a -> BooleanExpr

-- | Operator alias for <a>fieldGreaterThanOrEqualTo</a>
(.>=) :: FieldDefinition nullability a -> a -> BooleanExpr
infixl 9 .>=

-- | Checks that the value in a field is less than or equal to a particular
--   value.
fieldLessThanOrEqualTo :: FieldDefinition nullability a -> a -> BooleanExpr

-- | Operator alias for <a>fieldLessThanOrEqualTo</a>
(.<=) :: FieldDefinition nullability a -> a -> BooleanExpr
infixl 9 .<=

-- | Checks that the value in a field is null.
fieldIsNull :: FieldDefinition Nullable a -> BooleanExpr

-- | Checks that the value in a field is not null.
fieldIsNotNull :: FieldDefinition Nullable a -> BooleanExpr

-- | Checks that the value in a field matches a like pattern
fieldLike :: FieldDefinition nullability a -> Text -> BooleanExpr

-- | Checks that the value in a field matches a like pattern case
--   insensitively
fieldLikeInsensitive :: FieldDefinition nullability a -> Text -> BooleanExpr

-- | Checks that a field matches a list of values
fieldIn :: FieldDefinition nullability a -> NonEmpty a -> BooleanExpr

-- | Operator alias for <a>fieldIn</a>
(.<-) :: FieldDefinition nullability a -> NonEmpty a -> BooleanExpr
infixl 9 .<-

-- | Checks that a field does not match a list of values
fieldNotIn :: FieldDefinition nullability a -> NonEmpty a -> BooleanExpr

-- | Operator alias for <a>fieldNotIn</a>
(.</-) :: FieldDefinition nullability a -> NonEmpty a -> BooleanExpr
infixl 9 .</-

-- | Checks that a tuple of two fields is in the list of specified tuplies
fieldTupleIn :: FieldDefinition nullabilityA a -> FieldDefinition nullabilityB b -> NonEmpty (a, b) -> BooleanExpr

-- | Checks that a tuple of two fields is not in the list of specified
--   tuplies
fieldTupleNotIn :: FieldDefinition nullabilityA a -> FieldDefinition nullabilityB b -> NonEmpty (a, b) -> BooleanExpr

-- | Constructs a <a>SetClause</a> that will set the column named in the
--   field definition to the given value. The value is be converted to SQL
--   value using <a>fieldValueToSqlValue</a>
setField :: FieldDefinition nullability a -> a -> SetClause

-- | Operator alias for <a>setField</a>
(.:=) :: FieldDefinition nullability a -> a -> SetClause
orderByField :: FieldDefinition nullability value -> OrderByDirection -> OrderByExpr

-- | A <a>FieldNullability</a> is returned by the <a>fieldNullability</a>
--   function, which can be used when a function works on both
--   <a>Nullable</a> and <a>NotNull</a> functions but needs to deal with
--   each type of field separately. It adds wrapper constructors around the
--   <a>FieldDefinition</a> that you can pattern match on to then work with
--   a concrete <a>Nullable</a> or <a>NotNull</a> field.
data FieldNullability a
NullableField :: FieldDefinition Nullable a -> FieldNullability a
NotNullField :: FieldDefinition NotNull a -> FieldNullability a

-- | Mashalls a Haskell value to be stored in the field to its
--   <tt>SqlValue</tt> representation and packages the resul as a
--   <a>ValueExression</a> so that it can be easily used with other
--   <tt>Expr</tt> functions.
fieldValueToExpression :: FieldDefinition nullability a -> a -> ValueExpression

-- | Mashalls a Haskell value to be stored in the field to its
--   <tt>SqlValue</tt> representation.
fieldValueToSqlValue :: FieldDefinition nullability a -> a -> SqlValue

-- | Marshalls a <tt>SqlValue</tt> from the database into the Haskell value
--   that represents it. This may fail, in which case a <a>Left</a> is
--   returned with an error message.
fieldValueFromSqlValue :: FieldDefinition nullability a -> SqlValue -> Either String a

-- | Constructs the <a>ColumnName</a> for a field for use in SQL
--   expressions from the <tt>Expr</tt> module.
fieldColumnName :: FieldDefinition nullability a -> ColumnName

-- | Constructs the 'Expr.ValueExpression for a field for use in SQL
--   expressions from the <tt>Expr</tt> module.
fieldColumnReference :: FieldDefinition nullability a -> ValueExpression

-- | Constructions the equivalant <a>FieldDefinition</a> as a SQL
--   expression, generally for use in DDL for creating column in a table.
fieldColumnDefinition :: FieldDefinition nullability a -> ColumnDefinition

-- | A simple type to represent the name of a field.
data FieldName

-- | Constructs a <a>FieldName</a> from a <a>String</a>
stringToFieldName :: String -> FieldName

-- | Converts a <a>FieldName</a> back to a <a>String</a>
fieldNameToString :: FieldName -> String

-- | Convert a field name to an <a>ColumnName</a> for usage in SQL
--   expressions. The field name will be properly quoted and escaped.
fieldNameToColumnName :: FieldName -> ColumnName

-- | Converts a <a>FieldName</a> back to a <a>ByteString</a>
fieldNameToByteString :: FieldName -> ByteString

-- | Constructs a <a>FieldName</a> from a <a>ByteString</a>
byteStringToFieldName :: ByteString -> FieldName

-- | <a>NotNull</a> is a values-less type used to track that a
--   <a>FieldDefinition</a> represents a field that is marked not-null in
--   the database schema. See the <tt>Nullability</tt> type for the
--   value-level representation of field nullability.
data NotNull

-- | <a>Nullable</a> is a values-less type used to track that a
--   <a>FieldDefinition</a> represents a field that is marked nullable in
--   the database schema. See the <tt>Nullability</tt> type for the
--   value-level representation of field nullability.
data Nullable

-- | Applies a <a>SqlType</a> conversion to a <a>FieldDefinition</a>. You
--   can use this function the create <a>FieldDefinition</a>s for based on
--   the primitive ones provided, but with more specific Haskell types.
--   
--   See <a>convertSqlType</a> and <a>tryConvertSqlType</a> for functions
--   to create the conversion needed as the first argument to
--   <a>convertField</a>.
convertField :: (SqlType a -> SqlType b) -> FieldDefinition nullability a -> FieldDefinition nullability b

-- | A specialization of <a>convertField</a> that can be used with types
--   that implement <a>Coercible</a>. This is particularly useful for
--   newtype wrappers around primitive types.
coerceField :: (Coercible a b, Coercible b a) => FieldDefinition nullability a -> FieldDefinition nullability b

-- | Makes a <a>NotNull</a> field <a>Nullable</a> by wrapping the Haskell
--   type of the field in <a>Maybe</a>. The field will be marked as
--   <tt>NULL</tt> in the database schema and the value <a>Nothing</a> will
--   be used to represent <tt>NULL</tt> values when converting to and from
--   sql.
nullableField :: FieldDefinition NotNull a -> FieldDefinition Nullable (Maybe a)

-- | Adds a <a>Maybe</a> wrapper to a field that is already nullable. (If
--   your field is <a>NotNull</a>, you wanted <a>nullableField</a> instead
--   of this function). Note that fields created using this function have
--   asymetric encoding and decoding of <tt>NULL</tt> values. Because the
--   provided field is <a>Nullable</a>, <tt>NULL</tt> values decode from
--   the database already have a representation in the <tt>a</tt> type, so
--   <tt>NULL</tt> will be decoded as 'Just <a>of type a for NULL</a>'.
--   This means if you insert a <a>Nothing</a> value using the field, it
--   will be read back as <a>Just</a> value. This is useful for building
--   high level combinators that might need to make fields <a>Nullable</a>
--   but need the value to be decoded in its underlying type when reading
--   back (e.g. <tt>maybeMapper</tt> from <tt>SqlMarshaller</tt>).
asymmetricNullableField :: FieldDefinition Nullable a -> FieldDefinition Nullable (Maybe a)

-- | Sets a default value for the field. The default value will be added as
--   part of the column definition in the database. Because the default
--   value is ultimately provided by the database this can be used to add a
--   not-null column to safely to an existing table as long as a reasonable
--   default value is available to use.
setDefaultValue :: DefaultValue a -> FieldDefinition nullability a -> FieldDefinition nullability a

-- | Removes any default value that may have been set on a field via
--   <tt>setDefaultValue</tt>.
removeDefaultValue :: FieldDefinition nullability a -> FieldDefinition nullability a

-- | Adds a prefix, followed by an underscore, to a field's name.
prefixField :: String -> FieldDefinition nullability a -> FieldDefinition nullability a

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Int32</a>
--   values as the PostgreSQL <a>INT</a> type.
integerField :: String -> FieldDefinition NotNull Int32

-- | Builds a <a>FieldDefinition</a> that stores an <a>Int32</a> value as
--   the <a>SERIAL</a> type. This can be used to create auto-incrementing
--   columns.
serialField :: String -> FieldDefinition NotNull Int32

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Int16</a>
--   values as the PostgreSQL <a>SMALLINT</a> type.
smallIntegerField :: String -> FieldDefinition NotNull Int16

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Int64</a>
--   values as the PostgreSQL <a>BIGINT</a> type.
bigIntegerField :: String -> FieldDefinition NotNull Int64

-- | Builds a <a>FieldDefinition</a> that stores an <a>Int64</a> value as
--   the <a>BIGSERIAL</a> type. This can be used to create
--   auto-incrementing columns.
bigSerialField :: String -> FieldDefinition NotNull Int64

-- | Builds a <a>FieldDefinition</a> that stores a <a>Double</a> value as
--   the "DOUBLE PRECISION" type. Note: PostgreSQL's "DOUBLE PRECISION"
--   type only allows for up to 15 digits of precision, so some rounding
--   may occur when values are stored in the database.
doubleField :: String -> FieldDefinition NotNull Double

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Bool</a> values
--   as the PostgreSQL <a>BOOLEAN</a> type.
booleanField :: String -> FieldDefinition NotNull Bool

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Text</a> values
--   as the PostgreSQL <a>TEXT</a> type. Note that this PostgreSQL has no
--   particular limit on the length of text stored.
unboundedTextField :: String -> FieldDefinition NotNull Text

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Text</a> values
--   as the PostgreSQL <a>VARCHAR</a> type. Attempting to store a value
--   beyond the length specified will cause an error.
boundedTextField :: String -> Int32 -> FieldDefinition NotNull Text

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Text</a> values
--   as the PostgreSQL <a>CHAR</a> type. Attempting to store a value beyond
--   the length specified will cause an error. Storing a value that is not
--   the full length of the field will result in padding by the database.
fixedTextField :: String -> Int32 -> FieldDefinition NotNull Text

-- | Builds a <tt>FieldDefinition</tt> that stores PostgreSQL text search
--   vector values. The values are represented as Haskell <a>Text</a>
--   values, but are interpreted as text search vector values by PostgreSQL
--   when passed to it.
--   
--   See
--   <a>https://www.postgresql.org/docs/current/datatype-textsearch.html</a>
--   for information about how PostgreSQL creates <tt>tsvector</tt> values
--   from strings.
textSearchVectorField :: String -> FieldDefinition NotNull Text

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Day</a> values
--   as the PostgreSQL <a>DATE</a> type.
dateField :: String -> FieldDefinition NotNull Day

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>UTCTime</a>
--   values as the PostgreSQL "TIMESTAMP with time zone" type.
utcTimestampField :: String -> FieldDefinition NotNull UTCTime

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>UTCTime</a>
--   values as the PostgreSQL "TIMESTAMP without time zone" type.
localTimestampField :: String -> FieldDefinition NotNull LocalTime

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>UUID</a> values
--   as the PostgreSQL <a>UUID</a> type.
uuidField :: String -> FieldDefinition NotNull UUID

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Text</a> values
--   as the PostgreSQL <a>JSONB</a> type.
jsonbField :: String -> FieldDefinition NotNull Text

-- | Builds a <a>FieldDefinition</a> for will use the given
--   <tt>SqlType</tt> to determine the database representation of the
--   field. If you have created a custom <tt>SqlType</tt>, you can use this
--   function to construct a helper like the other functions in this module
--   for creating <a>FieldDefinition</a>s for your custom type.
fieldOfType :: SqlType a -> String -> FieldDefinition NotNull a

-- | Constructs a field-based <a>BooleanExpr</a> using a function that
--   builds a <a>BooleanExpr</a>
whereColumnComparison :: (ValueExpression -> ValueExpression -> BooleanExpr) -> FieldDefinition nullability a -> a -> BooleanExpr


module Orville.PostgreSQL.Schema.PrimaryKey

-- | A Haskell description of the <a>FieldDefinition</a>s that make up the
--   primary key of a SQL table. This type supports composite primary keys
--   as well as singular ones.
data PrimaryKey key

-- | <a>primaryKeyDescription</a> builds a user-readable representation of
--   the primary key for use in error messages and such. It is a
--   comma-delimited list of the names of the fields that make up the
--   primary key.
primaryKeyDescription :: PrimaryKey key -> String

-- | Retrieves the names of the fields that are part of the primary key.
primaryKeyFieldNames :: PrimaryKey key -> NonEmpty FieldName

-- | <a>primaryKeyToSql</a> converts a Haskell value for a primary key into
--   the (possibly multiple) sql values that represent the primary key in
--   the database.
primaryKeyToSql :: PrimaryKey key -> key -> NonEmpty SqlValue

-- | <a>primaryKey</a> constructs a single-field primary key from the
--   <a>FieldDefinition</a> that corresponds to the primary key's column.
--   This is generally used while building a <tt>TableDefinition</tt>.
primaryKey :: FieldDefinition NotNull key -> PrimaryKey key

-- | A <a>PrimaryKeyPart</a> describes one field of a composite primary
--   key. Values are built using <a>primaryKeyPart</a> and then used with
--   <a>compositePrimaryKey</a> to build a <a>PrimaryKey</a>
data PrimaryKeyPart key

-- | <a>compositePrimaryKey</a> constructs a multi-field primary key from
--   the given parts, each of which corresponds to one field in the primary
--   key. You should use this while building a <tt>TableDefinition</tt> for
--   a table that you want to have a multi-column primary key. See
--   <a>primaryKeyPart</a> for how to build the parts to be passed as
--   parameters. Note: there is no special significance to the first
--   argument other than requiring that there is at least one field in the
--   primary key.
compositePrimaryKey :: PrimaryKeyPart key -> [PrimaryKeyPart key] -> PrimaryKey key

-- | <a>primaryKeyPart</a> constructs a building block for a composite
--   primary key based a <a>FieldDefinition</a> and an accessor function to
--   extract the value for that field from the Haskell <tt>key</tt> type
--   that represents the overall composite key. <a>PrimaryKeyPart</a>
--   values built using this function are usually then passed in a list to
--   <a>compositePrimaryKey</a> to build a <a>PrimaryKey</a>.
primaryKeyPart :: (key -> part) -> FieldDefinition NotNull part -> PrimaryKeyPart key

-- | <a>mapPrimaryKeyParts</a> provides a way to access the innards of a
--   <a>PrimaryKey</a> definition to extract information. The given
--   function will be called on each part of the primary key in order and
--   the list of results is returned. Note that single-field and
--   multi-field primary keys are treated the same by this function, with
--   the single-field case simply behaving as composite key with just one
--   part.
mapPrimaryKeyParts :: (forall part. (key -> part) -> FieldDefinition NotNull part -> a) -> PrimaryKey key -> NonEmpty a

-- | Builds a <a>PrimaryKeyExpr</a> that is suitable to be used when
--   creating a table to define the primary key on the table.
mkPrimaryKeyExpr :: PrimaryKey key -> PrimaryKeyExpr

-- | <a>primaryKeyEquals</a> builds a <a>BooleanExpr</a> that will match
--   the row where the primary key is equal to the given value. For
--   single-field primary keys this is equivalent to <a>fieldEquals</a>,
--   but <a>primaryKeyEquals</a> also handles composite primary keys.
primaryKeyEquals :: PrimaryKey key -> key -> BooleanExpr

-- | <a>primaryKeyIn</a> builds a <a>BooleanExpr</a> that will match rows
--   where the primary key is contained the given list. For single-field
--   primary keys this is equivalent to <a>fieldIn</a>, but
--   <a>primaryKeyIn</a> also handles composite primary keys.
primaryKeyIn :: PrimaryKey key -> NonEmpty key -> BooleanExpr


module Orville.PostgreSQL.Marshall.SyntheticField

-- | A <a>SyntheticField</a> can be used to evaluate a SQL expression based
--   on the columns of a table when records are selected from the database.
--   Synthetic fields are inherently read-only.
data SyntheticField a

-- | Returns the SQL expression that should be in with select statements to
--   calculated the sythetic field.
syntheticFieldExpression :: SyntheticField a -> ValueExpression

-- | Returns the alias that should be used in select statements to name the
--   the synthetic field.
syntheticFieldAlias :: SyntheticField a -> FieldName

-- | Decodes a calculated value selected from the database to its expected
--   Haskell type. Returns a <a>Left</a> with an error message if the
--   decoding fails.
syntheticFieldValueFromSqlValue :: SyntheticField a -> SqlValue -> Either String a

-- | Constructs a <a>SyntheticField</a> that will select a SQL expression
--   using the given alias.
syntheticField :: ValueExpression -> String -> (SqlValue -> Either String a) -> SyntheticField a

-- | Modifies a <a>SyntheticField</a> to allow it to decode <tt>NULL</tt>
--   values.
nullableSyntheticField :: SyntheticField a -> SyntheticField (Maybe a)

-- | Adds a prefix, followed by an underscore, to the alias used to name
--   the synthetic field.
prefixSyntheticField :: String -> SyntheticField a -> SyntheticField a


-- | This module provides functions for constructing a mapping between
--   Haskell data types and SQL column schemas. The <a>SqlMarshaller</a>
--   that represents this mapping can be used to serialize Haskell values
--   both to and from SQL column sets. In most cases you construct a
--   <a>SqlMarshaller</a> as part of building you <a>TableDefinition</a>
--   and Orville handles the rest. In other cases you might use a
--   <a>SqlMarshaller</a> with a lower-level Orville function. For
--   instance, to decode the result set of a custom SQL query.
module Orville.PostgreSQL.Marshall.SqlMarshaller

-- | <a>SqlMarshaller</a> is how we group the lowest level translation of
--   single fields into a higher level marshalling of full sql records into
--   Haskell records. This is a flexible abstraction that allows us to
--   ultimately model SQL tables and work with them as potentially nested
--   Haskell records. We can then "marshall" the data as we want to model
--   it in sql and Haskell.
data SqlMarshaller a b

-- | An <a>AnnotatedSqlMarshaller</a> is a <a>SqlMarshaller</a> that
--   contains extra annotations cannot necessarily be determined from the
--   data in the marshaller itself. In particular, it includes the names of
--   fields that be used to identify a row in the database when an error is
--   encoutered during decoding.
--   
--   Normally you will not need to interact with this type directly -- the
--   <tt>TableDefinition</tt> type creates it for you using the information
--   it has about the primary key of table to identify rows in decoding
--   errors. If you are executing custom queries directly, you may need to
--   annotate a raw <a>SqlMarshaller</a> yourself so that rows can be
--   identified. See <a>annotateSqlMarshaller</a> and
--   <a>annotateSqlMarshallerEmptyAnnotation</a>.
data AnnotatedSqlMarshaller writeEntity readEntity

-- | Creates an <a>AnnotatedSqlMarshaller</a> that will use the given
--   column names to identify rows in error messages when decoding fails.
--   Any column names in the list that are not present in the result set
--   will simply be omitted from the error message.
annotateSqlMarshaller :: [FieldName] -> SqlMarshaller writeEntity readEntity -> AnnotatedSqlMarshaller writeEntity readEntity

-- | Creates an <a>AnnotatedSqlMarshaller</a> that will identify rows in
--   decoding errors by any columns. This is the equivalent of
--   <tt>annotateSqlMarshaller []</tt>.
annotateSqlMarshallerEmptyAnnotation :: SqlMarshaller writeEntity readEntity -> AnnotatedSqlMarshaller writeEntity readEntity
unannotatedSqlMarshaller :: AnnotatedSqlMarshaller writeEntity readEntity -> SqlMarshaller writeEntity readEntity

-- | Applies the provided function to a <a>SqlMarshaller</a> that has been
--   annotated, preserving the annotations.
mapSqlMarshaller :: (SqlMarshaller readEntityA writeEntityA -> SqlMarshaller readEntityB writeEntityB) -> AnnotatedSqlMarshaller readEntityA writeEntityA -> AnnotatedSqlMarshaller readEntityB writeEntityB

-- | Represents a primitive entry in a <a>SqlMarshaller</a>. This type is
--   used with <a>foldMarshallerFields</a> to provided the entry from the
--   mashaller to the folding function to be incorporate in the result of
--   the fold.
data MarshallerField writeEntity
[Natural] :: FieldDefinition nullability a -> Maybe (writeEntity -> a) -> MarshallerField writeEntity
[Synthetic] :: SyntheticField a -> MarshallerField writeEntity

-- | Decodes all the rows found in a execution result at once. The first
--   row that fails to decode will return the <tt>MarshallErrorDetails</tt>
--   that results, otherwise all decoded rows will be returned.
--   
--   Note that this function loads are decoded rows into memory at once, so
--   it should only be used with result sets that you know will fit into
--   memory.
marshallResultFromSql :: ExecutionResult result => ErrorDetailLevel -> AnnotatedSqlMarshaller writeEntity readEntity -> result -> IO (Either MarshallError [readEntity])

-- | Decodes all the rows found in a execution result at once. The first
--   row that fails to decode will return the <tt>MarshallErrorDetails</tt>
--   that results, otherwise all decoded rows will be returned. If an error
--   occurs while decoding a row, the <a>RowIdentityExtractor</a> will be
--   used to extract values to identify the row in the error details.
--   
--   Note that this function loads are decoded rows into memory at once, so
--   it should only be used with result sets that you know will fit into
--   memory.
marshallResultFromSqlUsingRowIdExtractor :: ExecutionResult result => ErrorDetailLevel -> RowIdentityExtractor -> SqlMarshaller writeEntity readEntity -> result -> IO (Either MarshallError [readEntity])

-- | A <a>RowIdentityExtractor</a> is used to retrieve identifying
--   information for a row when a <tt>MarshallError</tt> occurs reading it
--   from the database.
--   
--   You should only need to worry about this type if you're using
--   <a>marshallResultFromSqlUsingRowIdExtractor</a> and need to manually
--   provide it. When possible, it's easier to annotate a
--   <a>SqlMarshaller</a> with the field names you would like rows to be
--   identified by and then use <a>marshallResultFromSql</a> instead.
data RowIdentityExtractor

-- | Constructs a <a>RowIdentityExtractor</a> that will extract values for
--   the given fields from the result set to indentify rows in decoding
--   errors. Any of the named fields that are missing from the result set
--   not be included in the extracted row identity.
mkRowIdentityExtractor :: ExecutionResult result => [FieldName] -> result -> RowIdentityExtractor

-- | Builds a <a>SqlMarshaller</a> that maps a single field of a Haskell
--   entity to a single column in the database. That value to store in the
--   database will be retried from the entity using provided accessor
--   function. This function is intended to be used inside of a stanza of
--   <a>Applicative</a> syntax that will pass values read from the database
--   a constructor function to rebuild the entity containing the field,
--   like so:
--   
--   <pre>
--   data Foo = Foo { bar :: Int32, baz :: Text }
--   
--   fooMarshaller :: SqlMarshaller Foo Foo
--   fooMarshaller =
--     Foo
--       <a>$</a> marshallField bar (integerField "bar")
--       <a>*</a> marshallField baz (unboundedTextField "baz")
--   
--   
--   </pre>
marshallField :: (writeEntity -> fieldValue) -> FieldDefinition nullability fieldValue -> SqlMarshaller writeEntity fieldValue

-- | Builds a <a>SqlMarshaller</a> that will include a SQL expression in
--   select statements to calculate a value the columns of the table being
--   selected from. The columns being used in the calculation do not
--   themselves need to be selected, though they must be present in the
--   table so they can be referenced.
--   
--   <pre>
--   data AgeCheck
--     { atLeast21 :: Bool
--     }
--   
--   fooMarshaller :: SqlMarshaller Void AgeCheck
--   fooMarshaller =
--     AgeCheck
--       <a>*</a> Orville.marshallSyntheticField atLeast21Field
--   
--   atLeast21Field :: SyntheticField Bool
--   atLeast21Field =
--     SyntheticField
--       { syntheticFieldExpression = RawSql.unsafeSqlExpression "age &gt;= 21"
--       , syntheticFieldAlias = Orville.stringToFieldName "over21"
--       , syntheticFieldValueFromSqlValue = SqlValue.toBool
--       }
--   
--   </pre>
marshallSyntheticField :: SyntheticField fieldValue -> SqlMarshaller writeEntity fieldValue

-- | A version of <a>marshallField</a> that uses <a>marshallReadOnly</a> to
--   make a single read only field. You will usually use this in conjuction
--   with a <a>FieldDefinition</a> like <tt>serialField</tt> where the
--   valuue is populated by the database.
marshallReadOnlyField :: FieldDefinition nullability fieldValue -> SqlMarshaller writeEntity fieldValue

-- | Marks a <a>SqlMarshaller</a> as ready only so that it will not attempt
--   to read any values from the <tt>writeEntity</tt>. You should use this
--   if you have a group of fields which are populated by database rather
--   than the application.
marshallReadOnly :: SqlMarshaller a b -> SqlMarshaller c b

-- | Nests a <a>SqlMarshaller</a> inside another, using the given accesser
--   to retrieve value to be marshalled. The resulting marshaller can then
--   be used in the same way as <a>marshallField</a> within the applicative
--   syntax of a larger marshaller.
--   
--   For Example:
--   
--   <pre>
--   data Person =
--     Person
--       { personId :: PersonId
--       , personName :: Name
--       }
--   
--   data Name =
--     Name
--       { firstName :: T.Text
--       , lastName :: T.Text
--       }
--   
--   personMarshaller :: SqlMarshaller Person Person
--   personMarshaller =
--     Person
--       <a>$</a> marshallField personId personIdField
--       <a>*</a> marshallNested personName nameMarshaller
--   
--   nameMarshaller :: SqlMarshaller Name Name
--   nameMarshaller =
--     Name
--       <a>$</a> marshallField firstName firstNameField
--       <a>*</a> marshallField lastName lastNameField
--   
--   </pre>
marshallNested :: (parentEntity -> nestedWriteEntity) -> SqlMarshaller nestedWriteEntity nestedReadEntity -> SqlMarshaller parentEntity nestedReadEntity

-- | Lifts a <a>SqlMarshaller</a> to have both read/write entities be
--   <a>Maybe</a>, and applies a tag to avoid double mapping.
marshallMaybe :: SqlMarshaller a b -> SqlMarshaller (Maybe a) (Maybe b)

-- | Builds a <a>SqlMarshaller</a> that will raise a decoding error when
--   the value produced is a <a>Left</a>.
marshallPartial :: SqlMarshaller a (Either String b) -> SqlMarshaller a b

-- | Adds a prefix, followed by an underscore, to the names of all of the
--   fields and synthetic fields in a <a>SqlMarshaller</a>.
prefixMarshaller :: String -> SqlMarshaller readEntity writeEntity -> SqlMarshaller readEntity writeEntity

-- | Specifies whether read-only fields should be included when using
--   functions such as <a>collectFromField</a> and
--   <tt>marshallerColumnNames</tt>.
data ReadOnlyColumnOption
IncludeReadOnlyColumns :: ReadOnlyColumnOption
ExcludeReadOnlyColumns :: ReadOnlyColumnOption

-- | A fold function that can be used with <a>foldMarshallerFields</a> to
--   collect a value calculated from a <a>FieldDefinition</a> via the given
--   function. The calculated value is added to the list of values being
--   built.
--   
--   Note: Folds executed with <a>collectFromField</a> ignore
--   <a>Synthetic</a> entries in the marshaller. You should only use
--   <a>collectFromField</a> in situations where you only care about the
--   actual columns referenced by the marshaller.
collectFromField :: ReadOnlyColumnOption -> (forall nullability a. FieldDefinition nullability a -> result) -> MarshallerField entity -> [result] -> [result]

-- | Uses the field defintions in the marshaller to construct SQL
--   expressions that will set columns of the field defintions to their
--   corresponding value found in the Haskell <tt>writeEntity</tt> value.
marshallEntityToSetClauses :: SqlMarshaller writeEntity readEntity -> writeEntity -> [SetClause]

-- | <a>foldMarshallerFields</a> allows you to consume the
--   <a>FieldDefinition</a>s that are contained within the
--   <a>SqlMarshaller</a> to process them however is required. This can be
--   used to collect the names of all the fields, encode them to
--   <tt>SqlValue</tt>, etc.
foldMarshallerFields :: SqlMarshaller writeEntity readEntity -> result -> (MarshallerField writeEntity -> result -> result) -> result

-- | Returns a list of <a>DerivedColumn</a> expressions that can be used in
--   a select statement to select values from the database for the
--   <a>SqlMarshaller</a> decode.
marshallerDerivedColumns :: SqlMarshaller writeEntity readEntity -> [DerivedColumn]

-- | Returns the table constraints for all the <a>FieldDefinition</a>s used
--   in the <a>SqlMarshaller</a>.
marshallerTableConstraints :: SqlMarshaller writeEntity readEntity -> TableConstraints

-- | Uses the <a>SqlMarshaller</a> given to build a <a>RowSource</a> that
--   will decode from the given result set. The returned <a>RowSource</a>
--   can then be used to decode rows as desired by the user. Note that the
--   entire result set is held in memory for potential decoding until the
--   <a>RowSource</a> is garbage collected.
mkRowSource :: ExecutionResult result => SqlMarshaller writeEntity readEntity -> result -> IO (RowSource readEntity)

-- | A <a>RowSource</a> can fetch and decode rows from a database result
--   set. Using a <a>RowSource</a> gives random access to the rows in the
--   result set, only attempting to decode them when they are requested by
--   the use via <a>decodeRow</a>.
--   
--   Note that even though the rows are not decoded into Haskell until
--   <a>decodeRow</a> is called, all the rows returned from the query are
--   held in memory on the client waiting to be decoded until the
--   <a>RowSource</a> is garbage collected. As such, you can't use
--   <a>RowSource</a> (alone) to achieve any form of streaming or
--   pagination of rows between the database server and the client.
data RowSource readEntity

-- | Adds a function to the decoding proocess to transform the value
--   returned by a <a>RowSource</a>.
mapRowSource :: (a -> b) -> RowSource a -> RowSource b

-- | Applies a function that will be decoded from the result set to another
--   value decode from the result set.
applyRowSource :: RowSource (a -> b) -> RowSource a -> RowSource b

-- | Creates a <a>RowSource</a> that always returns the value given, rather
--   than attempting to access the result set and decoding anything.
constRowSource :: readEntity -> RowSource readEntity

-- | Creates a <a>RowSource</a> that will always fail to decode by
--   returning the provided error. This can be used in cases where a
--   <a>RowSource</a> must be provided but it is already known at run time
--   that decoding is impossible. For instance, this is used internally
--   when a <a>FieldDefinition</a> references a column that does not exist
--   in the result set.
failRowSource :: MarshallErrorDetails -> RowSource a
instance GHC.Base.Functor Orville.PostgreSQL.Marshall.SqlMarshaller.RowSource
instance GHC.Base.Applicative Orville.PostgreSQL.Marshall.SqlMarshaller.RowSource
instance GHC.Base.Functor (Orville.PostgreSQL.Marshall.SqlMarshaller.SqlMarshaller a)
instance GHC.Base.Applicative (Orville.PostgreSQL.Marshall.SqlMarshaller.SqlMarshaller a)


-- | Low-level functions for executing <a>SqlExpression</a> values
--   directly.
module Orville.PostgreSQL.Execution.Execute

-- | Executes a SQL query and decodes the result set using the provided
--   marshaller. Any SQL Execution callbacks that have been added to the
--   <a>OrvilleState</a> will be called.
--   
--   If the query fails or if any row is unable to be decoded by the
--   marshaller, an exception will be raised.
executeAndDecode :: (MonadOrville m, SqlExpression sql) => QueryType -> sql -> AnnotatedSqlMarshaller writeEntity readEntity -> m [readEntity]

-- | Executes a SQL query and returns the number of rows affected by the
--   query. Any SQL Execution callbacks that have been added to the
--   <a>OrvilleState</a> will be called.
--   
--   This function can only be used for the execution of a SELECT, CREATE
--   TABLE AS, INSERT, UPDATE, DELETE, MOVE, FETCH, or COPY statement, or
--   an EXECUTE of a prepared query that contains an INSERT, UPDATE, or
--   DELETE statement. If the query is anything else an
--   <a>AffectedRowsDecodingError</a> wil be raised after the query is
--   executed when the result is read.
--   
--   If the query fails an exception will be raised.
executeAndReturnAffectedRows :: (MonadOrville m, SqlExpression sql) => QueryType -> sql -> m Int

-- | Executes a SQL query and ignores the result. Any SQL Execution
--   callbacks that have been added to the <a>OrvilleState</a> will be
--   called.
--   
--   If the query fails an exception will be raised.
executeVoid :: (MonadOrville m, SqlExpression sql) => QueryType -> sql -> m ()

-- | Executes a SQL query and decodes the result set using the provided
--   marshaller. Any SQL Execution callbacks that have been added to the
--   <a>OrvilleState</a> will be called.
--   
--   If the query fails or if any row is unable to be decoded by the
--   marshaller, an exception will be raised.
executeAndDecodeIO :: SqlExpression sql => QueryType -> sql -> AnnotatedSqlMarshaller writeEntity readEntity -> OrvilleState -> Connection -> IO [readEntity]

-- | Executes a SQL query and returns the number of rows affected by the
--   query. Any SQL Execution callbacks that have been added to the
--   <a>OrvilleState</a> will be called.
--   
--   This function can only be used for the execution of a SELECT, CREATE
--   TABLE AS, INSERT, UPDATE, DELETE, MOVE, FETCH, or COPY statement, or
--   an EXECUTE of a prepared query that contains an INSERT, UPDATE, or
--   DELETE statement. If the query is anything else an
--   <a>AffectedRowsDecodingError</a> wil be raised after the query is
--   executed when the result is read.
--   
--   If the query fails an exception will be raised.
executeAndReturnAffectedRowsIO :: SqlExpression sql => QueryType -> sql -> OrvilleState -> Connection -> IO Int

-- | Executes a SQL query and ignores the result. Any SQL Execution
--   callbacks that have been added to the <a>OrvilleState</a> will be
--   called.
--   
--   If the query fails an exception will be raised.
executeVoidIO :: SqlExpression sql => QueryType -> sql -> OrvilleState -> Connection -> IO ()

-- | Thrown by <a>executeAndReturnAffectedRows</a> and
--   <a>executeAndReturnAffectedRowsIO</a> if the number of affected rows
--   cannot be successfully read from the LibPQ command result.
data AffectedRowsDecodingError
instance GHC.Show.Show Orville.PostgreSQL.Execution.Execute.AffectedRowsDecodingError
instance GHC.Exception.Type.Exception Orville.PostgreSQL.Execution.Execute.AffectedRowsDecodingError


-- | This module provides the functionality to work with SQL transactions,
--   notably to ensure some Haskell action occurs within a database
--   transaction.
module Orville.PostgreSQL.Execution.Transaction

-- | Performs an action in an Orville monad within a database transaction.
--   The transaction in begun before the action is called. If the action
--   completes without raising an exception, the transaction will be
--   committed. If the action raises an exception, the transaction will
--   rollback.
--   
--   This function in safe to call from within another transaction. When
--   called this way the transaction will establish a new savepoint at the
--   beginning of the nested transaction and either release the savepoint
--   or rollback to it as appropriate.
--   
--   Note: Exceptions are handled using the implementations of <a>catch</a>
--   and <a>mask</a> provided by the <tt>MonadOrvilleControl</tt> instance
--   for <tt>m</tt>.
withTransaction :: MonadOrville m => m a -> m a


-- | You can import <a>Orville.PostgreSQL.Marshall</a> to get access to all
--   the functions related to marshalling Haskell values to and from their
--   SQL representations. This includes a number of lowel-level items not
--   exported by <a>Orville.PostgreSQL</a> that give you more control (and
--   therefore responsibility) over how the marshalling is performed.
module Orville.PostgreSQL.Marshall


module Orville.PostgreSQL.Schema.TableDefinition

-- | Contains the definition of a SQL table for Orville to use for
--   generating queries and marshalling Haskell values to and from the
--   database.
--   
--   <ul>
--   <li><tt>key</tt> is a Haskell type used to indicate whether the table
--   has a primary key and what the type of the key is if so. See
--   <a>HasKey</a> and <a>NoKey</a> for values to be used in this
--   parameter.</li>
--   <li><tt>writeEntity</tt> is the Haskell type for values that Orville
--   will write to the database for you (i.e. both inserts and
--   updates)</li>
--   <li><tt>readEntity</tt> is the Haskell type for values that Orville
--   will decode from the result set when entities are queried from this
--   table.</li>
--   </ul>
data TableDefinition key writeEntity readEntity

-- | <a>HasKey</a> is a type with no constructors. It is used only at the
--   type level as the <tt>key</tt> parameter to the <a>TableDefinition</a>
--   type to indicate that the the table has a primary key and what the
--   Haskell type of the primary key is.
data HasKey key

-- | <a>NoKey</a> is a type with no constructors. It is used only at the
--   type level as the <tt>key</tt> parameter to the <a>TableDefinition</a>
--   type to indicate that the the table does not have a primary key.
data NoKey

-- | Constructs a new <a>TableDefinition</a> with the basic fields required
--   for operation. For convenience, this function accepts a
--   <a>PrimaryKey</a> even though this is not required for all Orville
--   operations to work. If you need to create a table without any primary
--   key, see <a>mkTableDefinitionWithoutKey</a>.
mkTableDefinition :: String -> PrimaryKey key -> SqlMarshaller writeEntity readEntity -> TableDefinition (HasKey key) writeEntity readEntity

-- | Constructs a new <a>TableDefinition</a> with the minimal fields
--   required for operation. Note: tables created via this function will
--   not have a primary key. Certain Orville functions required a primary
--   key. Attempting to call functions requiring a primary key will fail to
--   compile when using a table that has no key.
mkTableDefinitionWithoutKey :: String -> SqlMarshaller writeEntity readEntity -> TableDefinition NoKey writeEntity readEntity

-- | Annotates a <a>TableDefinition</a> with a direction to drop columns if
--   they are found in the database. Orville does not drop columns during
--   auto migration unless they are explicitly requested to be dropped via
--   <a>dropColumns</a>.
--   
--   If you remove a reference to a column from the table's
--   <a>SqlMarshaller</a> without adding the column's name to
--   <a>dropColumns</a>, Orville will operate as if the column does not
--   exist without actually dropping the column. This is often useful if
--   you're not sure you want to lose the data in the column, or if you
--   have zero down-time deployments, which requires the column not be
--   referenced by deployed code before it can be dropped.
dropColumns :: [String] -> TableDefinition key writeEntity readEntity -> TableDefinition key writeEntity readEntity

-- | Returns the set of columns that have be marked be dropped by
--   <a>dropColumns</a>
columnsToDrop :: TableDefinition key writeEntity readEntity -> Set String

-- | Returns the table's <a>TableIdentifier</a>
tableIdentifier :: TableDefinition key writeEntity readEntity -> TableIdentifier

-- | Returns the table's name as an expression that can be used to build
--   SQL statements. If the table has a schema name set, the name will be
--   qualified with it.
tableName :: TableDefinition key writeEntity readEntity -> Qualified TableName

-- | Sets the table's schema to the name in the given string, which will be
--   treated as a SQL identifier. If a table has a schema name set, it will
--   be included as a qualified on the table name for all queries involving
--   the table.
setTableSchema :: String -> TableDefinition key writeEntity readEntity -> TableDefinition key writeEntity readEntity

-- | Retrieves all the table constraints that have been added to the table
--   either via <a>addTableConstraints</a> or that are found on
--   <tt>FieldDefinition</tt>s included with this table's
--   <a>SqlMarshaller</a>.
tableConstraints :: TableDefinition key writeEntity readEntity -> TableConstraints

-- | Adds the given table constraints to the table definition. It's also
--   possible to add constraints that apply to only one column adding them
--   to the <tt>FieldDefinition</tt>s that are included in the table's
--   <a>SqlMarshaller</a>.
--   
--   If you wish to constrain multiple columns with a single constraint
--   (e.g. a multi-column unique constraint), you must use
--   <a>addTableConstraints</a>.
--   
--   Note: If multiple constraints are added with the same
--   <tt>ConstraintMigrationKey</tt>, only the last one that is added will
--   be part of the <a>TableDefinition</a>. Any previously added constraint
--   with the same key is replaced by the new one.
addTableConstraints :: [ConstraintDefinition] -> TableDefinition key writeEntity readEntity -> TableDefinition key writeEntity readEntity

-- | Retrieves all the table indexes that have been added to the table via
--   <a>addTableIndexes</a>.
tableIndexes :: TableDefinition key writeEntity readEntity -> Map IndexMigrationKey IndexDefinition

-- | Adds the given table indexes to the table definition.
--   
--   Note: If multiple indexes are added with the same
--   <a>IndexMigrationKey</a>, only the last one that is added will be part
--   of the <a>TableDefinition</a>. Any previously added index with the
--   same key is replaced by the new one.
addTableIndexes :: [IndexDefinition] -> TableDefinition key writeEntity readEntity -> TableDefinition key writeEntity readEntity

-- | Returns the primary key for the table, as defined at construction via
--   <a>mkTableDefinition</a>.
tablePrimaryKey :: TableDefinition (HasKey key) writeEntity readEntity -> PrimaryKey key

-- | Returns the marshaller for the table, as defined at construction via
--   <a>mkTableDefinition</a>.
tableMarshaller :: TableDefinition key writeEntity readEntity -> AnnotatedSqlMarshaller writeEntity readEntity

-- | Applies the provided function to the underlying <a>SqlMarshaller</a>
--   of the <a>TableDefinition</a>
mapTableMarshaller :: (SqlMarshaller readEntityA writeEntityA -> SqlMarshaller readEntityB writeEntityB) -> TableDefinition key readEntityA writeEntityA -> TableDefinition key readEntityB writeEntityB

-- | Builds an <a>InsertExpr</a> that will insert the given entities into
--   the SQL table when it is executed. A <tt>RETURNING</tt> clause with
--   either be included to return the insert rows or not, depending on the
--   <tt>ReturnOption</tt> given.
mkInsertExpr :: ReturningOption returningClause -> TableDefinition key writeEntity readEntity -> NonEmpty writeEntity -> InsertExpr

-- | Builds a <a>CreateTableExpr</a> that will create a SQL table matching
--   the given <a>TableDefinition</a> when it is executed.
mkCreateTableExpr :: TableDefinition key writeEntity readEntity -> CreateTableExpr

-- | Builds the <a>ColumnDefinitions</a> for all the fields described by
--   the table definition's <a>SqlMarshaller</a>.
mkTableColumnDefinitions :: TableDefinition key writeEntity readEntity -> [ColumnDefinition]

-- | Builds the <a>PrimaryKeyExpr</a> for this table, or none of this table
--   has no primary key.
mkTablePrimaryKeyExpr :: TableDefinition key writeEntity readEntity -> Maybe PrimaryKeyExpr

-- | Builds an <a>InsertColumnList</a> that specifies the columns for an
--   insert statement in the order that they appear in the given
--   <a>SqlMarshaller</a>.
--   
--   In normal circumstances you will want to build the complete insert
--   statement via <a>mkInsertExpr</a>, but this is exported in case you
--   are a composing SQL yourself and need the column list of an insert as
--   a fragment.
mkInsertColumnList :: SqlMarshaller writeEntity readEntity -> InsertColumnList

-- | Builds an <a>InsertSource</a> that will insert the given entities with
--   their values specified in the order that the fields appear in the
--   given <a>SqlMarshaller</a> (which matches the order of column names
--   produced by <tt>mkInsertColumnColumnsList</tt>).
--   
--   In normal circumstances you will want to build the complete insert
--   statement via <a>mkInsertExpr</a>, but this is exported in case you
--   are a composing SQL yourself and need the column list of an insert as
--   a fragment.
mkInsertSource :: SqlMarshaller writeEntity readEntity -> NonEmpty writeEntity -> InsertSource

-- | When <a>WithReturning</a> is given, builds a <a>ReturningExpr</a> that
--   will return all the columns in the given table definition.
mkTableReturningClause :: ReturningOption returningClause -> TableDefinition key writeEntity readEntty -> Maybe ReturningExpr


module Orville.PostgreSQL.Schema.IndexDefinition

-- | Defines an index that can be added to a <a>TableDefinition</a>. Use
--   one of the constructor functions below (such as <a>uniqueIndex</a>) to
--   construct the index definition you wish to have and then use
--   <a>addTableIndexes</a>. to add them to your table definition. Orville
--   will then add the index next time you run auto-migrations.
data IndexDefinition

-- | Gets the <a>IndexCreationStrategy</a> strategy to be used when
--   creating the index described by the <a>IndexDefinition</a>. By default
--   all indexes are created using the <a>Transactional</a> strategy.
indexCreationStrategy :: IndexDefinition -> IndexCreationStrategy

-- | Sets the <a>IndexCreationStrategy</a> strategy to be used when
--   creating the index described by the <a>IndexDefinition</a>. By default
--   all indexes are created using the <a>Transactional</a> strategy, but
--   some tables are too large for for this to be feasible. See the
--   <a>Asynchronous</a> creation strategy for how to work around this.
setIndexCreationStrategy :: IndexCreationStrategy -> IndexDefinition -> IndexDefinition

-- | Constructs an <a>IndexDefinition</a> for a <tt>UNIQUE</tt> index on
--   the given columns.
uniqueIndex :: NonEmpty FieldName -> IndexDefinition

-- | Constructs an <a>IndexDefinition</a> for a <tt>UNIQUE</tt> index on
--   the given columns.
uniqueNamedIndex :: String -> IndexBodyExpr -> IndexDefinition

-- | Constructs an <a>IndexDefinition</a> for a non-unique index on the
--   given columns
nonUniqueIndex :: NonEmpty FieldName -> IndexDefinition

-- | Constructs an <a>IndexDefinition</a> for a non-unique index with given
--   SQL and index name
nonUniqueNamedIndex :: String -> IndexBodyExpr -> IndexDefinition

-- | Constructs an <a>IndexDefinition</a> for an index on the given columns
--   with the given uniquness.
mkIndexDefinition :: IndexUniqueness -> NonEmpty FieldName -> IndexDefinition

-- | Constructs an <a>IndexDefinition</a> for an index with the given
--   uniqueness, given name, and given SQL.
mkNamedIndexDefinition :: IndexUniqueness -> String -> IndexBodyExpr -> IndexDefinition

-- | Type to represent if an index should be unique.
data IndexUniqueness
UniqueIndex :: IndexUniqueness
NonUniqueIndex :: IndexUniqueness

-- | Gets the SQL expression that will be used to add the index to the
--   specified table.
indexCreateExpr :: IndexDefinition -> Qualified TableName -> CreateIndexExpr

-- | Defines how an <a>IndexDefinition</a> will be execute to add an index
--   to a table. By default all indexes a created via the
--   <a>Transactional</a>
data IndexCreationStrategy

-- | The default strategy. The index will be added as part of the a
--   database transaction along with all the other DDL being executed to
--   migrate the database schema. If any migration should fail the index
--   creation will be rolled back as part of the transaction. This is how
--   schema migrations work in general in Orville.
Transactional :: IndexCreationStrategy

-- | Creates the index asynchronously using the <tt>CONCURRENTLY</tt>
--   keyword in PostgreSQL. Index creation will return immediately and the
--   index will be created in the background by PostgreSQL. Index creation
--   may fail when using the <a>Asynchronous</a> strategy. Orville has no
--   special provision to detect or recover from this failure currently.
--   You should manually check that index creation has succeeded. If
--   necessary, you can manually drop the index to cause Orville to
--   recreate it the next time migrations are run. This is useful when you
--   need to add an index to a very large table because this can lock the
--   table for a long time and cause an application to fail health checks
--   at startup if migrations do not finish quickly enough. You should
--   familiarize youself with how concurrent index creation works in
--   PostgreSQL before using this. See
--   <a>https://www.postgresql.org/docs/current/sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY</a>
Asynchronous :: IndexCreationStrategy


-- | You can import <a>Orville.PostgreSQL.Schema</a> to get access to all
--   the functions related to representing a SQL schema. This includes a
--   number of lowel-level items not exported by <a>Orville.PostgreSQL</a>
--   that give you more control (and therefore responsibility) over the
--   definition of the schema.
module Orville.PostgreSQL.Schema


-- | Functions for working with executable <tt>UPDATE</tt> statements. The
--   <a>Update</a> type is a value that can be passed around and executed
--   later. The <a>Update</a> is directly associated with the presence of a
--   returning clause and how to decode any rows returned by that clause.
--   This means it can be safely executed via <a>executeUpdate</a> or
--   <a>executeUpdateReturnEntities</a> as appropriate. It is a lower-level
--   API than the entity update functions in
--   <a>Orville.PostgreSQL.Execution.EntityOperations</a>, but not as
--   primitive as <a>Orville.PostgreSQL.Expr.Update</a>.
module Orville.PostgreSQL.Execution.Update

-- | Represents an <tt>UPDATE</tt> statement that can be executed against a
--   database. An <a>Update</a> has a <tt>SqlMarshaller</tt> bound to it
--   that, when the update returns data from the database, will be used to
--   decode the database result set when it is executed.
data Update readEntity returningClause

-- | Extracts the query that will be run when the update is executed.
--   Normally you don't want to extract the query and run it yourself, but
--   this function is useful to view the query for debugging or query
--   explanation.
updateToUpdateExpr :: Update readEntity returningClause -> UpdateExpr

-- | Executes the database query for the <a>Update</a> and returns the
--   number of affected rows.
executeUpdate :: MonadOrville m => Update readEntity returningClause -> m Int

-- | Executes the database query for the <a>Update</a> and uses its
--   <a>AnnotatedSqlMarshaller</a> to decode any rows that were just
--   updated, as returned via a RETURNING clause.
executeUpdateReturnEntities :: MonadOrville m => Update readEntity ReturningClause -> m [readEntity]

-- | Builds an <a>Update</a> that will update all of the writable columns
--   described in the <a>TableDefinition</a> and returning the data as seen
--   by the database. This is useful for getting database managed columns
--   such as auto-incrementing identifiers and sequences.
--   
--   This function returns <a>Nothing</a> if the <a>TableDefinition</a> has
--   no columns, which would otherwise generate and <a>Update</a> with
--   invalid SQL syntax.
updateToTableReturning :: TableDefinition (HasKey key) writeEntity readEntity -> key -> writeEntity -> Maybe (Update readEntity ReturningClause)

-- | Builds an <a>Update</a> that will update all of the writable columns
--   described in the <a>TableDefinition</a> without returning the data as
--   seen by the database.
--   
--   This function returns <a>Nothing</a> if the <a>TableDefinition</a> has
--   no columns, which would otherwise generate and <a>Update</a> with
--   invalid SQL syntax.
updateToTable :: TableDefinition (HasKey key) writeEntity readEntity -> key -> writeEntity -> Maybe (Update readEntity NoReturningClause)

-- | Builds an <a>Update</a> that will apply the specified column set
--   clauses to rows within the specified table and return the updated
--   version of any rows affected by the update state by using a
--   <tt>RETURNING</tt> clause.
updateToTableFieldsReturning :: TableDefinition key writeEntity readEntity -> NonEmpty SetClause -> Maybe BooleanExpr -> Update readEntity ReturningClause

-- | Builds an <a>Update</a> that will apply the specified column set
--   clauses to rows within the specified table without returning the data
--   as seen by the database.
updateToTableFields :: TableDefinition key writeEntity readEntity -> NonEmpty SetClause -> Maybe BooleanExpr -> Update readEntity NoReturningClause

-- | Builds an <a>Update</a> that will execute the specified query and use
--   the given <a>AnnotatedSqlMarshaller</a> to decode it. It is up to the
--   caller to ensure that the given <a>UpdateExpr</a> makes sense and
--   produces a value that can be stored, as well as returning a result
--   that the <a>AnnotatedSqlMarshaller</a> can decode.
--   
--   This is the lowest level of escape hatch available for <a>Update</a>.
--   The caller can build any query that Orville supports using the
--   expression building functions, or use <tt>RawSql.fromRawSql</tt> to
--   build a raw <a>UpdateExpr</a>.
rawUpdateExpr :: ReturningOption returningClause -> AnnotatedSqlMarshaller writeEntity readEntity -> UpdateExpr -> Update readEntity returningClause


-- | Interactions to work with database sequence values on the Haskell
--   side. Including inspection of the current and next values in the
--   sequence as well as updating a sequence to a given value.
module Orville.PostgreSQL.Execution.Sequence

-- | Fetches the next value from a sequence via the PostgreSQL
--   <tt>nextval</tt> function.
sequenceNextValue :: MonadOrville m => SequenceDefinition -> m Int64

-- | Fetches the current value from a sequence via the PostgreSQL
--   <tt>currval</tt> function.
sequenceCurrentValue :: MonadOrville m => SequenceDefinition -> m Int64

-- | Sets the current value from a sequence via the PostgreSQL
--   <tt>setval</tt> function.
sequenceSetValue :: MonadOrville m => SequenceDefinition -> Int64 -> m Int64


-- | Functions for working with executable <tt>SELECT</tt> statements. The
--   <a>Select</a> type is a value that can be passed around and executed
--   later. The <a>Select</a> is directly associated with how to decode the
--   rows returned by the query . This means it can be safely executed via
--   <tt>executeInsert</tt> and decode the rows.. It is a lower-level API
--   than the entity select functions in
--   <a>Orville.PostgreSQL.Execution.EntityOperations</a>, but not as
--   primitive as <a>Orville.PostgreSQL.Expr.Query</a>.
module Orville.PostgreSQL.Execution.Select

-- | Represents a <tt>SELECT</tt> statement that can be executed against a
--   database. A <a>Select</a> has a <tt>SqlMarshaller</tt> bound to it
--   that will be used to decode the database result set when it is
--   executed.
data Select readEntity

-- | Excutes the database query for the <a>Select</a> and uses its
--   <tt>SqlMarshaller</tt> to decode the result set.
executeSelect :: MonadOrville m => Select row -> m [row]

-- | Runs a function allowing it to use the data elements containted within
--   the <a>Select</a> it pleases. The marshaller that the function is
--   provided can be use to decode results from the query.
useSelect :: (forall writeEntity. QueryExpr -> AnnotatedSqlMarshaller writeEntity readEntity -> a) -> Select readEntity -> a

-- | Extracts the query that will be run when the select is executed.
--   Normally you don't want to extract the query and run it yourself, but
--   this function is useful to view the query for debugging or query
--   explanation.
selectToQueryExpr :: Select readEntity -> QueryExpr

-- | Builds a <a>Select</a> that will select all the columns described in
--   the <a>TableDefinition</a>. This is the safest way to build a
--   <a>Select</a>, because table name and columns are all read from the
--   <a>TableDefinition</a>. If the table is being managed with Orville
--   auto migrations, this will match the schema in the database.
selectTable :: TableDefinition key writeEntity readEntity -> SelectOptions -> Select readEntity

-- | Builds a <a>Select</a> that will select the columns described by the
--   marshaller from the specified table. It is up to the caller to ensure
--   that the columns in the marshaller make sense for the table.
--   
--   This function is useful for query a subset of table columns using a
--   custom marshaller.
selectMarshalledColumns :: AnnotatedSqlMarshaller writeEntity readEntity -> Qualified TableName -> SelectOptions -> Select readEntity

-- | Builds a <a>Select</a> that will execute the specified query and use
--   the given <tt>SqlMarshaller</tt> to decode it. It is up to the caller
--   to ensure that the given <a>QueryExpr</a> makes sense and produces a
--   result set that the <tt>SqlMarshaller</tt> can decode.
--   
--   This is the lowest level of escape hatch available for <a>Select</a>.
--   The caller can build any query that Orville supports using the
--   expression building functions, or use <tt>RawSql.fromRawSql</tt> to
--   build a raw <a>QueryExpr</a>.
rawSelectQueryExpr :: AnnotatedSqlMarshaller writeEntity readEntity -> QueryExpr -> Select readEntity


-- | Funtions and types for working with PostgreSQL cursors. You can use
--   cursors to execute a query and consume rows from the result set
--   incrementally. Rows that you do not consume will never be sent from
--   the database to the client.
module Orville.PostgreSQL.Execution.Cursor

-- | A <a>Cursor</a> allows you to fetch rows incrementally from
--   PostgreSQL. Using a cursor will allow you to execute a query that
--   returns a very large result set without the entire result set being
--   loaded in memory in your application and instead pulling rows as
--   you're able to process them.
--   
--   See <a>withCursor</a>, <a>fetch</a> and <a>move</a> for details on
--   creating and using <a>Cursor</a> values.
data Cursor readEntity

-- | Declares a <tt>CURSOR</tt> in PostgreSQL that is available for the
--   duration of the action passed to <a>withCursor</a> and closes the
--   cursor when that action completes (or raises an exception).
--   
--   See
--   <tt><a>https://www.postgresql.org/docs/current/sql-declare.html</a></tt>
--   for details about the <a>ScrollExpr</a> and <a>HoldExpr</a> parameters
--   and how cursor behave in general.
--   
--   We recommend you use this instead of <a>declareCursor</a> and
--   <a>closeCursor</a> unless you need to control the cursor resource
--   acquisition and release yourself and can do so safely.
withCursor :: MonadOrville m => Maybe ScrollExpr -> Maybe HoldExpr -> Select readEntity -> (Cursor readEntity -> m a) -> m a

-- | Declares a <tt>CURSOR</tt> in PostgreSQL and returns it for you to
--   use. The cursor must be closed via <a>closeCursor</a> (or another
--   means) when you are done using it. Generally you should use
--   <a>withCursor</a> instead of <a>declareCursor</a> to ensure that the
--   cursor gets closed properly.
--   
--   See
--   <tt><a>https://www.postgresql.org/docs/current/sql-declare.html</a></tt>
--   for details about the <a>ScrollExpr</a> and <a>HoldExpr</a> parameters
--   and how cursor behave in general.
declareCursor :: MonadOrville m => Maybe ScrollExpr -> Maybe HoldExpr -> Select readEntity -> m (Cursor readEntity)

-- | Closes a <tt>CURSOR</tt> in PostgreSQL that was previously declared.
--   This should be used to close any cursors you open via
--   <a>declareCursor</a>, thought we recommend you use <a>withCursor</a>
--   instead to ensure that any opened cursor are closed in the event of an
--   exception.
closeCursor :: MonadOrville m => Cursor readEntity -> m ()

-- | INTERNAL - Generates a unique (or very nearly guaranteed to be) cursor
--   name. Cursor names only need to be unique among the currently open
--   cursors on the current connection, so using POSIX time plus a 32 bit
--   random tag should be more than sufficient to ensure conflicts are not
--   seen in practice.
newCursorName :: MonadIO m => m CursorName

-- | Fetch rows from a cursor according to the <a>CursorDirection</a>
--   given. See
--   <tt><a>https://www.postgresql.org/docs/current/sql-fetch.html</a></tt>
--   for details about effect of fetch and the meanings of cursor
--   directions to PostgreSQL.
fetch :: MonadOrville m => Maybe CursorDirection -> Cursor readEntity -> m [readEntity]

-- | Moves a cursor according to the <a>CursorDirection</a> given. See
--   <tt><a>https://www.postgresql.org/docs/current/sql-fetch.html</a></tt>
--   for details about effect of move and the meanings of cursor directions
--   to PostgreSQL.
move :: MonadOrville m => Maybe CursorDirection -> Cursor readEntity -> m ()

-- | <a>CursorDirection</a> corresponds to the direction argument to the
--   SQL FETCH and MOVE statements. E.G.
--   
--   <pre>
--   BACKWARD
--   </pre>
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
--   
--   <a>CursorDirection</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data CursorDirection

-- | Specify a direction of the next single row. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
next :: CursorDirection

-- | Specify a direction of the prior single row. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
prior :: CursorDirection

-- | Specify a direction of the first single row. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
first :: CursorDirection

-- | Specify a direction of the last single row. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
last :: CursorDirection

-- | Specify a direction of the single row at an absolute position within
--   the cursor. Primarily for use with <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
absolute :: Int -> CursorDirection

-- | Specify a direction of the single row relative to the cursor's current
--   position. Primarily for use with <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
relative :: Int -> CursorDirection

-- | Given a <a>ValueExpression</a>, use it as the argument to the SQL
--   <tt>count</tt>
count :: ValueExpression -> ValueExpression

-- | Specify a direction of all the next rows. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
fetchAll :: CursorDirection

-- | Specify a direction of the next single row. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
forward :: CursorDirection

-- | Specify a direction of the next n rows. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
forwardCount :: Int -> CursorDirection

-- | Specify a direction of all the next rows. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
forwardAll :: CursorDirection

-- | Specify a direction of the prior single row. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
backward :: CursorDirection

-- | Specify a direction of the prior n rows. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
backwardCount :: Int -> CursorDirection

-- | Specify a direction of all the prior rows. Primarily for use with
--   <a>fetch</a> or <a>move</a>.
--   
--   See PostgreSQL <a>fetch documentation</a> for more information.
backwardAll :: CursorDirection


-- | Functions for working with executable <tt>INSERT</tt> statements. The
--   <a>Insert</a> type is a value that can be passed around and executed
--   later. The <a>Insert</a> is directly associated with the presence of a
--   returning clause and how to decode any rows returned by that clause.
--   This means it can be safely executed via <a>executeInsert</a> or
--   <a>executeInsertReturnEntities</a> as appropriate. It is a lower-level
--   API than the entity insert functions in
--   <a>Orville.PostgreSQL.Execution.EntityOperations</a>, but not as
--   primitive as <a>Orville.PostgreSQL.Expr.Insert</a>.
module Orville.PostgreSQL.Execution.Insert

-- | Represents an <tt>INSERT</tt> statement that can be executed against a
--   database. An <a>Insert</a> has a <tt>SqlMarshaller</tt> bound to it
--   that, when the insert returns data from the database, will be used to
--   decode the database result set when it is executed.
data Insert readEntity returningClause

-- | Extracts the query that will be run when the insert is executed.
--   Normally you don't want to extract the query and run it yourself, but
--   this function is useful to view the query for debugging or query
--   explanation.
insertToInsertExpr :: Insert readEntity returningClause -> InsertExpr

-- | Excutes the database query for the <a>Insert</a> and returns the
--   number of rows affected by the query.
executeInsert :: MonadOrville m => Insert readEntity NoReturningClause -> m Int

-- | Excutes the database query for the <a>Insert</a> and uses its
--   <tt>SqlMarshaller</tt> to decode the rows (that were just inserted) as
--   returned via a RETURNING clause.
executeInsertReturnEntities :: MonadOrville m => Insert readEntity ReturningClause -> m [readEntity]

-- | Builds an <a>Insert</a> that will insert all of the writeable columns
--   described in the <a>TableDefinition</a> and returning the data as seen
--   by the database. This is useful for getting database managed columns
--   such as auto-incrementing identifiers and sequences.
insertToTableReturning :: TableDefinition key writeEntity readEntity -> NonEmpty writeEntity -> Insert readEntity ReturningClause

-- | Builds an <a>Insert</a> that will insert all of the writeable columns
--   described in the <a>TableDefinition</a> without returning the data as
--   seen by the database.
insertToTable :: TableDefinition key writeEntity readEntity -> NonEmpty writeEntity -> Insert readEntity NoReturningClause

-- | Builds an <a>Insert</a> that will execute the specified query and use
--   the given <tt>SqlMarshaller</tt> to decode it. It is up to the caller
--   to ensure that the given <a>InsertExpr</a> makes sense and produces a
--   value that can be stored, as well as returning a result that the
--   <tt>SqlMarshaller</tt> can decode.
--   
--   This is the lowest level of escape hatch available for
--   <tt>Update</tt>. The caller can build any query that Orville supports
--   using the expression building functions, or use
--   <tt>RawSql.fromRawSql</tt> to build a raw <a>InsertExpr</a>. It is
--   expected that the <a>ReturningOption</a> given matches the
--   <a>InsertExpr</a>. This level of interface does not provide an
--   automatic enforcement of the expectation, however failure is likely if
--   that is not met.
rawInsertExpr :: ReturningOption returningClause -> AnnotatedSqlMarshaller writeEntity readEntity -> InsertExpr -> Insert readEntity returningClause


-- | Functions for working with executable <tt>DELETE</tt> statements. The
--   <a>Delete</a> type is a value that can be passed around and executed
--   later. The <a>Delete</a> is directly associated with the presence of a
--   returning clause and how to decode any rows returned by that clause.
--   This means it can be safely executed via <a>executeDelete</a> or
--   <tt>executeDeleteReturning</tt> as appropriate. It is a lower-level
--   API than the entity delete functions in
--   <a>Orville.PostgreSQL.Execution.EntityOperations</a>, but not as
--   primitive as <a>Orville.PostgreSQL.Expr.Delete</a>.
module Orville.PostgreSQL.Execution.Delete

-- | Represents a <tt>DELETE</tt> statement that can be executed against a
--   database. A <a>Delete</a> has a <tt>SqlMarshaller</tt> bound to it
--   that, when the delete returns data from the database, will be used to
--   decode the database result set when it is executed.
data Delete readEntity returningClause

-- | Extracts the query that will be run when the delete is executed.
--   Normally you don't want to extract the query and run it yourself, but
--   this function is useful to view the query for debugging or query
--   explanation.
deleteFromDeleteExpr :: Delete readEntity returningClause -> DeleteExpr

-- | Excutes the database query for the <a>Delete</a> and returns the
--   number of rows affected by the query.
executeDelete :: MonadOrville m => Delete readEntity NoReturningClause -> m Int

-- | Excutes the database query for the <a>Delete</a> and uses its
--   <tt>SqlMarshaller</tt> to decode the rows (that were just deleteed) as
--   returned via a RETURNING clause.
executeDeleteReturnEntities :: MonadOrville m => Delete readEntity ReturningClause -> m [readEntity]

-- | Builds a <a>Delete</a> that will delete all of the writeable columns
--   described in the <a>TableDefinition</a> and returning the data as seen
--   by the database. This is useful for getting database managed columns
--   such as auto-incrementing identifiers and sequences.
deleteFromTableReturning :: TableDefinition key writeEntity readEntity -> Maybe BooleanExpr -> Delete readEntity ReturningClause

-- | Builds a <a>Delete</a> that will delete all of the writeable columns
--   described in the <a>TableDefinition</a> without returning the data as
--   seen by the database.
deleteFromTable :: TableDefinition key writeEntity readEntity -> Maybe BooleanExpr -> Delete readEntity NoReturningClause

-- | Builds a <a>Delete</a> that will execute the specified query and use
--   the given <tt>SqlMarshaller</tt> to decode it. It is up to the caller
--   to ensure that the given <a>DeleteExpr</a> makes sense and returns a
--   result that the <tt>SqlMarshaller</tt> can decode.
--   
--   This is the lowest level of escape hatch available for <a>Delete</a>.
--   The caller can build any query that Orville supports using the
--   expression building functions, or use <tt>RawSql.fromRawSql</tt> to
--   build a raw <a>DeleteExpr</a>. It is expected that the
--   <a>ReturningOption</a> given matches the <a>DeleteExpr</a>. This level
--   of interface does not provide an automatic enforcement of the
--   expectation, however failure is likely if that is not met.
rawDeleteExpr :: ReturningOption returningClause -> AnnotatedSqlMarshaller writeEntity readEntity -> DeleteExpr -> Delete readEntity returningClause


-- | Entry-level functions for executing based CRUD operations on entity
--   tables. This are the functions that you will use most often for
--   interacting with tables.
module Orville.PostgreSQL.Execution.EntityOperations

-- | Inserts a entity into the specified table.
insertEntity :: MonadOrville m => TableDefinition key writeEntity readEntity -> writeEntity -> m ()

-- | Inserts a entity into the specified table. Returns the number of rows
--   affected by the query.
insertEntityAndReturnRowCount :: MonadOrville m => TableDefinition key writeEntity readEntity -> writeEntity -> m Int

-- | Inserts a entity into the specified table, returning the data inserted
--   into the database.
--   
--   You can use this function to obtain any column values filled in by the
--   database, such as auto-incrementing ids.
insertAndReturnEntity :: MonadOrville m => TableDefinition key writeEntity readEntity -> writeEntity -> m readEntity

-- | Inserts a non-empty list of entities into the specified table.
insertEntities :: MonadOrville m => TableDefinition key writeEntity readEntity -> NonEmpty writeEntity -> m ()

-- | Inserts a non-empty list of entities into the specified table,
--   returning the data that was inserted into the database.
--   
--   You can use this function to obtain any column values filled in by the
--   database, such as auto-incrementing ids.
insertAndReturnEntities :: MonadOrville m => TableDefinition key writeEntity readEntity -> NonEmpty writeEntity -> m [readEntity]

-- | Inserts a non-empty list of entities into the specified table. Returns
--   the number of rows affected by the query.
insertEntitiesAndReturnRowCount :: MonadOrville m => TableDefinition key writeEntity readEntity -> NonEmpty writeEntity -> m Int

-- | Updates the row with the given key in with the data given by
--   <tt>writeEntity</tt>.
updateEntity :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> key -> writeEntity -> m ()

-- | Updates the row with the given key in with the data given by
--   <tt>writeEntity</tt>. Returns the number of rows affected by the
--   query.
updateEntityAndReturnRowCount :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> key -> writeEntity -> m Int

-- | Updates the row with the given key in with the data given by
--   <tt>writeEntity</tt>, returning updated row from the database. If no
--   row matches the given key, <a>Nothing</a> will be returned.
--   
--   You can use this function to obtain any column values computer by the
--   database during update, including columns with triggers attached to
--   them.
updateAndReturnEntity :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> key -> writeEntity -> m (Maybe readEntity)

-- | Applies the given <a>SetClause</a>s to the rows in the table that
--   match the given where condition. The easiest way to construct a
--   <a>SetClause</a> is via the <a>setField</a> function (also exported as
--   <tt>.:=</tt>).
updateFields :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> NonEmpty SetClause -> Maybe BooleanExpr -> m ()

-- | Like <a>updateFields</a>, but uses a <tt>RETURNING</tt> clause to
--   return the updated version of any rows that were affected by the
--   update.
updateFieldsAndReturnEntities :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> NonEmpty SetClause -> Maybe BooleanExpr -> m [readEntity]

-- | Applies the given <a>SetClause</a>s to the rows in the table that
--   match the given where condition. The easiest way to construct a
--   <a>SetClause</a> is via the <a>setField</a> function (also exported as
--   <tt>.:=</tt>). Returns the number of rows affected by the query.
updateFieldsAndReturnRowCount :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> NonEmpty SetClause -> Maybe BooleanExpr -> m Int

-- | Deletes the row with the given key.
deleteEntity :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> key -> m ()

-- | Deletes the row with the given key. Returns the number of rows
--   affected by the query.
deleteEntityAndReturnRowCount :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> key -> m Int

-- | Deletes the row with the given key, returning the row that was
--   deleted. If no row matches the given key, <a>Nothing</a> is returned.
deleteAndReturnEntity :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> key -> m (Maybe readEntity)

-- | Deletes all rows in the given table that match the where condition.
deleteEntities :: MonadOrville m => TableDefinition key writeEntity readEntity -> Maybe BooleanExpr -> m ()

-- | Deletes all rows in the given table that match the where condition.
--   Returns the number of rows affected by the query.
deleteEntitiesAndReturnRowCount :: MonadOrville m => TableDefinition key writeEntity readEntity -> Maybe BooleanExpr -> m Int

-- | Deletes all rows in the given table that match the where condition,
--   returning the rows that were deleted.
deleteAndReturnEntities :: MonadOrville m => TableDefinition key writeEntity readEntity -> Maybe BooleanExpr -> m [readEntity]

-- | Finds all the entities in the given table according to the specified
--   <a>SelectOptions</a>, which may include where conditions to match,
--   ordering specifications, etc.
findEntitiesBy :: MonadOrville m => TableDefinition key writeEntity readEntity -> SelectOptions -> m [readEntity]

-- | Like 'findEntitiesBy, but adds a 'LIMIT 1' to the query and then
--   returns the first item from the list. Usually when you use this you
--   will want to provide an order by clause in the <a>SelectOptions</a>
--   because the database will not guarantee ordering.
findFirstEntityBy :: MonadOrville m => TableDefinition key writeEntity readEntity -> SelectOptions -> m (Maybe readEntity)

-- | Finds a single entity by the table's primary key value.
findEntity :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> key -> m (Maybe readEntity)

-- | Finds multiple entities by the table's primary key.
findEntities :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> NonEmpty key -> m [readEntity]
instance GHC.Show.Show Orville.PostgreSQL.Execution.EntityOperations.EmptyUpdateError
instance GHC.Exception.Type.Exception Orville.PostgreSQL.Execution.EntityOperations.EmptyUpdateError


-- | You can import <a>Orville.PostgreSQL.Execution</a> to get access to
--   all the execution-related functions and types exported by the modules
--   below. This includes a number of lowel-level items not exported by
--   <a>Orville.PostgreSQL</a> that give you more control (and therefore
--   responsibility) over how the SQL is executed.
module Orville.PostgreSQL.Execution


module Orville.PostgreSQL.Plan.Operation

-- | <a>Operation</a> provides a stucture for building primitive operations
--   that can be incorporated into a <a>Plan</a>. An <a>Operation</a>
--   provides base case implementations of the various plan execution
--   functions. You only need to care about this type if you want to create
--   new custom operations to include in a <a>Plan</a> beyond those already
--   provided in the <a>Plan</a> api.
--   
--   You can build your own custom <a>Operation</a> values either directly,
--   or using the function and types in this module, such as
--   <a>WherePlanner</a> (via <a>findAll</a>, etc), or
--   <a>SelectOperation</a> (via <a>selectOperation</a>).
data Operation param result
Operation :: (forall m. MonadOrville m => param -> m (Either AssertionFailed result)) -> (forall m. MonadOrville m => NonEmpty param -> m (Either AssertionFailed (Many param result))) -> Explanation -> Explanation -> Operation param result

-- | <a>executeOperationOne</a> will be called when an plan is executed
--   with a single input parameter
[executeOperationOne] :: Operation param result -> forall m. MonadOrville m => param -> m (Either AssertionFailed result)

-- | <a>executeOperationMany</a> will be called when an plan is executed
--   with multiple input parameters (via <tt>planMany</tt>).
[executeOperationMany] :: Operation param result -> forall m. MonadOrville m => NonEmpty param -> m (Either AssertionFailed (Many param result))

-- | <a>explainOperationOne</a> will be called when producing an
--   explanation of what the plan will do when given one input parameter.
--   Plans that do not perform any interesting IO interactions should
--   generally return an empty explanation.
[explainOperationOne] :: Operation param result -> Explanation

-- | <a>explainOperationMany</a> will be called when producing an
--   explanation of what the plan will do when given multiple input
--   parameters (via <tt>planMany</tt>). Plans that do not perform any
--   interesting IO interactions should generally return an empty
--   explanation.
[explainOperationMany] :: Operation param result -> Explanation

-- | <a>AssertionFailed</a> may be returned from the execute functions of
--   an <a>Operation</a> to indicate that some expected invariant has
--   failed. For example, following a foreign key that is enforced by the
--   database only to find that no record exists. When an <a>Operation</a>
--   returns an <a>AssertionFailed</a> value during plan execution the
--   error is thrown as an exception using the <a>MonadThrow</a> instance
--   for whatever monad the plan is executing in.
data AssertionFailed

-- | <a>mkAssertionFailed</a> builds an <a>AssertionFailed</a> error from
--   an error message.
mkAssertionFailed :: String -> AssertionFailed

-- | The functions below (<a>findOne</a>, <a>findAll</a>, etc) accept a
--   <a>WherePlanner</a> to determine how to build the where conditions for
--   executing a <tt>Select</tt> statement as part of a the plan operation.
--   
--   For simple queries you can use the functions such as <a>byField</a>
--   that are provided here to build a <a>WherePlanner</a>, but you may
--   also build your own custom <a>WherePlanner</a> for more advanced use
--   cases.
--   
--   If you need to execute a custom query that cannot be build by
--   providing custom where clause via <a>WherePlanner</a>, you may want to
--   use more direct <a>selectOperation</a> function.
data WherePlanner param
WherePlanner :: (forall entity. (entity -> param) -> SqlMarshaller entity param) -> (param -> BooleanExpr) -> (NonEmpty param -> BooleanExpr) -> BooleanExpr -> BooleanExpr -> WherePlanner param

-- | The <a>paramMarshaller</a> function provided here will be used to
--   decode the parameter field from the result set so that the row can be
--   properly associated with the input parameter that matched it.
[paramMarshaller] :: WherePlanner param -> forall entity. (entity -> param) -> SqlMarshaller entity param

-- | <a>executeOneWhereCondition</a> must build a where condition that will
--   match only those rows that match the input paramater.
[executeOneWhereCondition] :: WherePlanner param -> param -> BooleanExpr

-- | <a>executeManyWhereCondition</a> must build a where condition that
--   will match only those rows that match any (not all!) of the input
--   parameters.
[executeManyWhereCondition] :: WherePlanner param -> NonEmpty param -> BooleanExpr

-- | <a>explainOneWhereCondition</a> must build a where condition that is
--   suitable to be used as an example of <a>executeManyWhereCondition</a>
--   would return when given a parameter. This where condition will be used
--   for when producing explanations of plans. For example, this could fill
--   in either an example or dummy value.
[explainOneWhereCondition] :: WherePlanner param -> BooleanExpr

-- | <a>explainManyWhereCondition</a> must build a where condition that is
--   suitable to be used as an example of <a>executeOneWhereCondition</a>
--   would return when given a list of parameters. This where condition
--   will be used for when producing explanations of plans. For example,
--   this could fill in either an example or dummy value.
[explainManyWhereCondition] :: WherePlanner param -> BooleanExpr

-- | Builds a <a>WherePlanner</a> that will match on a single
--   <a>FieldDefinition</a>. The resulting <a>WherePlanner</a> can be used
--   with functions such as <a>findOne</a> and <a>findAll</a> to construct
--   an <a>Operation</a>.
byField :: Ord fieldValue => FieldDefinition nullability fieldValue -> WherePlanner fieldValue

-- | Builds a <a>WherePlanner</a> that will match on a 2-tuple of
--   <a>FieldDefinition</a>s. The resulting <a>WherePlanner</a> can be used
--   with functions such as <a>findOne</a> and <a>findAll</a> to construct
--   an <a>Operation</a>.
byFieldTuple :: forall nullabilityA fieldValueA nullabilityB fieldValueB. (Ord fieldValueA, Ord fieldValueB) => FieldDefinition nullabilityA fieldValueA -> FieldDefinition nullabilityB fieldValueB -> WherePlanner (fieldValueA, fieldValueB)

-- | <a>findOne</a> builds a planning primitive that finds (at most) one
--   row from the given table where the column value for the provided
--   <a>FieldDefinition</a> matches the plan's input parameter. When
--   executed on multiple parameters it fetches all rows where the field
--   matches the inputs and arbitrarily picks at most one of those rows to
--   use as the result for each input.
findOne :: Ord param => TableDefinition key writeEntity readEntity -> WherePlanner param -> Operation param (Maybe readEntity)

-- | <a>findOneWhere</a> is similar to <a>findOne</a> but allows a
--   <tt>WhereCondition</tt> to be specified that is added to the database
--   query to restrict which rows are returned.
findOneWhere :: Ord param => TableDefinition key writeEntity readEntity -> WherePlanner param -> BooleanExpr -> Operation param (Maybe readEntity)

-- | <a>findAll</a> builds a planning primitive that finds all the rows
--   from the given table where the column value for the provided field
--   matches the plan's input parameter. Where executed on multiple
--   parameters all rows are fetch in a single query and then associated
--   with their respective inputs after being fetched.
findAll :: Ord param => TableDefinition key writeEntity readEntity -> WherePlanner param -> Operation param [readEntity]

-- | <a>findAllWhere</a> is similar to <a>findAll</a> but allows a
--   <tt>WhereCondition</tt> to be specified that is added to the database
--   query to restrict which rows are returned.
findAllWhere :: Ord param => TableDefinition key writeEntity readEntity -> WherePlanner param -> BooleanExpr -> Operation param [readEntity]

-- | <a>findSelect</a> builds a plan <a>Operation</a> where the select that
--   is run does not use the input parameters for the plan in any way. If
--   the <a>executeOperationMany</a> function of the resulting
--   <a>Operation</a> will run the query once and use the entire result set
--   as the result each of the input parameters in turn.
findSelect :: forall param row. Select row -> Operation param [row]

-- | <a>askParam</a> simply returns the paremeter given from the plan.
askParam :: Operation param param

-- | <a>assertRight</a> returns the value on the <a>Right</a> side of an
--   <a>Either</a>. If the <a>Either</a> is a <a>Left</a>, it raises
--   <a>AssertionFailed</a> with the message from the left side of the
--   either.
assertRight :: Operation (Either String a) a

-- | <a>SelectOperation</a> is a helper type for building <a>Operation</a>
--   primitives that run <tt>Select</tt> queries. Specifying the fields of
--   <a>SelectOperation</a> and then using the <a>selectOperation</a>
--   function to build an <a>Operation</a> is more convenient that building
--   functions to execute the queries thate are required by the
--   <a>Operation</a> type.
--   
--   Note: If you only need to build a custom where clause based on the
--   <a>Operation</a> parameter, you may want to use a custom
--   <a>WherePlanner</a> with one of the existing <a>findOne</a> or
--   <a>findAll</a> functions.
--   
--   If you cannot respresent your custom operation using
--   <a>SelectOperation</a> then you need build the <a>Operation</a> value
--   directly yourself.
data SelectOperation param row result
SelectOperation :: (param -> Select row) -> (NonEmpty param -> Select row) -> Select row -> Select row -> (row -> param) -> ([row] -> result) -> SelectOperation param row result

-- | <a>selectOne</a> will be called to build the <tt>Select</tt> query
--   that should be run when there is a single input parameter while
--   executing a plan. Note that the "One-ness" here refers to the single
--   input parameter rather than result. See <a>produceResult</a> below for
--   more information about returning one values vs. many from a
--   <a>SelectOperation</a>.
[selectOne] :: SelectOperation param row result -> param -> Select row

-- | <a>selectMany</a> will be called to build the <tt>Select</tt> query
--   that should be run when there are multiple parameters while executing
--   a plan. Note that the "Many-ness" here refers to the multiple input
--   parameters rather than result. See <a>produceResult</a> below for more
--   information about returning one values vs. many from a
--   <a>SelectOperation</a>.
[selectMany] :: SelectOperation param row result -> NonEmpty param -> Select row

-- | <a>explainSelectOne</a> should show a representative query of what
--   will be returned when <a>selectOne</a> is used. No input parameter is
--   available here to build the query, however, because this value is used
--   to explain a plan without actually running it.
[explainSelectOne] :: SelectOperation param row result -> Select row

-- | <a>explainSelectMany</a> should show a representative query of what
--   will be returned when 'selectMany is used. No input parameters are
--   available here to build the query, however, because this value is used
--   to explain a plan without actually running it.
[explainSelectMany] :: SelectOperation param row result -> Select row

-- | <a>categorizeRow</a> will be used when a plan is executed with
--   multiple parameters to determine which input parameter the row should
--   be associated with.
[categorizeRow] :: SelectOperation param row result -> row -> param

-- | <a>produceResult</a> will be used convert the <tt>row</tt> type
--   returned by the <tt>Select</tt> queries for the operation input the
--   <tt>result</tt> type that is present as the output of the operation.
--   The input rows will be all the inputs associated with a single
--   parameter. The <tt>result</tt> type constructed here need not be a
--   single value. For instance, <a>findAll</a> uses the list type as the
--   <tt>result</tt> type and <a>findOne</a> uses <a>Maybe</a>.
[produceResult] :: SelectOperation param row result -> [row] -> result

-- | <a>selectOperation</a> builds a primitive planning <a>Operation</a>
--   using the functions given by a <a>SelectOperation</a>. If you are
--   implementing a custom operation that runs a select statement, it is
--   probably easier to use this function rather than building the
--   <a>Operation</a> functions directly.
selectOperation :: Ord param => SelectOperation param row result -> Operation param result
instance GHC.Show.Show Orville.PostgreSQL.Plan.Operation.AssertionFailed
instance GHC.Exception.Type.Exception Orville.PostgreSQL.Plan.Operation.AssertionFailed


module Orville.PostgreSQL.Plan

-- | A <a>Plan</a> is an executable set of queries that can be executed to
--   load data from the database, using the results of prior queries as
--   input parameters to following queries in controlled ways. In
--   particular, the "controlled" aspect of this allows plans that take a
--   single input to be adapted to take multiple input parameters in a list
--   without the resulting plan executing N+1 queries. This restriction
--   means that while query results can be used as input parameters to
--   later queries, they cannot be used to decide to run completely
--   different queries based on other query results. Allowing this would
--   prevent the <a>Plan</a> structure from eliminating N+1 query loops.
--   
--   Note that during execution queries are never combined across tables to
--   form joins or subqueries. Queries are still executed in the same
--   sequence as specified in the plan, just on all the inputs at once
--   rather than in a loop. If you need to do a join with a plan, you can
--   always construction your own custom <a>Operation</a> and use
--   <a>planOperation</a> to incorporate into a plan.
--   
--   The <tt>param</tt> type variable indicates what type of value is
--   expected as input when the plan is executed.
--   
--   The <tt>result</tt> type for a plan indicates what Haskell type is
--   produced when the plan is executed.
--   
--   The <tt>scope</tt> type is used internally by Orville to track the
--   plan is currently executed against a single input or multiple inputs.
--   This type parameter should never specified as a concrete type in user
--   code, but must be exposed as a variable to ensure that execute scope
--   is tracked correctly through usages of <a>bind</a>.
data Plan scope param result

-- | A <a>Planned</a> value is a wrapper around the results of previous run
--   queries when using the <a>bind</a> function. At the time that you are
--   writing a plan you do not know whether the <a>Plan</a> will be run
--   with a single input or multiple inputs. A <a>Planned</a> value may end
--   up being either an individual item or a list of items. Due to this,
--   your ability to interact with the value is limited to the use of
--   <a>fmap</a> to extract (or build) other values from the results.
--   <a>Planned</a> values can be used together with the <a>use</a>
--   function to make a <a>Plan</a> that produces the extracted value.
--   
--   Note that while <a>Planned</a> could provide an <a>Applicative</a>
--   instance as well, it does not to avoid confusion with
--   <a>Applicative</a> instance for <a>Plan</a> itself. If you need to
--   build a value from several <a>Planned</a> values using
--   <a>Applicative</a>, you should call <a>use</a> on each of the values
--   and use the <a>Applicative</a> instance for <a>Plan</a>.
data Planned scope param a

-- | <a>Execute</a> is a tag type used by as the <tt>scope</tt> variable
--   for <a>Plan</a> values when executing them via the <a>execute</a>
--   function.
data Execute

-- | <a>Explain</a> is an tag type used as the <tt>scope</tt> variable when
--   explaining a <a>Plan</a> via the <a>explain</a> function.
data Explain

-- | <a>askParam</a> allows the input parameter for the plan to be
--   retrieved as the result of the plan. Together with <a>bind</a> you can
--   use this to get access to the input parameter as a <a>Planned</a>
--   value.
askParam :: Plan scope param param

-- | <a>execute</a> accepts the input parameter (or parameters) expected by
--   a <a>Plan</a> and runs the plan to completion, either throwing an
--   <a>AssertionFailed</a> exception in the monad <tt>m</tt> or producing
--   the expected result.
--   
--   If you have a plan that takes one input and want to provide a list of
--   input, use <a>planMany</a> to adapt it to a multple-input plan before
--   calling <a>execute</a>.
execute :: MonadOrville m => Plan Execute param result -> param -> m result

-- | <a>explain</a> produces a textual description of the steps outlined by
--   a <a>Plan</a> -- in most cases example SQL queries. If you want to see
--   the explanation of how the plan will run with multiple input
--   parameters, you can use <a>planMany</a> to adapt it before calling
--   <a>explain</a>.
explain :: Plan Explain param result -> [String]

-- | <a>findMaybeOne</a> constructs a <a>Plan</a> that will find at most
--   one row from the given table where the plan's input value matches the
--   given database field.
findMaybeOne :: Ord fieldValue => TableDefinition key writeEntity readEntity -> FieldDefinition nullability fieldValue -> Plan scope fieldValue (Maybe readEntity)

-- | <a>findMaybeOneWhere</a> is similar to <a>findMaybeOne</a>, but allows
--   a <tt>WhereCondition</tt> to be specified to restrict which rows are
--   matched by the database query.
findMaybeOneWhere :: Ord fieldValue => TableDefinition key writeEntity readEntity -> FieldDefinition nullability fieldValue -> BooleanExpr -> Plan scope fieldValue (Maybe readEntity)

-- | <a>findOne</a> is an alias to <a>findOneShowVia</a> that uses the
--   <a>Show</a> instance of <tt>fieldValue</tt> when producing a failure
--   message in the result the entity cannot be found.
findOne :: (Show fieldValue, Ord fieldValue) => TableDefinition key writeEntity readEntity -> FieldDefinition nullability fieldValue -> Plan scope fieldValue readEntity

-- | <a>findOneShowVia</a> is similar to 'findMaybeOne, but it expects that
--   there will always be a row found matching the plan's input value. If
--   no row is found an <a>AssertionFailed</a> exception will be thrown.
--   This is a useful convenience when looking up foreign-key associations
--   that are expected to be enforced by the database itself.
findOneShowVia :: Ord fieldValue => (fieldValue -> String) -> TableDefinition key writeEntity readEntity -> FieldDefinition nullability fieldValue -> Plan scope fieldValue readEntity

-- | <a>findOneWhere</a> is an alias to <a>findOneWhereShowVia</a> that
--   uses the <a>Show</a> instance of <tt>fieldValue</tt> when producing a
--   failure message in the result the entity cannot be found.
findOneWhere :: (Show fieldValue, Ord fieldValue) => TableDefinition key writeEntity readEntity -> FieldDefinition nullability fieldValue -> BooleanExpr -> Plan scope fieldValue readEntity

-- | <a>findOneWhereShowVia</a> is similar to <a>findOneShowVia</a>, but
--   allows a <tt>WhereCondition</tt> to be specified to restrict which
--   rows are matched by the database query.
findOneWhereShowVia :: Ord fieldValue => (fieldValue -> String) -> TableDefinition key writeEntity readEntity -> FieldDefinition nullability fieldValue -> BooleanExpr -> Plan scope fieldValue readEntity

-- | <a>findAll</a> constructs a <a>Plan</a> that will find all the rows
--   from the given table there the plan's input value matches the given
--   database field.
findAll :: Ord fieldValue => TableDefinition key writeEntity readEntity -> FieldDefinition nullability fieldValue -> Plan scope fieldValue [readEntity]

-- | <a>findAllWhere</a> is similar to <a>findAll</a>, but allows a
--   <tt>WhereCondition</tt> to be specified to restrict which rows are
--   matched by the database query.
findAllWhere :: Ord fieldValue => TableDefinition key writeEntity readEntity -> FieldDefinition nullability fieldValue -> BooleanExpr -> Plan scope fieldValue [readEntity]

-- | <a>bind</a> gives access to the results of a plan to use as input
--   values to future plans. The plan result is given the input parameter
--   to the provided function, which must produce the remaining <a>Plan</a>
--   to be executed. The value will be wrapped in the <a>Planned</a> type,
--   which may represent either a result or multiple results, depending on
--   whether one plan is currently be executed with one and multiple input
--   parameters. This ensures that the caller produces only a single
--   remaining <a>Plan</a> to be used for all inputs when there are
--   multiple to eliminate the need to possibly run different queries for
--   different inputs (which would an introduce N+1 query execution).
--   
--   The <a>Planned</a> value (or values) provided by <a>bind</a> have
--   actually been retrieved from the database, so the value can be used
--   multiple times when constructing the remaining <a>Plan</a> without
--   fear of causing the query to run multiple times.
--   
--   Also see <a>use</a> for how to lift a <a>Planned</a> value back into a
--   <a>Plan</a>.
bind :: Plan scope param a -> (Planned scope param a -> Plan scope param result) -> Plan scope param result

-- | <a>use</a> constructs a <a>Plan</a> that always produces the
--   <a>Planned</a> value as its result, regardless of the parameter given
--   as input to the plan.
use :: Planned scope param a -> Plan scope param a

-- | <a>using</a> uses a <a>Planned</a> value in the input to another
--   <a>Plan</a>. The resulting plan will ignore its input and use the
--   <a>Planned</a> value as the input to produce its result instead.
using :: Planned scope param a -> Plan scope a b -> Plan scope param b

-- | <a>chain</a> connects the output of one plan to the input of another
--   to form a larger plan that will execute the first followed by the
--   second.
chain :: Plan scope a b -> Plan scope b c -> Plan scope a c

-- | <a>chainMaybe</a> connects two plans that both yield Maybes. If the
--   first plan yields no result, the second is skipped. See also
--   <a>chain</a>.
chainMaybe :: Plan scope a (Maybe b) -> Plan scope b (Maybe c) -> Plan scope a (Maybe c)

-- | <a>apply</a> applies a function produced by a plan to the value
--   produced by another plan. This is usually used via the
--   <a>&lt;*&gt;</a> operator through the <a>Applicative</a> instance for
--   <a>Plan</a>.
apply :: Plan scope param (a -> b) -> Plan scope param a -> Plan scope param b

-- | <a>planMany</a> adapts a plan that takes a single input parameter to
--   work on multiple input parameters. When the new plan is executed each
--   query will execute in the same basic order, but with adjusted
--   conditions to find all the rows for all inputs at once rather than
--   running the planned queries once for each input.
planMany :: (forall manyScope. Plan manyScope param result) -> Plan scope [param] (Many param result)

-- | <a>planList</a> lifts a plan so both its param and result become
--   lists. This saves you from having to fmap in <a>elems</a> when all you
--   want back from a <a>Many</a> is the list of results inside it.
--   
--   There will always be the same number of elements in the
--   <tt>[result]</tt> list as there are in the <tt>[param]</tt> list, even
--   if there are duplicate values in the input parameters. This may be
--   counter-intuitive in the trivial case where a plan that queries a
--   single table is passed to <a>planList</a> but cannot be avoided due to
--   more complicated situations where the original plan executes queries
--   against multiple tables. When a plan that queries multiple table is
--   passed, the query results must be correlated based on the input
--   parameters to build each <tt>result</tt> value.
planList :: (forall scope. Plan scope param result) -> Plan listScope [param] [result]

-- | <a>focusParam</a> builds a plan from a function and an existing plan
--   taking the result of that function as input. This is especially useful
--   when there is some structure, and a plan that only needs a part of
--   that structure as input. The function argument can access part of the
--   structure for the plan argument to use, so the final returned plan can
--   take the entire structure as input.
focusParam :: (a -> b) -> Plan scope b result -> Plan scope a result

-- | <a>planEither</a> lets you construct a plan that branches by executing
--   a different plan for the <a>Left</a> and <a>Right</a> sides of an
--   <a>Either</a> value. When used with a single input parameter only one
--   of the two plans will be used, based on the input parameter. When used
--   on multiple input parameters, each of the two plans will be executed
--   only once with all the <a>Left</a> and <a>Right</a> values provided as
--   input parameters respectively.
planEither :: Plan scope leftParam leftResult -> Plan scope rightParam rightResult -> Plan scope (Either leftParam rightParam) (Either leftResult rightResult)

-- | <a>planMaybe</a> lifts a plan so both its param and result become
--   <a>Maybe</a>s. This is useful when modifying an existing plan to deal
--   with optionality. Writing just one plan can then easily produce both
--   the required and optional versions.
planMaybe :: Plan scope a b -> Plan scope (Maybe a) (Maybe b)

-- | <a>AssertionFailed</a> may be returned from the execute functions of
--   an <a>Operation</a> to indicate that some expected invariant has
--   failed. For example, following a foreign key that is enforced by the
--   database only to find that no record exists. When an <a>Operation</a>
--   returns an <a>AssertionFailed</a> value during plan execution the
--   error is thrown as an exception using the <a>MonadThrow</a> instance
--   for whatever monad the plan is executing in.
data AssertionFailed

-- | <a>assert</a> allows you to make an assertion about a plans result
--   that will throw an <a>AssertionFailed</a> failed exception during
--   execution if it proves to be false. The first parameter is the
--   assertion function, which should return either an error message to be
--   given in the exception or the value to be used as the plan's result.
assert :: (param -> a -> Either String b) -> Plan scope param a -> Plan scope param b

-- | <a>planSelect</a> allows any Orville <a>Select</a> query to be
--   incorporated into a plan. Note that the <a>Select</a> cannot depend on
--   the plan's input parameters in this case. If the plan is executed with
--   multiple inputs the same set of all the results will be used as the
--   results for each of the input parameters.
planSelect :: Select row -> Plan scope () [row]

-- | <a>planOperation</a> allows any primitive <a>Operation</a> to be used
--   as an atomic step in a plan. When the plan is executed, the
--   appropriate <a>Operation</a> functions will be used depending on the
--   execution context.
planOperation :: Operation param result -> Plan scope param result
instance GHC.Base.Functor (Orville.PostgreSQL.Plan.Plan scope param)
instance GHC.Base.Applicative (Orville.PostgreSQL.Plan.Plan scope param)
instance GHC.Base.Functor (Orville.PostgreSQL.Plan.Planned scope param)


-- | This module exports the <a>bind</a> function as <a>&gt;&gt;=</a> so
--   that it can be used in conjuction with the <tt>QualifiedDo</tt>
--   language extension to write plans using do syntax like so:
--   
--   <pre>
--   {-# LANGUAGE QualifiedDo #-}
--   module MyModule where
--   
--   import qualified Orville.PostgreSQL.Plan.Syntax as PlanSyntax
--   
--   data FooFamily =
--     FooFamily
--       { foo :: Foo
--       , children :: [FooChildren]
--       , pets :: [FooPets]
--       }
--   
--   findFooFamily = PlanSyntax.do $
--     fooHeader &lt;- Plan.findOne fooTable fooIdField
--     fooChildren &lt;- Plan.findAll fooChildTable fooIdField
--     fooPets &lt;- Plan.findAll fooPetTable fooIdField
--   
--     FooFamily
--       <a>$</a> Plan.use fooHeader
--       <a>*</a> Plan.use fooChildren
--       <a>*</a> Plan.use fooPets
--   </pre>
module Orville.PostgreSQL.Plan.Syntax

-- | An operator alias of <a>bind</a> so that it can be used with
--   <tt>QualifiedDo</tt>.
(>>=) :: Plan scope param a -> (Planned scope param a -> Plan scope param result) -> Plan scope param result


-- | <a>Orville.PostgreSQL</a> is the module you will most often want to
--   import for using Orville. It re-exports most of the functions you need
--   for everyday basic operations on table entities. If you cannot find
--   the function you need exported here, you may be able to find it one of
--   the modules that re-exports more functional for a specific area:
--   
--   <ul>
--   <li><a>Orville.PostgreSQL.AutoMigration</a></li>
--   <li><a>Orville.PostgreSQL.Execution</a></li>
--   <li><a>Orville.PostgreSQL.Expr</a></li>
--   <li><a>Orville.PostgreSQL.Marshall</a></li>
--   <li><a>Orville.PostgreSQL.Monad</a></li>
--   <li><a>Orville.PostgreSQL.OrvilleState</a></li>
--   <li><a>Orville.PostgreSQL.Schema</a></li>
--   </ul>
--   
--   Of course, you can always use the table of contents for the package to
--   see all the exports Orville offers.
module Orville.PostgreSQL

-- | Inserts a entity into the specified table.
insertEntity :: MonadOrville m => TableDefinition key writeEntity readEntity -> writeEntity -> m ()

-- | Inserts a entity into the specified table. Returns the number of rows
--   affected by the query.
insertEntityAndReturnRowCount :: MonadOrville m => TableDefinition key writeEntity readEntity -> writeEntity -> m Int

-- | Inserts a entity into the specified table, returning the data inserted
--   into the database.
--   
--   You can use this function to obtain any column values filled in by the
--   database, such as auto-incrementing ids.
insertAndReturnEntity :: MonadOrville m => TableDefinition key writeEntity readEntity -> writeEntity -> m readEntity

-- | Inserts a non-empty list of entities into the specified table.
insertEntities :: MonadOrville m => TableDefinition key writeEntity readEntity -> NonEmpty writeEntity -> m ()

-- | Inserts a non-empty list of entities into the specified table. Returns
--   the number of rows affected by the query.
insertEntitiesAndReturnRowCount :: MonadOrville m => TableDefinition key writeEntity readEntity -> NonEmpty writeEntity -> m Int

-- | Inserts a non-empty list of entities into the specified table,
--   returning the data that was inserted into the database.
--   
--   You can use this function to obtain any column values filled in by the
--   database, such as auto-incrementing ids.
insertAndReturnEntities :: MonadOrville m => TableDefinition key writeEntity readEntity -> NonEmpty writeEntity -> m [readEntity]

-- | Updates the row with the given key in with the data given by
--   <tt>writeEntity</tt>.
updateEntity :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> key -> writeEntity -> m ()

-- | Updates the row with the given key in with the data given by
--   <tt>writeEntity</tt>. Returns the number of rows affected by the
--   query.
updateEntityAndReturnRowCount :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> key -> writeEntity -> m Int

-- | Updates the row with the given key in with the data given by
--   <tt>writeEntity</tt>, returning updated row from the database. If no
--   row matches the given key, <a>Nothing</a> will be returned.
--   
--   You can use this function to obtain any column values computer by the
--   database during update, including columns with triggers attached to
--   them.
updateAndReturnEntity :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> key -> writeEntity -> m (Maybe readEntity)

-- | Applies the given <a>SetClause</a>s to the rows in the table that
--   match the given where condition. The easiest way to construct a
--   <a>SetClause</a> is via the <a>setField</a> function (also exported as
--   <tt>.:=</tt>).
updateFields :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> NonEmpty SetClause -> Maybe BooleanExpr -> m ()

-- | Like <a>updateFields</a>, but uses a <tt>RETURNING</tt> clause to
--   return the updated version of any rows that were affected by the
--   update.
updateFieldsAndReturnEntities :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> NonEmpty SetClause -> Maybe BooleanExpr -> m [readEntity]

-- | Applies the given <a>SetClause</a>s to the rows in the table that
--   match the given where condition. The easiest way to construct a
--   <a>SetClause</a> is via the <a>setField</a> function (also exported as
--   <tt>.:=</tt>). Returns the number of rows affected by the query.
updateFieldsAndReturnRowCount :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> NonEmpty SetClause -> Maybe BooleanExpr -> m Int

-- | Deletes the row with the given key.
deleteEntity :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> key -> m ()

-- | Deletes the row with the given key. Returns the number of rows
--   affected by the query.
deleteEntityAndReturnRowCount :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> key -> m Int

-- | Deletes the row with the given key, returning the row that was
--   deleted. If no row matches the given key, <a>Nothing</a> is returned.
deleteAndReturnEntity :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> key -> m (Maybe readEntity)

-- | Deletes all rows in the given table that match the where condition.
deleteEntities :: MonadOrville m => TableDefinition key writeEntity readEntity -> Maybe BooleanExpr -> m ()

-- | Deletes all rows in the given table that match the where condition.
--   Returns the number of rows affected by the query.
deleteEntitiesAndReturnRowCount :: MonadOrville m => TableDefinition key writeEntity readEntity -> Maybe BooleanExpr -> m Int

-- | Deletes all rows in the given table that match the where condition,
--   returning the rows that were deleted.
deleteAndReturnEntities :: MonadOrville m => TableDefinition key writeEntity readEntity -> Maybe BooleanExpr -> m [readEntity]

-- | Finds all the entities in the given table according to the specified
--   <a>SelectOptions</a>, which may include where conditions to match,
--   ordering specifications, etc.
findEntitiesBy :: MonadOrville m => TableDefinition key writeEntity readEntity -> SelectOptions -> m [readEntity]

-- | Like 'findEntitiesBy, but adds a 'LIMIT 1' to the query and then
--   returns the first item from the list. Usually when you use this you
--   will want to provide an order by clause in the <a>SelectOptions</a>
--   because the database will not guarantee ordering.
findFirstEntityBy :: MonadOrville m => TableDefinition key writeEntity readEntity -> SelectOptions -> m (Maybe readEntity)

-- | Finds a single entity by the table's primary key value.
findEntity :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> key -> m (Maybe readEntity)

-- | Finds multiple entities by the table's primary key.
findEntities :: MonadOrville m => TableDefinition (HasKey key) writeEntity readEntity -> NonEmpty key -> m [readEntity]

-- | The <a>Orville</a> Monad provides a easy starter implementation of
--   <tt>MonadOrville</tt> when you don't have a monad specific to your
--   application that you need to use.
--   
--   If you want add Orville capabilities to your own monad, take a look at
--   <tt>MonadOrville</tt> to learn what needs to be done.
data Orville a

-- | Runs an <a>Orville</a> operation in the <a>IO</a> monad using the
--   given connection pool.
--   
--   This will run the <a>Orville</a> operation with the
--   <tt>ErrorDetailLevel</tt> set to the default. If want to run with a
--   different detail level, you can use <a>newOrvilleState</a> to create a
--   state with the desired detail level and then use
--   <a>runOrvilleWithState</a>.
runOrville :: Pool Connection -> Orville a -> IO a

-- | Runs an <a>Orville</a> operation in the <a>IO</a> monad, starting from
--   the provided <tt>OrvilleState</tt>.
--   
--   Caution: If you harvest an <tt>OrvilleState</tt> from inside a
--   <a>MonadOrville</a> monad using <a>askOrvilleState</a>, you may pick
--   up connection tracking state that you didn't intend to. You may want
--   to use <a>resetOrvilleState</a> in this situation to get a new initial
--   state before passing it to <a>runOrvilleWithState</a>.
--   
--   On the other hand, if you know that you want to pass the existing
--   connection state from another monad into the <a>Orville</a> monad,
--   this is how you do it.
runOrvilleWithState :: OrvilleState -> Orville a -> IO a

-- | <a>createConnectionPool</a> allocates a pool of connections to a
--   PostgreSQL server.
createConnectionPool :: NoticeReporting -> Int -> NominalDiffTime -> Int -> ByteString -> IO (Pool Connection)

-- | An Orville handle for a LibPQ connection.
data Connection
data () => Pool a

-- | An option for <a>createConnectionPool</a> than indicates whether the
--   LibPQ should print notice reports for warnings to the console
data NoticeReporting
EnableNoticeReporting :: NoticeReporting
DisableNoticeReporting :: NoticeReporting

-- | Performs an action in an Orville monad within a database transaction.
--   The transaction in begun before the action is called. If the action
--   completes without raising an exception, the transaction will be
--   committed. If the action raises an exception, the transaction will
--   rollback.
--   
--   This function in safe to call from within another transaction. When
--   called this way the transaction will establish a new savepoint at the
--   beginning of the nested transaction and either release the savepoint
--   or rollback to it as appropriate.
--   
--   Note: Exceptions are handled using the implementations of <a>catch</a>
--   and <a>mask</a> provided by the <tt>MonadOrvilleControl</tt> instance
--   for <tt>m</tt>.
withTransaction :: MonadOrville m => m a -> m a

-- | <a>MonadOrville</a> is the typeclass that most Orville operations
--   require to do anything that connects to the database.
--   <a>MonadOrville</a> itself is empty, but it lists all the required
--   typeclasses as superclass contraints so that it can be used instead of
--   listing all the constraints on every function.
--   
--   If you want to be able to run Orville operations directly in your own
--   application's Monad stack, a good starting place is to add
--   
--   <pre>
--   instance MonadOrville MyApplicationMonad
--   
--   </pre>
--   
--   to your module and then let the compiler tell you what instances you
--   are missing from the superclasses.
class (HasOrvilleState m, MonadOrvilleControl m, MonadIO m) => MonadOrville m

-- | <a>withConnection_</a> is a convenience version of
--   <a>withConnection</a> for those that don't need the actual connection
--   handle. You might want to use this function even without using the
--   handle because it ensures that all the Orville operations performed by
--   the action passed to it occur on the same connection. Orville uses
--   connection pooling, so unless you use either <a>withConnection</a> or
--   <tt>withTransaction</tt> each database operation may be performed on a
--   different connection.
withConnection_ :: MonadOrville m => m a -> m a

-- | <a>withConnection</a> should be used to receive a <a>Connection</a>
--   handle for executing queries against the database from within an
--   application monad using Orville. For the "outermost" call of
--   <a>withConnection</a>, a connection will be acquired from the resource
--   pool. Additional calls to <a>withConnection</a> that happen inside the
--   'm a' that uses the connection will return the same <a>Connection</a>
--   the same connection. When the 'm a' finishes the connection will be
--   returned to the pool. If 'm a' throws an exception the pool's
--   exception handling will take effect, generally destroying the
--   connection in case it was the source of the error.
withConnection :: MonadOrville m => (Connection -> m a) -> m a

-- | <a>MonadOrvilleControl</a> presents the interface that Orville will
--   used to lift low-level IO operations that cannot be lifted via
--   <tt>liftIO</tt> (i.e. those where the IO parameter is contravriant
--   rather than covariant).
--   
--   For application monads built using only <a>ReaderT</a> and <a>IO</a>,
--   this can be trivially implemented (or derived), using the
--   <a>ReaderT</a> instance that is provided here. If you monad stack is
--   sufficiently complicated, you may need to use the <tt>unliftio</tt>
--   package as a stepping stone to implementing
--   <a>MonadOrvilleControl</a>. If your monad uses features that
--   <tt>unliftio</tt> cannot support (e.g. the State monad or
--   continuations), then you may need to use 'monad-control' instead.
--   
--   See <a>UnliftIO</a> for functions that can be used as the
--   implementation of the methods below for monads that implement
--   <tt>MonadUnliftIO</tt>.
class MonadOrvilleControl m

-- | Orville will use this function to lift the acquisition of connections
--   from the resource pool into the application monad.
liftWithConnection :: MonadOrvilleControl m => (forall a. (Connection -> IO a) -> IO a) -> (Connection -> m b) -> m b

-- | Orville will use this function to lift exception catches into the
--   application monad.
liftCatch :: (MonadOrvilleControl m, Exception e) => (forall a. IO a -> (e -> IO a) -> IO a) -> m b -> (e -> m b) -> m b

-- | Orville will use this function to lift <tt>mask</tt> calls into the
--   application monad to guarantee resource cleanup is executed even when
--   asynchrouns exceptions are thrown.
liftMask :: MonadOrvilleControl m => (forall b. ((forall a. IO a -> IO a) -> IO b) -> IO b) -> ((forall a. m a -> m a) -> m c) -> m c

-- | <a>HasOrvilleState</a> is the typeclass that Orville uses to access
--   and manange the connection pool and state tracking when it is being
--   executed inside an unknown Monad. It is a specialized version of the
--   Reader interface so that it can easily implemented by application
--   Monads that already have a Reader context and want to simply add
--   <a>OrvilleState</a> as an attribute to that context, like so
--   
--   <pre>
--   data MyApplicationState =
--     MyApplicationState
--       { appConfig :: MyAppConfig
--       , appOrvilleState :: OrvilleState
--       }
--   
--   newtype MyApplicationMonad a =
--     MyApplicationMonad (ReaderT MyApplicationState IO) a
--   
--   instance HasOrvilleState MyApplicationMonad where
--     askOrvilleState =
--       MyApplicationMonad (asks appOrvilleState)
--   
--     localOrvilleState f (MyApplicationMonad reader) =
--       MyApplicationMonad $
--         local
--           (state -&gt; state { appOrvilleState = f (appOrvilleState state))
--           reader
--   
--   </pre>
--   
--   An instance for 'ReaderT OrvilleState m' is provided as a convenience
--   in the case that your application has no extra context to track.
class HasOrvilleState m

-- | Fetches the current <a>OrvilleState</a> from the host Monad context.
--   The equivalent of <a>ask</a> for 'ReaderT OrvilleState'
askOrvilleState :: HasOrvilleState m => m OrvilleState

-- | Applies a modification to the <a>OrvilleState</a> that is local to the
--   given monad operation. Calls to <a>askOrvilleState</a> made within the
--   'm a' provided must return the modified state. The modified state must
--   only apply to the given 'm a' and not persisted beyond it. The
--   equivalent of <a>local</a> for 'ReaderT OrvilleState'
localOrvilleState :: HasOrvilleState m => (OrvilleState -> OrvilleState) -> m a -> m a

-- | <a>OrvilleState</a> is used to manange opening connections to the
--   database, transactions, etc. <a>newOrvilleState</a> should be used to
--   create an appopriate initial state for your monad's context.
data OrvilleState

-- | Creates a appropriate initial <a>OrvilleState</a> that will use the
--   connection pool given to initiate connections to the database.
newOrvilleState :: ErrorDetailLevel -> Pool Connection -> OrvilleState

-- | Creates a new initial <a>OrvilleState</a> using the connection pool
--   from the provide state. You might need to use this if you are spawning
--   one Orville monad from another and they should not share the same
--   connection and transaction state.
resetOrvilleState :: OrvilleState -> OrvilleState

-- | Registers a callback to be invoked during transactions.
--   
--   The callback given will be called after the SQL statement
--   corresponding to the given event has finished executing. Callbacks
--   will be called in the order the are added.
--   
--   Note: There is no specialized error handling for these callbacks. This
--   means that if a callback raises an exception no further callbacks will
--   be called and the exception will propagate up until it caught
--   elsewhere. In particular, if an exception is raised by a callback upon
--   opening the transaction it will cause the transaction to be
--   rolled-back the same as any other exception that might happen during
--   the transaction. In general, we recommend only using callbacks that
--   either raise no exceptions or can handle their own exceptions cleanly.
addTransactionCallback :: (TransactionEvent -> IO ()) -> OrvilleState -> OrvilleState

-- | Describes an event in the lifecycle of a database transaction. You can
--   use <tt>addTransactionCallBack</tt> to register a callback to respond
--   to these events. The callback will be called after the even in
--   question has been succesfully executed.
data TransactionEvent

-- | Indicates a new transaction has been started
BeginTransaction :: TransactionEvent

-- | Indicates that a new savepoint has been saved within a transaction
NewSavepoint :: Savepoint -> TransactionEvent

-- | Indicates that a previous savepoint has been released. It can no
--   longer be rolled back to.
ReleaseSavepoint :: Savepoint -> TransactionEvent

-- | Indicates that rollbac was performed to a prior savepoint.
--   
--   Note: It is possible to rollback to a savepoint prior to the most
--   recent one without releasing or rolling back to intermediate
--   savepoints. Doing so destroys any savepoints created after given
--   savepoint. Although Orville currently always matches
--   <a>NewSavepoint</a> with either <a>ReleaseSavepoint</a> or
--   <a>RollbackToSavepoint</a>, it is recommended that you do not rely on
--   this behavior.
RollbackToSavepoint :: Savepoint -> TransactionEvent

-- | Indicates that the transaction has been committed.
CommitTransaction :: TransactionEvent

-- | Indicates that the transaction has been rolled back.
RollbackTransaction :: TransactionEvent

-- | An internal Orville identifier for a savepoint in a PostgreSQL
--   transaction.
data Savepoint

-- | Adds a callback to be called when an Orville operation executes a SQL
--   statement. The callback is given the IO action that will perform the
--   query execution and must call that action for the query to be run. In
--   particular, you can use this to time query and log any that are slow.
--   
--   Calls to any previously added callbacks will also be execute as part
--   of the IO action passed to the new callback. Thus the newly added
--   callback happens "around" the previously added callback.
--   
--   There is no special exception handling done for these callbacks beyond
--   what they implement themelves. Any callbacks should allow for the
--   possibility that the IO action they are given may raise an exception.
addSqlExecutionCallback :: (forall a. QueryType -> RawSql -> IO a -> IO a) -> OrvilleState -> OrvilleState

-- | Sets the SQL expression that Orville will use to begin transactions.
--   You can control the transaction isolation level by building your own
--   <a>BeginTransactionExpr</a> with the desired isolation level.
setBeginTransactionExpr :: BeginTransactionExpr -> OrvilleState -> OrvilleState

-- | Sets the SqlCommenterAttributes that Orville will then add to any
--   following statement executions.
setSqlCommenterAttributes :: SqlCommenterAttributes -> OrvilleState -> OrvilleState

-- | Adds the SqlCommenterAttributes to the already existing that Orville
--   will then add to any following statement executions.
addSqlCommenterAttributes :: SqlCommenterAttributes -> OrvilleState -> OrvilleState

-- | <a>ErrorDetailLevel</a> provides a means to configure what elements of
--   information are included in error messages that originate from
--   decoding rows queried from the database. This can be specified either
--   my manually rendering the error message and providing the desired
--   configuration, or by setting the desired detail level in the
--   <tt>OrvilleState</tt> as a default.
--   
--   Information will be redacted from error messages for any of the fields
--   that are set to <tt>False</tt>.
data ErrorDetailLevel
ErrorDetailLevel :: Bool -> Bool -> Bool -> Bool -> ErrorDetailLevel
[includeErrorMessage] :: ErrorDetailLevel -> Bool
[includeSchemaNames] :: ErrorDetailLevel -> Bool
[includeRowIdentifierValues] :: ErrorDetailLevel -> Bool
[includeNonIdentifierValues] :: ErrorDetailLevel -> Bool

-- | A default <a>ErrorDetailLevel</a> that strikes balance of including
--   all <a>Generic</a> information such as the error message, schema names
--   and row identifiers, but avoids untentionally leaking non-identifier
--   values from the database by redacting them.
defaultErrorDetailLevel :: ErrorDetailLevel

-- | A minimal <a>ErrorDetailLevel</a> where everything all information
--   (including any situationally-specific error message!) is redacted from
--   error messages.
minimalErrorDetailLevel :: ErrorDetailLevel

-- | A maximal <a>ErrorDetailLevel</a> that redacts no information from the
--   error messages. Error messages will include values from the database
--   for any columns are involved in a decoding failure, including some
--   which you may not have intended to expose through error message. Use
--   with caution.
maximalErrorDetailLevel :: ErrorDetailLevel

-- | Contains the definition of a SQL table for Orville to use for
--   generating queries and marshalling Haskell values to and from the
--   database.
--   
--   <ul>
--   <li><tt>key</tt> is a Haskell type used to indicate whether the table
--   has a primary key and what the type of the key is if so. See
--   <a>HasKey</a> and <a>NoKey</a> for values to be used in this
--   parameter.</li>
--   <li><tt>writeEntity</tt> is the Haskell type for values that Orville
--   will write to the database for you (i.e. both inserts and
--   updates)</li>
--   <li><tt>readEntity</tt> is the Haskell type for values that Orville
--   will decode from the result set when entities are queried from this
--   table.</li>
--   </ul>
data TableDefinition key writeEntity readEntity

-- | Constructs a new <a>TableDefinition</a> with the basic fields required
--   for operation. For convenience, this function accepts a
--   <a>PrimaryKey</a> even though this is not required for all Orville
--   operations to work. If you need to create a table without any primary
--   key, see <a>mkTableDefinitionWithoutKey</a>.
mkTableDefinition :: String -> PrimaryKey key -> SqlMarshaller writeEntity readEntity -> TableDefinition (HasKey key) writeEntity readEntity

-- | Constructs a new <a>TableDefinition</a> with the minimal fields
--   required for operation. Note: tables created via this function will
--   not have a primary key. Certain Orville functions required a primary
--   key. Attempting to call functions requiring a primary key will fail to
--   compile when using a table that has no key.
mkTableDefinitionWithoutKey :: String -> SqlMarshaller writeEntity readEntity -> TableDefinition NoKey writeEntity readEntity

-- | Sets the table's schema to the name in the given string, which will be
--   treated as a SQL identifier. If a table has a schema name set, it will
--   be included as a qualified on the table name for all queries involving
--   the table.
setTableSchema :: String -> TableDefinition key writeEntity readEntity -> TableDefinition key writeEntity readEntity

-- | Retrieves all the table constraints that have been added to the table
--   either via <a>addTableConstraints</a> or that are found on
--   <tt>FieldDefinition</tt>s included with this table's
--   <a>SqlMarshaller</a>.
tableConstraints :: TableDefinition key writeEntity readEntity -> TableConstraints

-- | Adds the given table constraints to the table definition. It's also
--   possible to add constraints that apply to only one column adding them
--   to the <tt>FieldDefinition</tt>s that are included in the table's
--   <a>SqlMarshaller</a>.
--   
--   If you wish to constrain multiple columns with a single constraint
--   (e.g. a multi-column unique constraint), you must use
--   <a>addTableConstraints</a>.
--   
--   Note: If multiple constraints are added with the same
--   <tt>ConstraintMigrationKey</tt>, only the last one that is added will
--   be part of the <a>TableDefinition</a>. Any previously added constraint
--   with the same key is replaced by the new one.
addTableConstraints :: [ConstraintDefinition] -> TableDefinition key writeEntity readEntity -> TableDefinition key writeEntity readEntity

-- | Retrieves all the table indexes that have been added to the table via
--   <a>addTableIndexes</a>.
tableIndexes :: TableDefinition key writeEntity readEntity -> Map IndexMigrationKey IndexDefinition

-- | Adds the given table indexes to the table definition.
--   
--   Note: If multiple indexes are added with the same
--   <a>IndexMigrationKey</a>, only the last one that is added will be part
--   of the <a>TableDefinition</a>. Any previously added index with the
--   same key is replaced by the new one.
addTableIndexes :: [IndexDefinition] -> TableDefinition key writeEntity readEntity -> TableDefinition key writeEntity readEntity

-- | Annotates a <a>TableDefinition</a> with a direction to drop columns if
--   they are found in the database. Orville does not drop columns during
--   auto migration unless they are explicitly requested to be dropped via
--   <a>dropColumns</a>.
--   
--   If you remove a reference to a column from the table's
--   <a>SqlMarshaller</a> without adding the column's name to
--   <a>dropColumns</a>, Orville will operate as if the column does not
--   exist without actually dropping the column. This is often useful if
--   you're not sure you want to lose the data in the column, or if you
--   have zero down-time deployments, which requires the column not be
--   referenced by deployed code before it can be dropped.
dropColumns :: [String] -> TableDefinition key writeEntity readEntity -> TableDefinition key writeEntity readEntity

-- | Returns the set of columns that have be marked be dropped by
--   <a>dropColumns</a>
columnsToDrop :: TableDefinition key writeEntity readEntity -> Set String

-- | Returns the table's <a>TableIdentifier</a>
tableIdentifier :: TableDefinition key writeEntity readEntity -> TableIdentifier

-- | Returns the table's name as an expression that can be used to build
--   SQL statements. If the table has a schema name set, the name will be
--   qualified with it.
tableName :: TableDefinition key writeEntity readEntity -> Qualified TableName

-- | Builds a <a>CreateTableExpr</a> that will create a SQL table matching
--   the given <a>TableDefinition</a> when it is executed.
mkCreateTableExpr :: TableDefinition key writeEntity readEntity -> CreateTableExpr

-- | Builds the <a>ColumnDefinitions</a> for all the fields described by
--   the table definition's <a>SqlMarshaller</a>.
mkTableColumnDefinitions :: TableDefinition key writeEntity readEntity -> [ColumnDefinition]

-- | Builds the <a>PrimaryKeyExpr</a> for this table, or none of this table
--   has no primary key.
mkTablePrimaryKeyExpr :: TableDefinition key writeEntity readEntity -> Maybe PrimaryKeyExpr

-- | Returns the primary key for the table, as defined at construction via
--   <a>mkTableDefinition</a>.
tablePrimaryKey :: TableDefinition (HasKey key) writeEntity readEntity -> PrimaryKey key

-- | Returns the marshaller for the table, as defined at construction via
--   <a>mkTableDefinition</a>.
tableMarshaller :: TableDefinition key writeEntity readEntity -> AnnotatedSqlMarshaller writeEntity readEntity

-- | <a>HasKey</a> is a type with no constructors. It is used only at the
--   type level as the <tt>key</tt> parameter to the <a>TableDefinition</a>
--   type to indicate that the the table has a primary key and what the
--   Haskell type of the primary key is.
data HasKey key

-- | <a>NoKey</a> is a type with no constructors. It is used only at the
--   type level as the <tt>key</tt> parameter to the <a>TableDefinition</a>
--   type to indicate that the the table does not have a primary key.
data NoKey

-- | An identifier used by Orville to identify a particular table in a
--   particular schema.
data TableIdentifier

-- | Constructs a <a>TableIdentifier</a> where the table's name will not be
--   qualified by a particular schema.
unqualifiedNameToTableId :: String -> TableIdentifier

-- | Retrieves the unqualified name of the table as a string.
tableIdUnqualifiedNameString :: TableIdentifier -> String

-- | Returns the 'Expr.Qualified Expr.TableName' that should be used to
--   refer to the table in SQL queries.
tableIdQualifiedName :: TableIdentifier -> Qualified TableName

-- | Sets the schema of the <a>TableIdentifier</a>. Wherever applicable,
--   references to the table will be qualified by the given scheme name.
setTableIdSchema :: String -> TableIdentifier -> TableIdentifier

-- | Retrieves the schema name of the table as a string
tableIdSchemaNameString :: TableIdentifier -> Maybe String

-- | Converts a <a>TableIdentifier</a> for a string for descriptive
--   purposes. The name will be qualified if a schema name has been set for
--   the identifier.
--   
--   Note: You should not use this function for building SQL expressions.
--   Use <a>tableIdQualifiedName</a> instead for that.
tableIdToString :: TableIdentifier -> String

-- | Defines a constraint that can be added to a <a>TableDefinition</a>.
--   Use one of the constructor functions below (such as
--   <a>uniqueConstraint</a>) to construct the constraint definition you
--   wish to have and then use <a>addTableConstraints</a>. to add them to
--   your table definition. Orville will then add the constraint next time
--   you run auto-migrations.
data ConstraintDefinition

-- | Constructs a <a>ConstraintDefinition</a> for a <tt>UNIQUE</tt>
--   constraint on the given columns.
uniqueConstraint :: NonEmpty FieldName -> ConstraintDefinition

-- | Builds a <a>ConstraintDefinition</a> for a <tt>FOREIGN KEY</tt>
--   constraint.
foreignKeyConstraint :: TableIdentifier -> NonEmpty ForeignReference -> ConstraintDefinition

-- | Builds a <a>ConstraintDefinition</a> for a <tt>FOREIGN KEY</tt>
--   constraint, with ON UPDATE and ON DELETE actions.
foreignKeyConstraintWithOptions :: TableIdentifier -> NonEmpty ForeignReference -> ForeignKeyOptions -> ConstraintDefinition

-- | Defines the options for a foreign key constraint. To construct
--   <a>ForeignKeyOptions</a>, perform a record update on
--   <a>defaultForeignKeyOptions</a>.
data ForeignKeyOptions

-- | The <tt>ON DELETE</tt> action for the foreign key
foreignKeyOptionsOnDelete :: ForeignKeyOptions -> ForeignKeyAction

-- | The <tt>ON UPDATE</tt> action for the foreign key
foreignKeyOptionsOnUpdate :: ForeignKeyOptions -> ForeignKeyAction

-- | The default <a>ForeignKeyOptions</a>, containing <a>NoAction</a> for
--   both <a>foreignKeyOptionsOnUpdate</a> and
--   <a>foreignKeyOptionsOnDelete</a>.
defaultForeignKeyOptions :: ForeignKeyOptions

-- | The actions that can be set on <a>ForeignKeyOptions</a>.
data ForeignKeyAction
NoAction :: ForeignKeyAction
Restrict :: ForeignKeyAction
Cascade :: ForeignKeyAction
SetNull :: ForeignKeyAction
SetDefault :: ForeignKeyAction

-- | A <a>ForeignReference</a> represents one part of a foreign key. The
--   entire foreign key may comprise multiple columns. The
--   <a>ForeignReference</a> defines a single column in the key and which
--   column it references in the foreign table.
data ForeignReference
ForeignReference :: FieldName -> FieldName -> ForeignReference
[localFieldName] :: ForeignReference -> FieldName
[foreignFieldName] :: ForeignReference -> FieldName

-- | Constructs a <a>ForeignReference</a>
foreignReference :: FieldName -> FieldName -> ForeignReference

-- | The key used by Orville to determine whether a constraint should be
--   added to a table when performing auto migrations. For most use cases
--   the constructor functions that build a <a>ConstraintDefinition</a>
--   will create this automatically for you.
data ConstraintMigrationKey
ConstraintMigrationKey :: ConstraintKeyType -> Maybe [FieldName] -> Maybe TableIdentifier -> Maybe [FieldName] -> Maybe ForeignKeyAction -> Maybe ForeignKeyAction -> ConstraintMigrationKey
[constraintKeyType] :: ConstraintMigrationKey -> ConstraintKeyType
[constraintKeyColumns] :: ConstraintMigrationKey -> Maybe [FieldName]
[constraintKeyForeignTable] :: ConstraintMigrationKey -> Maybe TableIdentifier
[constraintKeyForeignColumns] :: ConstraintMigrationKey -> Maybe [FieldName]
[constraintKeyForeignKeyOnUpdateAction] :: ConstraintMigrationKey -> Maybe ForeignKeyAction
[constraintKeyForeignKeyOnDeleteAction] :: ConstraintMigrationKey -> Maybe ForeignKeyAction

-- | The kind of constraint that is described by a
--   <a>ConstraintMigrationKey</a> (e.g. unique, foreign key).
data ConstraintKeyType
UniqueConstraint :: ConstraintKeyType
ForeignKeyConstraint :: ConstraintKeyType

-- | Gets the <a>ConstraintMigrationKey</a> for the
--   <a>ConstraintDefinition</a>
constraintMigrationKey :: ConstraintDefinition -> ConstraintMigrationKey

-- | Gets the SQL expression that will be used to add the constraint to the
--   table.
constraintSqlExpr :: ConstraintDefinition -> TableConstraint

-- | Defines an index that can be added to a <a>TableDefinition</a>. Use
--   one of the constructor functions below (such as <a>uniqueIndex</a>) to
--   construct the index definition you wish to have and then use
--   <a>addTableIndexes</a>. to add them to your table definition. Orville
--   will then add the index next time you run auto-migrations.
data IndexDefinition

-- | Constructs an <a>IndexDefinition</a> for a <tt>UNIQUE</tt> index on
--   the given columns.
uniqueIndex :: NonEmpty FieldName -> IndexDefinition

-- | Constructs an <a>IndexDefinition</a> for a non-unique index on the
--   given columns
nonUniqueIndex :: NonEmpty FieldName -> IndexDefinition

-- | Constructs an <a>IndexDefinition</a> for an index on the given columns
--   with the given uniquness.
mkIndexDefinition :: IndexUniqueness -> NonEmpty FieldName -> IndexDefinition

-- | Constructs an <a>IndexDefinition</a> for an index with the given
--   uniqueness, given name, and given SQL.
mkNamedIndexDefinition :: IndexUniqueness -> String -> IndexBodyExpr -> IndexDefinition

-- | Type to represent if an index should be unique.
data IndexUniqueness
UniqueIndex :: IndexUniqueness
NonUniqueIndex :: IndexUniqueness

-- | Gets the SQL expression that will be used to add the index to the
--   specified table.
indexCreateExpr :: IndexDefinition -> Qualified TableName -> CreateIndexExpr

-- | Defines how an <a>IndexDefinition</a> will be execute to add an index
--   to a table. By default all indexes a created via the
--   <a>Transactional</a>
data IndexCreationStrategy

-- | The default strategy. The index will be added as part of the a
--   database transaction along with all the other DDL being executed to
--   migrate the database schema. If any migration should fail the index
--   creation will be rolled back as part of the transaction. This is how
--   schema migrations work in general in Orville.
Transactional :: IndexCreationStrategy

-- | Creates the index asynchronously using the <tt>CONCURRENTLY</tt>
--   keyword in PostgreSQL. Index creation will return immediately and the
--   index will be created in the background by PostgreSQL. Index creation
--   may fail when using the <a>Asynchronous</a> strategy. Orville has no
--   special provision to detect or recover from this failure currently.
--   You should manually check that index creation has succeeded. If
--   necessary, you can manually drop the index to cause Orville to
--   recreate it the next time migrations are run. This is useful when you
--   need to add an index to a very large table because this can lock the
--   table for a long time and cause an application to fail health checks
--   at startup if migrations do not finish quickly enough. You should
--   familiarize youself with how concurrent index creation works in
--   PostgreSQL before using this. See
--   <a>https://www.postgresql.org/docs/current/sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY</a>
Asynchronous :: IndexCreationStrategy

-- | Sets the <a>IndexCreationStrategy</a> strategy to be used when
--   creating the index described by the <a>IndexDefinition</a>. By default
--   all indexes are created using the <a>Transactional</a> strategy, but
--   some tables are too large for for this to be feasible. See the
--   <a>Asynchronous</a> creation strategy for how to work around this.
setIndexCreationStrategy :: IndexCreationStrategy -> IndexDefinition -> IndexDefinition

-- | Gets the <a>IndexCreationStrategy</a> strategy to be used when
--   creating the index described by the <a>IndexDefinition</a>. By default
--   all indexes are created using the <a>Transactional</a> strategy.
indexCreationStrategy :: IndexDefinition -> IndexCreationStrategy

-- | A Haskell description of the <a>FieldDefinition</a>s that make up the
--   primary key of a SQL table. This type supports composite primary keys
--   as well as singular ones.
data PrimaryKey key

-- | <a>primaryKey</a> constructs a single-field primary key from the
--   <a>FieldDefinition</a> that corresponds to the primary key's column.
--   This is generally used while building a <tt>TableDefinition</tt>.
primaryKey :: FieldDefinition NotNull key -> PrimaryKey key

-- | <a>compositePrimaryKey</a> constructs a multi-field primary key from
--   the given parts, each of which corresponds to one field in the primary
--   key. You should use this while building a <tt>TableDefinition</tt> for
--   a table that you want to have a multi-column primary key. See
--   <a>primaryKeyPart</a> for how to build the parts to be passed as
--   parameters. Note: there is no special significance to the first
--   argument other than requiring that there is at least one field in the
--   primary key.
compositePrimaryKey :: PrimaryKeyPart key -> [PrimaryKeyPart key] -> PrimaryKey key

-- | <a>primaryKeyPart</a> constructs a building block for a composite
--   primary key based a <a>FieldDefinition</a> and an accessor function to
--   extract the value for that field from the Haskell <tt>key</tt> type
--   that represents the overall composite key. <a>PrimaryKeyPart</a>
--   values built using this function are usually then passed in a list to
--   <a>compositePrimaryKey</a> to build a <a>PrimaryKey</a>.
primaryKeyPart :: (key -> part) -> FieldDefinition NotNull part -> PrimaryKeyPart key

-- | <a>SqlMarshaller</a> is how we group the lowest level translation of
--   single fields into a higher level marshalling of full sql records into
--   Haskell records. This is a flexible abstraction that allows us to
--   ultimately model SQL tables and work with them as potentially nested
--   Haskell records. We can then "marshall" the data as we want to model
--   it in sql and Haskell.
data SqlMarshaller a b

-- | An <a>AnnotatedSqlMarshaller</a> is a <a>SqlMarshaller</a> that
--   contains extra annotations cannot necessarily be determined from the
--   data in the marshaller itself. In particular, it includes the names of
--   fields that be used to identify a row in the database when an error is
--   encoutered during decoding.
--   
--   Normally you will not need to interact with this type directly -- the
--   <tt>TableDefinition</tt> type creates it for you using the information
--   it has about the primary key of table to identify rows in decoding
--   errors. If you are executing custom queries directly, you may need to
--   annotate a raw <a>SqlMarshaller</a> yourself so that rows can be
--   identified. See <a>annotateSqlMarshaller</a> and
--   <a>annotateSqlMarshallerEmptyAnnotation</a>.
data AnnotatedSqlMarshaller writeEntity readEntity

-- | Creates an <a>AnnotatedSqlMarshaller</a> that will use the given
--   column names to identify rows in error messages when decoding fails.
--   Any column names in the list that are not present in the result set
--   will simply be omitted from the error message.
annotateSqlMarshaller :: [FieldName] -> SqlMarshaller writeEntity readEntity -> AnnotatedSqlMarshaller writeEntity readEntity

-- | Creates an <a>AnnotatedSqlMarshaller</a> that will identify rows in
--   decoding errors by any columns. This is the equivalent of
--   <tt>annotateSqlMarshaller []</tt>.
annotateSqlMarshallerEmptyAnnotation :: SqlMarshaller writeEntity readEntity -> AnnotatedSqlMarshaller writeEntity readEntity
unannotatedSqlMarshaller :: AnnotatedSqlMarshaller writeEntity readEntity -> SqlMarshaller writeEntity readEntity

-- | Applies the provided function to a <a>SqlMarshaller</a> that has been
--   annotated, preserving the annotations.
mapSqlMarshaller :: (SqlMarshaller readEntityA writeEntityA -> SqlMarshaller readEntityB writeEntityB) -> AnnotatedSqlMarshaller readEntityA writeEntityA -> AnnotatedSqlMarshaller readEntityB writeEntityB

-- | Builds a <a>SqlMarshaller</a> that maps a single field of a Haskell
--   entity to a single column in the database. That value to store in the
--   database will be retried from the entity using provided accessor
--   function. This function is intended to be used inside of a stanza of
--   <a>Applicative</a> syntax that will pass values read from the database
--   a constructor function to rebuild the entity containing the field,
--   like so:
--   
--   <pre>
--   data Foo = Foo { bar :: Int32, baz :: Text }
--   
--   fooMarshaller :: SqlMarshaller Foo Foo
--   fooMarshaller =
--     Foo
--       <a>$</a> marshallField bar (integerField "bar")
--       <a>*</a> marshallField baz (unboundedTextField "baz")
--   
--   
--   </pre>
marshallField :: (writeEntity -> fieldValue) -> FieldDefinition nullability fieldValue -> SqlMarshaller writeEntity fieldValue

-- | Nests a <a>SqlMarshaller</a> inside another, using the given accesser
--   to retrieve value to be marshalled. The resulting marshaller can then
--   be used in the same way as <a>marshallField</a> within the applicative
--   syntax of a larger marshaller.
--   
--   For Example:
--   
--   <pre>
--   data Person =
--     Person
--       { personId :: PersonId
--       , personName :: Name
--       }
--   
--   data Name =
--     Name
--       { firstName :: T.Text
--       , lastName :: T.Text
--       }
--   
--   personMarshaller :: SqlMarshaller Person Person
--   personMarshaller =
--     Person
--       <a>$</a> marshallField personId personIdField
--       <a>*</a> marshallNested personName nameMarshaller
--   
--   nameMarshaller :: SqlMarshaller Name Name
--   nameMarshaller =
--     Name
--       <a>$</a> marshallField firstName firstNameField
--       <a>*</a> marshallField lastName lastNameField
--   
--   </pre>
marshallNested :: (parentEntity -> nestedWriteEntity) -> SqlMarshaller nestedWriteEntity nestedReadEntity -> SqlMarshaller parentEntity nestedReadEntity

-- | Builds a <a>SqlMarshaller</a> that will include a SQL expression in
--   select statements to calculate a value the columns of the table being
--   selected from. The columns being used in the calculation do not
--   themselves need to be selected, though they must be present in the
--   table so they can be referenced.
--   
--   <pre>
--   data AgeCheck
--     { atLeast21 :: Bool
--     }
--   
--   fooMarshaller :: SqlMarshaller Void AgeCheck
--   fooMarshaller =
--     AgeCheck
--       <a>*</a> Orville.marshallSyntheticField atLeast21Field
--   
--   atLeast21Field :: SyntheticField Bool
--   atLeast21Field =
--     SyntheticField
--       { syntheticFieldExpression = RawSql.unsafeSqlExpression "age &gt;= 21"
--       , syntheticFieldAlias = Orville.stringToFieldName "over21"
--       , syntheticFieldValueFromSqlValue = SqlValue.toBool
--       }
--   
--   </pre>
marshallSyntheticField :: SyntheticField fieldValue -> SqlMarshaller writeEntity fieldValue

-- | Marks a <a>SqlMarshaller</a> as ready only so that it will not attempt
--   to read any values from the <tt>writeEntity</tt>. You should use this
--   if you have a group of fields which are populated by database rather
--   than the application.
marshallReadOnly :: SqlMarshaller a b -> SqlMarshaller c b

-- | A version of <a>marshallField</a> that uses <a>marshallReadOnly</a> to
--   make a single read only field. You will usually use this in conjuction
--   with a <a>FieldDefinition</a> like <tt>serialField</tt> where the
--   valuue is populated by the database.
marshallReadOnlyField :: FieldDefinition nullability fieldValue -> SqlMarshaller writeEntity fieldValue

-- | Builds a <a>SqlMarshaller</a> that will raise a decoding error when
--   the value produced is a <a>Left</a>.
marshallPartial :: SqlMarshaller a (Either String b) -> SqlMarshaller a b

-- | Lifts a <a>SqlMarshaller</a> to have both read/write entities be
--   <a>Maybe</a>, and applies a tag to avoid double mapping.
marshallMaybe :: SqlMarshaller a b -> SqlMarshaller (Maybe a) (Maybe b)

-- | Adds a prefix, followed by an underscore, to the names of all of the
--   fields and synthetic fields in a <a>SqlMarshaller</a>.
prefixMarshaller :: String -> SqlMarshaller readEntity writeEntity -> SqlMarshaller readEntity writeEntity

-- | <a>foldMarshallerFields</a> allows you to consume the
--   <a>FieldDefinition</a>s that are contained within the
--   <a>SqlMarshaller</a> to process them however is required. This can be
--   used to collect the names of all the fields, encode them to
--   <tt>SqlValue</tt>, etc.
foldMarshallerFields :: SqlMarshaller writeEntity readEntity -> result -> (MarshallerField writeEntity -> result -> result) -> result

-- | A fold function that can be used with <a>foldMarshallerFields</a> to
--   collect a value calculated from a <a>FieldDefinition</a> via the given
--   function. The calculated value is added to the list of values being
--   built.
--   
--   Note: Folds executed with <a>collectFromField</a> ignore
--   <a>Synthetic</a> entries in the marshaller. You should only use
--   <a>collectFromField</a> in situations where you only care about the
--   actual columns referenced by the marshaller.
collectFromField :: ReadOnlyColumnOption -> (forall nullability a. FieldDefinition nullability a -> result) -> MarshallerField entity -> [result] -> [result]

-- | Specifies whether read-only fields should be included when using
--   functions such as <a>collectFromField</a> and
--   <tt>marshallerColumnNames</tt>.
data ReadOnlyColumnOption
IncludeReadOnlyColumns :: ReadOnlyColumnOption
ExcludeReadOnlyColumns :: ReadOnlyColumnOption

-- | A <a>SyntheticField</a> can be used to evaluate a SQL expression based
--   on the columns of a table when records are selected from the database.
--   Synthetic fields are inherently read-only.
data SyntheticField a

-- | Returns the SQL expression that should be in with select statements to
--   calculated the sythetic field.
syntheticFieldExpression :: SyntheticField a -> ValueExpression

-- | Returns the alias that should be used in select statements to name the
--   the synthetic field.
syntheticFieldAlias :: SyntheticField a -> FieldName

-- | Decodes a calculated value selected from the database to its expected
--   Haskell type. Returns a <a>Left</a> with an error message if the
--   decoding fails.
syntheticFieldValueFromSqlValue :: SyntheticField a -> SqlValue -> Either String a

-- | Constructs a <a>SyntheticField</a> that will select a SQL expression
--   using the given alias.
syntheticField :: ValueExpression -> String -> (SqlValue -> Either String a) -> SyntheticField a

-- | Modifies a <a>SyntheticField</a> to allow it to decode <tt>NULL</tt>
--   values.
nullableSyntheticField :: SyntheticField a -> SyntheticField (Maybe a)

-- | Adds a prefix, followed by an underscore, to the alias used to name
--   the synthetic field.
prefixSyntheticField :: String -> SyntheticField a -> SyntheticField a

-- | <a>FieldDefinition</a> determines the SQL constsruction of a column in
--   the database, comprising the name, SQL type and whether the field is
--   nullable. A <a>FieldDefinition</a> is matched to a particular Haskell
--   type, which it knows how to marshall to and from the database
--   representation of SQL type for the field.
data FieldDefinition nullability a

-- | <a>NotNull</a> is a values-less type used to track that a
--   <a>FieldDefinition</a> represents a field that is marked not-null in
--   the database schema. See the <tt>Nullability</tt> type for the
--   value-level representation of field nullability.
data NotNull

-- | <a>Nullable</a> is a values-less type used to track that a
--   <a>FieldDefinition</a> represents a field that is marked nullable in
--   the database schema. See the <tt>Nullability</tt> type for the
--   value-level representation of field nullability.
data Nullable

-- | Makes a <a>NotNull</a> field <a>Nullable</a> by wrapping the Haskell
--   type of the field in <a>Maybe</a>. The field will be marked as
--   <tt>NULL</tt> in the database schema and the value <a>Nothing</a> will
--   be used to represent <tt>NULL</tt> values when converting to and from
--   sql.
nullableField :: FieldDefinition NotNull a -> FieldDefinition Nullable (Maybe a)

-- | Adds a <a>Maybe</a> wrapper to a field that is already nullable. (If
--   your field is <a>NotNull</a>, you wanted <a>nullableField</a> instead
--   of this function). Note that fields created using this function have
--   asymetric encoding and decoding of <tt>NULL</tt> values. Because the
--   provided field is <a>Nullable</a>, <tt>NULL</tt> values decode from
--   the database already have a representation in the <tt>a</tt> type, so
--   <tt>NULL</tt> will be decoded as 'Just <a>of type a for NULL</a>'.
--   This means if you insert a <a>Nothing</a> value using the field, it
--   will be read back as <a>Just</a> value. This is useful for building
--   high level combinators that might need to make fields <a>Nullable</a>
--   but need the value to be decoded in its underlying type when reading
--   back (e.g. <tt>maybeMapper</tt> from <tt>SqlMarshaller</tt>).
asymmetricNullableField :: FieldDefinition Nullable a -> FieldDefinition Nullable (Maybe a)

-- | Applies a <a>SqlType</a> conversion to a <a>FieldDefinition</a>. You
--   can use this function the create <a>FieldDefinition</a>s for based on
--   the primitive ones provided, but with more specific Haskell types.
--   
--   See <a>convertSqlType</a> and <a>tryConvertSqlType</a> for functions
--   to create the conversion needed as the first argument to
--   <a>convertField</a>.
convertField :: (SqlType a -> SqlType b) -> FieldDefinition nullability a -> FieldDefinition nullability b

-- | A specialization of <a>convertField</a> that can be used with types
--   that implement <a>Coercible</a>. This is particularly useful for
--   newtype wrappers around primitive types.
coerceField :: (Coercible a b, Coercible b a) => FieldDefinition nullability a -> FieldDefinition nullability b

-- | Sets a default value for the field. The default value will be added as
--   part of the column definition in the database. Because the default
--   value is ultimately provided by the database this can be used to add a
--   not-null column to safely to an existing table as long as a reasonable
--   default value is available to use.
setDefaultValue :: DefaultValue a -> FieldDefinition nullability a -> FieldDefinition nullability a

-- | Removes any default value that may have been set on a field via
--   <tt>setDefaultValue</tt>.
removeDefaultValue :: FieldDefinition nullability a -> FieldDefinition nullability a

-- | Adds a prefix, followed by an underscore, to a field's name.
prefixField :: String -> FieldDefinition nullability a -> FieldDefinition nullability a

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Int32</a>
--   values as the PostgreSQL <a>INT</a> type.
integerField :: String -> FieldDefinition NotNull Int32

-- | Builds a <a>FieldDefinition</a> that stores an <a>Int32</a> value as
--   the <a>SERIAL</a> type. This can be used to create auto-incrementing
--   columns.
serialField :: String -> FieldDefinition NotNull Int32

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Int16</a>
--   values as the PostgreSQL <a>SMALLINT</a> type.
smallIntegerField :: String -> FieldDefinition NotNull Int16

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>UUID</a> values
--   as the PostgreSQL <a>UUID</a> type.
uuidField :: String -> FieldDefinition NotNull UUID

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Int64</a>
--   values as the PostgreSQL <a>BIGINT</a> type.
bigIntegerField :: String -> FieldDefinition NotNull Int64

-- | Builds a <a>FieldDefinition</a> that stores an <a>Int64</a> value as
--   the <a>BIGSERIAL</a> type. This can be used to create
--   auto-incrementing columns.
bigSerialField :: String -> FieldDefinition NotNull Int64

-- | Builds a <a>FieldDefinition</a> that stores a <a>Double</a> value as
--   the "DOUBLE PRECISION" type. Note: PostgreSQL's "DOUBLE PRECISION"
--   type only allows for up to 15 digits of precision, so some rounding
--   may occur when values are stored in the database.
doubleField :: String -> FieldDefinition NotNull Double

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Bool</a> values
--   as the PostgreSQL <a>BOOLEAN</a> type.
booleanField :: String -> FieldDefinition NotNull Bool

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Text</a> values
--   as the PostgreSQL <a>TEXT</a> type. Note that this PostgreSQL has no
--   particular limit on the length of text stored.
unboundedTextField :: String -> FieldDefinition NotNull Text

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Text</a> values
--   as the PostgreSQL <a>VARCHAR</a> type. Attempting to store a value
--   beyond the length specified will cause an error.
boundedTextField :: String -> Int32 -> FieldDefinition NotNull Text

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Text</a> values
--   as the PostgreSQL <a>CHAR</a> type. Attempting to store a value beyond
--   the length specified will cause an error. Storing a value that is not
--   the full length of the field will result in padding by the database.
fixedTextField :: String -> Int32 -> FieldDefinition NotNull Text

-- | Builds a <tt>FieldDefinition</tt> that stores PostgreSQL text search
--   vector values. The values are represented as Haskell <a>Text</a>
--   values, but are interpreted as text search vector values by PostgreSQL
--   when passed to it.
--   
--   See
--   <a>https://www.postgresql.org/docs/current/datatype-textsearch.html</a>
--   for information about how PostgreSQL creates <tt>tsvector</tt> values
--   from strings.
textSearchVectorField :: String -> FieldDefinition NotNull Text

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Day</a> values
--   as the PostgreSQL <a>DATE</a> type.
dateField :: String -> FieldDefinition NotNull Day

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>UTCTime</a>
--   values as the PostgreSQL "TIMESTAMP with time zone" type.
utcTimestampField :: String -> FieldDefinition NotNull UTCTime

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>UTCTime</a>
--   values as the PostgreSQL "TIMESTAMP without time zone" type.
localTimestampField :: String -> FieldDefinition NotNull LocalTime

-- | Builds a <a>FieldDefinition</a> that stores Haskell <a>Text</a> values
--   as the PostgreSQL <a>JSONB</a> type.
jsonbField :: String -> FieldDefinition NotNull Text

-- | Builds a <a>FieldDefinition</a> for will use the given
--   <tt>SqlType</tt> to determine the database representation of the
--   field. If you have created a custom <tt>SqlType</tt>, you can use this
--   function to construct a helper like the other functions in this module
--   for creating <a>FieldDefinition</a>s for your custom type.
fieldOfType :: SqlType a -> String -> FieldDefinition NotNull a

-- | Constructs the <a>ColumnName</a> for a field for use in SQL
--   expressions from the <tt>Expr</tt> module.
fieldColumnName :: FieldDefinition nullability a -> ColumnName

-- | Constructs the 'Expr.ValueExpression for a field for use in SQL
--   expressions from the <tt>Expr</tt> module.
fieldColumnReference :: FieldDefinition nullability a -> ValueExpression

-- | The name used in database queries to reference the field.
fieldName :: FieldDefinition nullability a -> FieldName

-- | Returns the description that was passed to <a>setFieldDescription</a>,
--   if any.
fieldDescription :: FieldDefinition nullability a -> Maybe String

-- | Sets the description for the field. This description not currently
--   used anywhere by Orville itself, but users can retrieve the
--   description via <a>fieldDescription</a> for their own purposes (e.g.
--   generating documentation).
setFieldDescription :: String -> FieldDefinition nullability a -> FieldDefinition nullability a

-- | Adds a <tt>UNIQUE</tt> constraint to the <a>FieldDefinition</a>. This
--   constraint will be included on any table that uses the field
--   definition.
addUniqueConstraint :: FieldDefinition nullability a -> FieldDefinition nullability a

-- | Adds a <tt>FOREIGN KEY</tt> constraint to the <a>FieldDefinition</a>
--   (using <a>addFieldTableConstraints</a>). This constraint will be
--   included on any table that uses the field definition.
addForeignKeyConstraint :: TableIdentifier -> FieldName -> FieldDefinition nullability a -> FieldDefinition nullability a

-- | A simple type to represent the name of a field.
data FieldName

-- | Constructs a <a>FieldName</a> from a <a>String</a>
stringToFieldName :: String -> FieldName

-- | Converts a <a>FieldName</a> back to a <a>String</a>
fieldNameToString :: FieldName -> String

-- | Convert a field name to an <a>ColumnName</a> for usage in SQL
--   expressions. The field name will be properly quoted and escaped.
fieldNameToColumnName :: FieldName -> ColumnName

-- | Converts a <a>FieldName</a> back to a <a>ByteString</a>
fieldNameToByteString :: FieldName -> ByteString

-- | The <tt>SqlType</tt> for the <a>FieldDefinition</a> determines the
--   PostgreSQL data type used to define the field as well as how to
--   mashall Haskell values to and from the database.
fieldType :: FieldDefinition nullability a -> SqlType a

-- | Returns the default value definition for the field, if any has been
--   set.
fieldDefaultValue :: FieldDefinition nullability a -> Maybe (DefaultValue a)

-- | Constructions the equivalant <a>FieldDefinition</a> as a SQL
--   expression, generally for use in DDL for creating column in a table.
fieldColumnDefinition :: FieldDefinition nullability a -> ColumnDefinition

-- | Indicates whether a field is nullable.
fieldIsNotNullable :: FieldDefinition nullability a -> Bool

-- | Resolves the <tt>nullablity</tt> of a field to a concrete type, which
--   is returned via the <a>FieldNullability</a> type. You can pattern
--   match on this type to then extract the either <a>Nullable</a> or
--   <a>NotNull</a> not field for cases where you may require different
--   logic based on the nullability of a field.
fieldNullability :: FieldDefinition nullability a -> FieldNullability a

-- | Constructs a <a>SetClause</a> that will set the column named in the
--   field definition to the given value. The value is be converted to SQL
--   value using <a>fieldValueToSqlValue</a>
setField :: FieldDefinition nullability a -> a -> SetClause

-- | Operator alias for <a>setField</a>
(.:=) :: FieldDefinition nullability a -> a -> SetClause

-- | A <a>FieldNullability</a> is returned by the <a>fieldNullability</a>
--   function, which can be used when a function works on both
--   <a>Nullable</a> and <a>NotNull</a> functions but needs to deal with
--   each type of field separately. It adds wrapper constructors around the
--   <a>FieldDefinition</a> that you can pattern match on to then work with
--   a concrete <a>Nullable</a> or <a>NotNull</a> field.
data FieldNullability a
NullableField :: FieldDefinition Nullable a -> FieldNullability a
NotNullField :: FieldDefinition NotNull a -> FieldNullability a

-- | A <a>DefaultValue</a> is a SQL expression that can be attached to a
--   field definition to give a default value for a column at the database
--   level. The default value will be used if an insert is done and the
--   column is not provided.
--   
--   This is useful if you want to add a new column to a table that is
--   already in production without breaking a previous version of your
--   application that is running (e.g. during a zero-down-time deployment)
--   and without needing to make the new column nullable. Default values
--   can also be used to create database-assigned values such as using
--   'now()' to set a <tt>created_at</tt> column on a row automatically in
--   the database.
data DefaultValue a

-- | Builds a default value from an <a>Int32</a> for use with integer
--   fields.
--   
--   This is a specialization of <a>integerDefault</a>.
integerDefault :: Int32 -> DefaultValue Int32

-- | Builds a default value from an <a>Int16</a> for use with small integer
--   fields.
--   
--   This is a specialization of <a>integerDefault</a>.
smallIntegerDefault :: Int16 -> DefaultValue Int16

-- | Builds a default value from an <a>Int16</a> for use with big integer
--   fields.
--   
--   This is a specialization of <a>integerDefault</a>.
bigIntegerDefault :: Int64 -> DefaultValue Int64

-- | Builds a default value for any <a>Integral</a> type <tt>n</tt> by
--   converting it an <a>Integer</a>.
integralDefault :: Integral n => n -> DefaultValue n

-- | Builds a default value from a <a>Double</a> field with double fields.
doubleDefault :: Double -> DefaultValue Double

-- | Builds a default value from a <a>Bool</a>, for use with boolean
--   fields.
booleanDefault :: Bool -> DefaultValue Bool

-- | Builds a default value from a <a>Text</a>, for use with unbounded,
--   bounded and fixed-length text fields.
textDefault :: Text -> DefaultValue Text

-- | Builds a default value from a <a>Day</a> for use with date fields.
dateDefault :: Day -> DefaultValue Day

-- | Builds a default value that will default to the current date (i.e. the
--   date at which the database populates the default value on a given
--   row).
--   
--   For use with date fields.
currentDateDefault :: DefaultValue Day

-- | Builds a default value from a <a>UTCTime</a> for use with utc
--   timestamp fields.
utcTimestampDefault :: UTCTime -> DefaultValue UTCTime

-- | Builds a default value that will default to the current utc time (i.e.
--   the time at which the database populates the default value on a given
--   row).
--   
--   For use with utc timestamp fields.
currentUTCTimestampDefault :: DefaultValue UTCTime

-- | Builds a default value from a <a>LocalTime</a> for use with local
--   timestamp fields.
localTimestampDefault :: LocalTime -> DefaultValue LocalTime

-- | Builds a default value that will default to the current local time
--   (i.e. the time at which the database populates the default value on a
--   given row).
--   
--   Note: "local" time here will be determined by the database itself,
--   subject to whatever timezone offset has been configured in its
--   settings.
--   
--   For use with local timestamp fields.
currentLocalTimestampDefault :: DefaultValue LocalTime

-- | Coerce's a <a>DefaultValue</a> so that it can be used with field
--   definitions of a different Haskell type. The coercion will always
--   succeed, and is safe as far as Haskell itself it concerned. As long as
--   the <a>DefaultValue</a> is used with a column whose database type is
--   the same as the one the <a>DefaultValue</a> was originally intended
--   for, everything will work as expected.
coerceDefaultValue :: DefaultValue a -> DefaultValue b

-- | Returns database value expression for the default value
defaultValueExpression :: DefaultValue a -> ValueExpression

-- | Constructs a default value from a <tt>ValueExpression</tt>. You can
--   use this to construct default values for any SQL expression that
--   Orville does not support directly.
--   
--   Note: If you are using auto migrations, the <a>ValueExpression</a>
--   that you pass here must match what is returned by the PostgreSQL
--   <tt>pg_get_expr</tt> function. <tt>pg_get_expr</tt> decompiles the
--   compiled version of the default experssion back to source text,
--   sometimes in non-obvious ways. Orville's auto migration compares
--   expression given in the field definition with the decompiled
--   expression from the database to determine whether the default value
--   needs to be updated in the schema or not. If the expression given by a
--   <a>DefaultValue</a> is logically equivalent but does not match the
--   decompiled form, auto migration will continue to execute SQL
--   statements to update the schema even when it does not need to.
rawSqlDefault :: ValueExpression -> DefaultValue a

-- | A <a>SelectOptions</a> is a set of options that can be used to change
--   the way a basic query function works by adding <tt>WHERE</tt>, 'ORDER
--   BY', 'GROUP BY', etc. Functions are provided to construct
--   <a>SelectOptions</a> for individual options, which may then be
--   combined via <a>&lt;&gt;</a> (also exposed as
--   <a>appendSelectOptions</a>).
data SelectOptions

-- | Constructs a <a>SelectOptions</a> with just <a>distinct</a> set to
--   <a>True</a>.
distinct :: SelectOptions

-- | Constructs a <a>SelectOptions</a> with just the given
--   <tt>GroupByClause</tt>.
groupBy :: GroupByExpr -> SelectOptions

-- | Constructs a <a>SelectOptions</a> that will apply the given limit.
limit :: Int -> SelectOptions

-- | Constructs a <a>SelectOptions</a> that will apply the given offset.
offset :: Int -> SelectOptions

-- | Constructs a <a>SelectOptions</a> with just the given
--   <a>OrderByExpr</a>.
orderBy :: OrderByExpr -> SelectOptions

-- | Constructs a <a>SelectOptions</a> with just the given
--   <tt>WhereCondition</tt>.
where_ :: BooleanExpr -> SelectOptions

-- | A set of empty <a>SelectOptions</a> that will not change how a query
--   is run.
emptySelectOptions :: SelectOptions

-- | Combines multple select options together, unioning the options
--   together where possible. For options where this is not possible, (e.g.
--   <tt>LIMIT</tt>), the one on the left is preferred.
appendSelectOptions :: SelectOptions -> SelectOptions -> SelectOptions

-- | Checks that the value in a field equals a particular value.
fieldEquals :: FieldDefinition nullability a -> a -> BooleanExpr

-- | Operator alias for <a>fieldEquals</a>
(.==) :: FieldDefinition nullability a -> a -> BooleanExpr
infixl 9 .==

-- | Checks that the value in a field does not equal a particular value.
fieldNotEquals :: FieldDefinition nullability a -> a -> BooleanExpr

-- | Operator alias for <a>fieldNotEquals</a>
(./=) :: FieldDefinition nullability a -> a -> BooleanExpr
infixl 9 ./=

-- | Checks that the value in a field is greater than a particular value.
fieldGreaterThan :: FieldDefinition nullability a -> a -> BooleanExpr

-- | Operator alias for <a>fieldGreaterThan</a>
(.>) :: FieldDefinition nullability a -> a -> BooleanExpr
infixl 9 .>

-- | Checks that the value in a field is less than a particular value.
fieldLessThan :: FieldDefinition nullability a -> a -> BooleanExpr

-- | Operator alias for <a>fieldLessThan</a>
(.<) :: FieldDefinition nullability a -> a -> BooleanExpr
infixl 9 .<

-- | Checks that the value in a field is greater than or equal to a
--   particular value.
fieldGreaterThanOrEqualTo :: FieldDefinition nullability a -> a -> BooleanExpr

-- | Operator alias for <a>fieldGreaterThanOrEqualTo</a>
(.>=) :: FieldDefinition nullability a -> a -> BooleanExpr
infixl 9 .>=

-- | Checks that the value in a field is less than or equal to a particular
--   value.
fieldLessThanOrEqualTo :: FieldDefinition nullability a -> a -> BooleanExpr

-- | Operator alias for <a>fieldLessThanOrEqualTo</a>
(.<=) :: FieldDefinition nullability a -> a -> BooleanExpr
infixl 9 .<=

-- | Checks that the value in a field matches a like pattern
fieldLike :: FieldDefinition nullability a -> Text -> BooleanExpr

-- | Checks that the value in a field matches a like pattern case
--   insensitively
fieldLikeInsensitive :: FieldDefinition nullability a -> Text -> BooleanExpr

-- | Checks that the value in a field is null.
fieldIsNull :: FieldDefinition Nullable a -> BooleanExpr

-- | Checks that the value in a field is not null.
fieldIsNotNull :: FieldDefinition Nullable a -> BooleanExpr

-- | Checks that a field matches a list of values
fieldIn :: FieldDefinition nullability a -> NonEmpty a -> BooleanExpr

-- | Operator alias for <a>fieldIn</a>
(.<-) :: FieldDefinition nullability a -> NonEmpty a -> BooleanExpr
infixl 9 .<-

-- | Checks that a field does not match a list of values
fieldNotIn :: FieldDefinition nullability a -> NonEmpty a -> BooleanExpr

-- | Operator alias for <a>fieldNotIn</a>
(.</-) :: FieldDefinition nullability a -> NonEmpty a -> BooleanExpr
infixl 9 .</-

-- | Checks that a tuple of two fields is in the list of specified tuplies
fieldTupleIn :: FieldDefinition nullabilityA a -> FieldDefinition nullabilityB b -> NonEmpty (a, b) -> BooleanExpr

-- | Checks that a tuple of two fields is not in the list of specified
--   tuplies
fieldTupleNotIn :: FieldDefinition nullabilityA a -> FieldDefinition nullabilityB b -> NonEmpty (a, b) -> BooleanExpr

-- | Type to represent a SQL order by direction expression. E.G.
--   
--   <pre>
--   ASC
--   </pre>
--   
--   <a>OrderByDirection</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data OrderByDirection

-- | Type to represent the ordering of Null, intended to be used with
--   <a>OrderByDirection</a>.
data NullsOrder
NullsFirst :: NullsOrder
NullsLast :: NullsOrder

-- | The SQL ASC order direction.
ascendingOrder :: OrderByDirection

-- | The SQL ASC order direction with NULLs ordered as given.
ascendingOrderWith :: NullsOrder -> OrderByDirection

-- | The SQL DESC order direction.
descendingOrder :: OrderByDirection

-- | The SQL DESC order direction with NULLs ordered as given.
descendingOrderWith :: NullsOrder -> OrderByDirection
orderByField :: FieldDefinition nullability value -> OrderByDirection -> OrderByExpr
orderByColumnName :: ColumnName -> OrderByDirection -> OrderByExpr

-- | The SQL <tt>AND</tt> operator. The arguments will be surrounded with
--   parentheses to ensure that the associativity of expression in the
--   resulting SQL matches the associtivity implied by this Haskell
--   function.
andExpr :: BooleanExpr -> BooleanExpr -> BooleanExpr

-- | The SQL <tt>OR</tt> operator. The arguments will be surrounded with
--   parentheses to ensure that the associativity of expression in the
--   resulting SQL matches the associtivity implied by this Haskell
--   function.
orExpr :: BooleanExpr -> BooleanExpr -> BooleanExpr

-- | The SQL <tt>AND</tt> operator (alias for <a>andExpr</a>)
(.&&) :: BooleanExpr -> BooleanExpr -> BooleanExpr
infixr 8 .&&

-- | The SQL <tt>OR</tt> operator (alias for <a>orExpr</a>)
(.||) :: BooleanExpr -> BooleanExpr -> BooleanExpr
infixr 8 .||

-- | Builds the <a>GroupByClause</a> that should be used to include the
--   <tt>GroupByClause</tt>s from the <a>SelectOptions</a> on a query. This
--   will be <a>Nothing</a> where no <tt>GroupByClause</tt>s have been
--   specified.
selectGroupByClause :: SelectOptions -> Maybe GroupByClause

-- | Builds the <a>OrderByClause</a> that should be used to include the
--   <tt>OrderByClause</tt>s from the <a>SelectOptions</a> on a query. This
--   will be <a>Nothing</a> where no <tt>OrderByClause</tt>s have been
--   specified.
selectOrderByClause :: SelectOptions -> Maybe OrderByClause

-- | Builds the <a>WhereClause</a> that should be used to include the
--   <tt>WhereCondition</tt>s from the <a>SelectOptions</a> on a query.
--   This will be <a>Nothing</a> where no <tt>WhereCondition</tt>s have
--   been specified.
selectWhereClause :: SelectOptions -> Maybe WhereClause

-- | Builds the <a>SelectClause</a> that should be used to include the
--   <a>distinct</a>s from the <a>SelectOptions</a> on a query.
selectDistinct :: SelectOptions -> SelectClause

-- | Fetches the next value from a sequence via the PostgreSQL
--   <tt>nextval</tt> function.
sequenceNextValue :: MonadOrville m => SequenceDefinition -> m Int64

-- | Fetches the current value from a sequence via the PostgreSQL
--   <tt>currval</tt> function.
sequenceCurrentValue :: MonadOrville m => SequenceDefinition -> m Int64

-- | Sets the current value from a sequence via the PostgreSQL
--   <tt>setval</tt> function.
sequenceSetValue :: MonadOrville m => SequenceDefinition -> Int64 -> m Int64

-- | Contains the definition of a SQL sequence for Orville to use when
--   creating the sequence and fetching values from it. You can create a
--   <a>SequenceDefinition</a> with default values via
--   <a>mkSequenceDefinition</a> and then use the various set functions
--   that are provided if you need to set specific attributes on the
--   sequence.
data SequenceDefinition

-- | Constructs an ascending <a>SequenceDefinition</a> with increment 1 and
--   cache 1 that does not cycle. The sequence will start at 1 and count to
--   the largest <a>Int64</a> value.
mkSequenceDefinition :: String -> SequenceDefinition

-- | Sets the sequence's schema to the name in the given string, which will
--   be treated as a SQL identifier. If a sequence has a schema name set,
--   it will be included as a qualified on the sequence name for all
--   queries involving the sequence.
setSequenceSchema :: String -> SequenceDefinition -> SequenceDefinition

-- | Retrieves the <a>SequenceIdentifier</a> for this sequence, which is
--   set by the name provided to <a>mkSequenceDefinition</a> and any calls
--   make to <a>setSequenceSchema</a> thereafter.
sequenceIdentifier :: SequenceDefinition -> SequenceIdentifier

-- | Retrieves the <a>Qualified</a> <a>SequenceName</a> for the sequence
--   that should be used to build SQL expressions involving it.
sequenceName :: SequenceDefinition -> Qualified SequenceName

-- | Retrieves the increment value for the sequence.
sequenceIncrement :: SequenceDefinition -> Int64

-- | Sets the increment value for the sequence. The increment cannot be set
--   to <tt>0</tt> (PostgreSQL will raise an error when trying to create or
--   modify the sequence in this case).
--   
--   If the increment is negative the sequence will be descending. When no
--   explicit start is set a descending sequence begins at the max value.
setSequenceIncrement :: Int64 -> SequenceDefinition -> SequenceDefinition

-- | Retrieves the min value of the sequence. If no explicit minimum has
--   been set this returns <tt>1</tt> for ascending sequences and
--   <a>minBound</a> for <a>Int64</a> for descending sequences.
sequenceMinValue :: SequenceDefinition -> Int64

-- | Sets the min value for the sequence.
setSequenceMinValue :: Int64 -> SequenceDefinition -> SequenceDefinition

-- | Retrieves the max value of the sequence. If no explicit maximum has
--   been set this returns <a>maxBound</a> for <a>Int64</a> for ascending
--   sequences and <tt>-1</tt> descending sequences.
sequenceMaxValue :: SequenceDefinition -> Int64

-- | Sets the max value for the sequence.
setSequenceMaxValue :: Int64 -> SequenceDefinition -> SequenceDefinition

-- | Retrieves the start value for the sequence. If no explicit start value
--   has been set this returns <a>sequenceMinValue</a> for ascending
--   sequences and <a>sequenceMaxValue</a> for descending sequences.
sequenceStart :: SequenceDefinition -> Int64

-- | Sets the sequence start value. The start value must be at least the
--   minimum value and no greater than the max value.
setSequenceStart :: Int64 -> SequenceDefinition -> SequenceDefinition

-- | Retrieves the number of sequence values that will be pre-allocated by
--   PostgreSQL.
sequenceCache :: SequenceDefinition -> Int64

-- | Sets the number of sequence values that will be pre-allocated by
--   PostgreSQL.
setSequenceCache :: Int64 -> SequenceDefinition -> SequenceDefinition

-- | Indicates whether the sequence will wrap around when it reaches the
--   maximum value (for ascending sequences) or minimum value (for
--   descending sequences). When <a>False</a>, any attempts to get the next
--   value of the sequence while at the limit will result in an error.
sequenceCycle :: SequenceDefinition -> Bool

-- | Sets the <a>sequenceCycle</a> value for the sequence. <a>True</a>
--   indicates that the sequence will cycle. <a>False</a> will cause an
--   error to be raised if the next sequence value is requested while
--   already at the limit.
setSequenceCycle :: Bool -> SequenceDefinition -> SequenceDefinition

-- | Builds a <a>CreateSequenceExpr</a> that will create a SQL sequence
--   matching the given <a>SequenceDefinition</a> when it is executed.
mkCreateSequenceExpr :: SequenceDefinition -> CreateSequenceExpr

-- | An identifier used by Orville to identify a particular sequence in a
--   particular schema.
data SequenceIdentifier

-- | Constructs a <a>SequenceIdentifier</a> where the sequence's name will
--   not be qualified by a particular schema.
unqualifiedNameToSequenceId :: String -> SequenceIdentifier

-- | Retrieves the unqualified name of the sequence as a string.
sequenceIdUnqualifiedNameString :: SequenceIdentifier -> String

-- | Returns the 'Expr.Qualified Expr.SequenceName' that should be used to
--   refer to the sequence in SQL queries.
sequenceIdQualifiedName :: SequenceIdentifier -> Qualified SequenceName

-- | Sets the schema of the <a>SequenceIdentifier</a>. Wherever applicable,
--   references to the sequence will be qualified by the given scheme name.
setSequenceIdSchema :: String -> SequenceIdentifier -> SequenceIdentifier

-- | Retrieves the schema name of the sequence as a string
sequenceIdSchemaNameString :: SequenceIdentifier -> Maybe String

-- | Converts a <a>SequenceIdentifier</a> for a string for descriptive
--   purposes. The name will be qualified if a schema name has been set for
--   the identifier.
--   
--   Note: You should not use this function for building SQL expressions.
--   Use <a>sequenceIdQualifiedName</a> instead for that.
sequenceIdToString :: SequenceIdentifier -> String

-- | <a>integer</a> defines a 32-bit integer type. This corresponds to the
--   <a>INTEGER</a> type in SQL.
integer :: SqlType Int32

-- | <a>serial</a> defines a 32-bit auto-incrementing column type. This
--   corresponds to the <a>SERIAL</a> type in PostgreSQL.
serial :: SqlType Int32

-- | <a>bigInteger</a> defines a 64-bit integer type. This corresponds to
--   the <a>BIGINT</a> type in SQL.
bigInteger :: SqlType Int64

-- | <a>bigSerial</a> defines a 64-bit auto-incrementing column type. This
--   corresponds to the <a>BIGSERIAL</a> type in PostgresSQL.
bigSerial :: SqlType Int64

-- | <a>double</a> defines a floating point numeric type. This corresponds
--   to the "DOUBLE PRECISION" type in SQL.
double :: SqlType Double

-- | <a>boolean</a> defines a True/False boolean type. This corresponds to
--   the <a>BOOLEAN</a> type in SQL.
boolean :: SqlType Bool

-- | <a>unboundedText</a> defines a unbounded length text field type. This
--   corresponds to a <a>TEXT</a> type in PostgreSQL.
unboundedText :: SqlType Text

-- | <a>fixedText</a> defines a fixed length text field type. This
--   corresponds to a "CHAR(len)" type in PostgreSQL.
fixedText :: Int32 -> SqlType Text

-- | <a>boundedText</a> defines a variable length text field type. This
--   corresponds to a "VARCHAR(len)" type in PostgreSQL.
boundedText :: Int32 -> SqlType Text

-- | <a>textSearchVector</a> defines a type for indexed text searching. It
--   corresponds to the <a>TSVECTOR</a> type in PostgreSQL.
textSearchVector :: SqlType Text

-- | <a>uuid</a> defines a UUID type. It corresponds to the <a>UUID</a>
--   type in PostgreSQL.
uuid :: SqlType UUID

-- | <a>date</a> defines a type representing a calendar date (without time
--   zone). It corresponds to the <a>DATE</a> type in SQL.
date :: SqlType Day

-- | <a>timestamp</a> defines a type representing a particular point in
--   time without time zone information, but can be constructed with a time
--   zone offset. It corresponds to the "TIMESTAMP with time zone" type in
--   SQL.
--   
--   Note: This is NOT a typo. The "TIMESTAMP with time zone" type in SQL
--   does not include any actual time zone information. For an excellent
--   explanation of the complexities involving this type, please see Chris
--   Clark's blog post about it:
--   <a>http://blog.untrod.com/2016/08/actually-understanding-timezones-in-postgresql.html</a>
timestamp :: SqlType UTCTime

-- | <a>jsonb</a> represents any type that can be converted To and From
--   JSON. This corresponds to the <a>JSONB</a> type in PostgreSQL.
jsonb :: SqlType Text

-- | <a>foreignRefType</a> creates a <a>SqlType</a> suitable for columns
--   will be foreign keys referencing a column of the given <a>SqlType</a>.
--   For most types the underlying sql type with be identical, but for
--   special types (such as autoincrementing primary keys), the type
--   construted by <a>foreignRefType</a> with have regular underlying sql
--   type. Each <a>SqlType</a> definition must specify any special handling
--   required when creating foreign reference types by setting the
--   <a>sqlTypeReferenceExpr</a> field to an appropriate value.
foreignRefType :: SqlType a -> SqlType a

-- | <a>convertSqlType</a> changes the Haskell type used by a
--   <a>SqlType</a> in the same manner as <a>tryConvertSqlType</a> in cases
--   where an <tt>a</tt> can always be converted to a <tt>b</tt>.
convertSqlType :: (b -> a) -> (a -> b) -> SqlType a -> SqlType b

-- | <a>tryConvertSqlType</a> changes the Haskell type used by a
--   <a>SqlType</a> which changing the column type that will be used in the
--   database schema. The functions given will be used to convert the now
--   Haskell type to and from the original type when reading and writing
--   values from the database. When reading an <tt>a</tt> value from the
--   database, the conversion function should produce 'Left with an error
--   message if the value cannot be successfully converted to a <tt>b</tt>
tryConvertSqlType :: (b -> a) -> (a -> Either String b) -> SqlType a -> SqlType b

-- | SqlType defines the mapping of a Haskell type (<tt>a</tt>) to a SQL
--   column type in the database. This includes both how to convert the
--   type to and from the raw values read from the database as well as the
--   schema information required to create and migrate columns using the
--   type.
data SqlType a
SqlType :: DataType -> Maybe DataType -> Oid -> Maybe Int32 -> (a -> SqlValue) -> (SqlValue -> Either String a) -> Bool -> SqlType a

-- | The sql data type expression to use when creating/migrating columns of
--   this type
[sqlTypeExpr] :: SqlType a -> DataType

-- | The sql data type experession to use when creating/migrating columns
--   with foreign keys to this type. This is used foreignRefType to build a
--   new SqlType when making foreign key fields
[sqlTypeReferenceExpr] :: SqlType a -> Maybe DataType

-- | The Oid for the type in postgresql. This will be used during
--   migrations to determine whether the column type needs to be altered.
[sqlTypeOid] :: SqlType a -> Oid

-- | The maximum length for lengths that take a type parameter (such as
--   <tt>char</tt> and <tt>varchar</tt>). This will be used during
--   migration to determine whether the column type needs to be altered.
[sqlTypeMaximumLength] :: SqlType a -> Maybe Int32

-- | A function for converting Haskell values of this type into values to
--   be stored in the database.
[sqlTypeToSql] :: SqlType a -> a -> SqlValue

-- | A function for converting values of this are stored in the database
--   into Haskell values. This function should return <a>Nothing</a> to
--   indicate an error if the conversion is impossible. Otherwise it should
--   return <a>Just</a> the corresponding <tt>a</tt> value.
[sqlTypeFromSql] :: SqlType a -> SqlValue -> Either String a

-- | The SERIAL and BIGSERIAL PostgreSQL types are really pesudo types that
--   create an implicit default value. This flag tells Orville's auto
--   migration logic to ignore the default value rather than drop it as it
--   normally would.
[sqlTypeDontDropImplicitDefaultDuringMigrate] :: SqlType a -> Bool

-- | Type to represent a SQL query, E.G.
--   
--   <pre>
--   SELECT id FROM some_table
--   </pre>
--   
--   <a>QueryExpr</a> provides a <a>SqlExpression</a> instance. See
--   <a>unsafeSqlExpression</a> for how to construct a value with your own
--   custom SQL.
data QueryExpr

-- | Executes a SQL query and decodes the result set using the provided
--   marshaller. Any SQL Execution callbacks that have been added to the
--   <a>OrvilleState</a> will be called.
--   
--   If the query fails or if any row is unable to be decoded by the
--   marshaller, an exception will be raised.
executeAndDecode :: (MonadOrville m, SqlExpression sql) => QueryType -> sql -> AnnotatedSqlMarshaller writeEntity readEntity -> m [readEntity]

-- | Executes a SQL query and returns the number of rows affected by the
--   query. Any SQL Execution callbacks that have been added to the
--   <a>OrvilleState</a> will be called.
--   
--   This function can only be used for the execution of a SELECT, CREATE
--   TABLE AS, INSERT, UPDATE, DELETE, MOVE, FETCH, or COPY statement, or
--   an EXECUTE of a prepared query that contains an INSERT, UPDATE, or
--   DELETE statement. If the query is anything else an
--   <a>AffectedRowsDecodingError</a> wil be raised after the query is
--   executed when the result is read.
--   
--   If the query fails an exception will be raised.
executeAndReturnAffectedRows :: (MonadOrville m, SqlExpression sql) => QueryType -> sql -> m Int

-- | Executes a SQL query and ignores the result. Any SQL Execution
--   callbacks that have been added to the <a>OrvilleState</a> will be
--   called.
--   
--   If the query fails an exception will be raised.
executeVoid :: (MonadOrville m, SqlExpression sql) => QueryType -> sql -> m ()

-- | A simple categorization of SQL queries that is used to provide a hint
--   to user callbacks about what kind of query is being run.
--   
--   See <a>addSqlExecutionCallback</a>
data QueryType
SelectQuery :: QueryType
InsertQuery :: QueryType
UpdateQuery :: QueryType
DeleteQuery :: QueryType
DDLQuery :: QueryType
OtherQuery :: QueryType

-- | The representation of <a>Text</a> key/value pairs for supporting the
--   sqlcommenter specification. This allows you to attach key/values of
--   <a>Text</a> that supporting systems can use for advanced metrics. See
--   <a>sqlcommenter</a> for details of the specification.
type SqlCommenterAttributes = Map Text Text


module Orville.PostgreSQL.PgCatalog

-- | The Haskell representation of data read from the
--   <tt>pg_catalog.pg_sequence</tt> table. Rows in this table sequences in
--   PostgreSQL.
data PgSequence
PgSequence :: Oid -> Oid -> Int64 -> Int64 -> Int64 -> Int64 -> Int64 -> Bool -> PgSequence

-- | The PostgreSQL <tt>oid</tt> of the <tt>pg_class</tt> for this sequence
[pgSequenceClassOid] :: PgSequence -> Oid

-- | The PostgreSQL <tt>oid</tt> of the data type of the sequence.
--   References <tt>pg_type.oid</tt>
[pgSequenceTypeOid] :: PgSequence -> Oid

-- | The start value of the sequence
[pgSequenceStart] :: PgSequence -> Int64

-- | The increment value of the sequence
[pgSequenceIncrement] :: PgSequence -> Int64

-- | The max value of the sequence
[pgSequenceMax] :: PgSequence -> Int64

-- | The max value of the sequence
[pgSequenceMin] :: PgSequence -> Int64

-- | The cache size of the sequence
[pgSequenceCache] :: PgSequence -> Int64

-- | Wether the sequence cycles
[pgSequenceCycle] :: PgSequence -> Bool

-- | An Orville <a>TableDefinition</a> for querying the
--   <tt>pg_catalog.pg_sequence</tt> table
pgSequenceTable :: TableDefinition (HasKey Oid) PgSequence PgSequence

-- | The <tt>seqrelid</tt> column of the <tt>pg_cataglog.pg_sequence</tt>
--   table
sequencePgClassOidField :: FieldDefinition NotNull Oid

-- | The Haskell representation of data read from the
--   <tt>pg_catalog.pg_namespace</tt> table. Namespaces in
--   <tt>pg_catalog</tt> correspond to "schema" concept in database
--   organization.
data PgNamespace
PgNamespace :: Oid -> NamespaceName -> PgNamespace

-- | The PostgreSQL <tt>oid</tt> for the namespace. This is referenced from
--   other tables, such as <tt>pg_class</tt>.
[pgNamespaceOid] :: PgNamespace -> Oid

-- | The name of the namespace.
[pgNamespaceName] :: PgNamespace -> NamespaceName

-- | A Haskell type for the name of a namespace
data NamespaceName

-- | Convert a 'NamespaceName to a plain <a>String</a>
namespaceNameToString :: NamespaceName -> String

-- | An Orville <a>TableDefinition</a> for querying the
--   <tt>pg_catalog.pg_namespace</tt> table
pgNamespaceTable :: TableDefinition (HasKey Oid) PgNamespace PgNamespace

-- | The <tt>nspname</tt> column of the <tt>pg_catalog.pg_namespace</tt>
--   table
namespaceNameField :: FieldDefinition NotNull NamespaceName

-- | The Haskell representation of data read from the
--   <tt>pg_catalog.pg_index</tt> tale. Rows in this table contain extended
--   information about indices. Information about indices is also contained
--   in the <tt>pg_catalog.pg_class</tt> table as well.
data PgIndex
PgIndex :: Oid -> Oid -> [AttributeNumber] -> Bool -> Bool -> Bool -> PgIndex

-- | The PostgreSQL <tt>oid</tt> of the <tt>pg_class</tt> entry for this
--   index.
[pgIndexPgClassOid] :: PgIndex -> Oid

-- | The PostgreSQL <tt>oid</tt> of the <tt>pg_class</tt> entry for the
--   table that this index is for.
[pgIndexRelationOid] :: PgIndex -> Oid

-- | An array of attribute numbers references the columns the table that
--   are included in the index. An attribute number of <tt>0</tt> indicates
--   an expression over the table's columns rather than just a reference to
--   a column.
--   
--   In PostgreSQL 11+ this includes both key columns and non-key included
--   columns. Orville is currently not aware of this distinction, however.
[pgIndexAttributeNumbers] :: PgIndex -> [AttributeNumber]

-- | Indicates whether this is a unique index
[pgIndexIsUnique] :: PgIndex -> Bool

-- | Indicates whether this is the primary key index for the table
[pgIndexIsPrimary] :: PgIndex -> Bool

-- | When <tt>False</tt>, indicates that this index is in the process of
--   being dropped and should be ignored
[pgIndexIsLive] :: PgIndex -> Bool

-- | An Orville <a>TableDefinition</a> for querying the
--   <tt>pg_catalog.pg_index</tt> table
pgIndexTable :: TableDefinition NoKey PgIndex PgIndex

-- | The <tt>indrelid</tt> column of the <tt>pg_index</tt> table
indexRelationOidField :: FieldDefinition NotNull Oid

-- | The <tt>indislive</tt> column of the <tt>pg_index</tt> table
indexIsLiveField :: FieldDefinition NotNull Bool

-- | The Haskell representation of data read from the
--   <tt>pg_catalog.pg_constraint</tt> tale. Rows in this table correspond
--   to check, primary key, unique, foreign key and exclusion constraints
--   on tables.
data PgConstraint
PgConstraint :: Oid -> ConstraintName -> Oid -> ConstraintType -> Oid -> Oid -> Maybe [AttributeNumber] -> Oid -> Maybe [AttributeNumber] -> Maybe ForeignKeyAction -> Maybe ForeignKeyAction -> PgConstraint

-- | The PostgreSQL <tt>oid</tt> for the constraint
[pgConstraintOid] :: PgConstraint -> Oid

-- | The constraint name (which may not be unique)
[pgConstraintName] :: PgConstraint -> ConstraintName

-- | The oid of the namespace that contains the constraint
[pgConstraintNamespaceOid] :: PgConstraint -> Oid

-- | The type of constraint
[pgConstraintType] :: PgConstraint -> ConstraintType

-- | The PostgreSQL <tt>oid</tt> of the table that the constraint is on (or
--   <tt>0</tt> if not a table constraint)
[pgConstraintRelationOid] :: PgConstraint -> Oid

-- | The PostgreSQL <tt>oid</tt> ef the index supporting this constraint,
--   if it's a unique, primary key, foreign key or exclusion constraint.
--   Otherwise <tt>0</tt>.
[pgConstraintIndexOid] :: PgConstraint -> Oid

-- | For table constraints, the attribute numbers of the constrained
--   columns. These correspond to the <tt>pgAttributeNumber</tt> field of
--   <tt>PgAttribute</tt>.
[pgConstraintKey] :: PgConstraint -> Maybe [AttributeNumber]

-- | For foreign key constraints, the PostgreSQL <tt>oid</tt> of the table
--   the foreign key references
[pgConstraintForeignRelationOid] :: PgConstraint -> Oid

-- | For foreignkey constraints, the attribute numbers of the referenced
--   columns. These correspond to the <tt>pgAttributeNumber</tt> field of
--   <tt>PgAttribute</tt>.
[pgConstraintForeignKey] :: PgConstraint -> Maybe [AttributeNumber]

-- | For foreignkey constraints, the on update action type
[pgConstraintForeignKeyOnUpdateType] :: PgConstraint -> Maybe ForeignKeyAction

-- | For foreignkey constraints, the on delete action type
[pgConstraintForeignKeyOnDeleteType] :: PgConstraint -> Maybe ForeignKeyAction

-- | The type of constraint that a <a>PgConstraint</a> represents, as
--   described at
--   <a>https://www.postgresql.org/docs/13/catalog-pg-constraint.html</a>
data ConstraintType
CheckConstraint :: ConstraintType
ForeignKeyConstraint :: ConstraintType
PrimaryKeyConstraint :: ConstraintType
UniqueConstraint :: ConstraintType
ConstraintTrigger :: ConstraintType
ExclusionConstraint :: ConstraintType

-- | A Haskell type for the name of the constraint represented by a
--   <a>PgConstraint</a>
data ConstraintName

-- | Converts an <a>ConstraintName</a> to a plain old string
constraintNameToString :: ConstraintName -> String

-- | An Orville <a>TableDefinition</a> for querying the
--   <tt>pg_catalog.pg_constraint</tt> table
pgConstraintTable :: TableDefinition (HasKey Oid) PgConstraint PgConstraint

-- | The <tt>conrelid</tt> column of the <tt>pg_constraint</tt> table
constraintRelationOidField :: FieldDefinition NotNull Oid

-- | The Haskell representation of data read from the
--   <tt>pg_catalog.pg_class</tt> table. Rows in this table correspond to
--   tables, indexes, sequences, views, materialized views, composite types
--   and TOAST tables.
data PgClass
PgClass :: Oid -> Oid -> RelationName -> RelationKind -> PgClass

-- | The PostgreSQL <tt>oid</tt> for the relation
[pgClassOid] :: PgClass -> Oid

-- | The PostgreSQL <tt>oid</tt> of the namespace that the relation belongs
--   to. References <tt>pg_namespace.oid</tt>.
[pgClassNamespaceOid] :: PgClass -> Oid

-- | The name of relation
[pgClassRelationName] :: PgClass -> RelationName

-- | The kind of relation (table, view, etc)
[pgClassRelationKind] :: PgClass -> RelationKind

-- | A Haskell type for the name of the relation represented by a
--   <a>PgClass</a>
data RelationName

-- | Convert a <a>RelationName</a> to a plain <a>String</a>
relationNameToString :: RelationName -> String

-- | The kind of relation represented by a <a>PgClass</a>, as described at
--   <a>https://www.postgresql.org/docs/13/catalog-pg-class.html</a>.
data RelationKind
OrdinaryTable :: RelationKind
Index :: RelationKind
Sequence :: RelationKind
ToastTable :: RelationKind
View :: RelationKind
MaterializedView :: RelationKind
CompositeType :: RelationKind
ForeignTable :: RelationKind
PartitionedTable :: RelationKind
PartitionedIndex :: RelationKind

-- | An Orville <a>TableDefinition</a> for querying the
--   <tt>pg_catalog.pg_class</tt> table
pgClassTable :: TableDefinition (HasKey Oid) PgClass PgClass

-- | The <tt>relname</tt> column of the <tt>pg_catalog.pg_class</tt> table
relationNameField :: FieldDefinition NotNull RelationName

-- | The <tt>relnamespace</tt> column of the <tt>pg_catalog.pg_class</tt>
--   table
namespaceOidField :: FieldDefinition NotNull Oid

-- | The <tt>relkind</tt> column of the <tt>pg_catalog.pg_class</tt> table
relationKindField :: FieldDefinition NotNull RelationKind

-- | The Haskell representation of data read from the
--   <tt>pg_catalog.pg_attrdef</tt> table.
data PgAttributeDefault
PgAttributeDefault :: Oid -> Oid -> AttributeNumber -> Text -> PgAttributeDefault

-- | The PostgreSQL <tt>oid</tt> for the default value
[pgAttributeDefaultOid] :: PgAttributeDefault -> Oid

-- | The PostgreSQL <tt>oid</tt> for the relation that this attribute
--   belongs to. References <tt>pg_class.oid</tt>
[pgAttributeDefaultRelationOid] :: PgAttributeDefault -> Oid

-- | The PostgreSQL attribute number for the column that this default
--   belongs to. References <tt>pg_attribute.attnum</tt>.
[pgAttributeDefaultAttributeNumber] :: PgAttributeDefault -> AttributeNumber

-- | The PostgreSQL default value expression, as decompiled from the
--   <tt>adbin</tt> column using the PostgreSQL <tt>pg_get_expr</tt>
--   function.
[pgAttributeDefaultExpression] :: PgAttributeDefault -> Text

-- | An Orville <a>TableDefinition</a> for querying the
--   <tt>pg_catalog.pg_attrdef</tt> table
pgAttributeDefaultTable :: TableDefinition NoKey PgAttributeDefault PgAttributeDefault

-- | The <tt>adrelid</tt> column of the <tt>pg_catalog.pg_attrdef</tt>
--   table
attributeDefaultRelationOidField :: FieldDefinition NotNull Oid

-- | The Haskell representation of data read from the
--   <tt>pg_catalog.pg_attribute</tt> table. Rows in this table correspond
--   to table columns, but also for attributes of other items from the
--   <tt>pg_class</tt> table.
--   
--   See also <a>PgClass</a>.
data PgAttribute
PgAttribute :: Oid -> AttributeName -> AttributeNumber -> Oid -> Int16 -> Int32 -> Bool -> Bool -> PgAttribute

-- | The PostgreSQL <tt>oid</tt> for the relation that this attribute
--   belongs to. References <tt>pg_class.oid</tt>
[pgAttributeRelationOid] :: PgAttribute -> Oid

-- | The name of attribute
[pgAttributeName] :: PgAttribute -> AttributeName

-- | The PostgreSQL number of attribute
[pgAttributeNumber] :: PgAttribute -> AttributeNumber

-- | The PostgreSQL <tt>oid</tt> for the type of this attribute. References
--   <tt>pg_type.oid</tt>
[pgAttributeTypeOid] :: PgAttribute -> Oid

-- | The length of this attributes type (a copy of
--   <tt>pg_type.typlen</tt>). Note that this is _NOT_ the maximum length
--   of a <tt>varchar</tt> column!
[pgAttributeLength] :: PgAttribute -> Int16

-- | Type-specific data supplied at creation time, such as the maximum
--   length of a <tt>varchar</tt> column
[pgAttributeTypeModifier] :: PgAttribute -> Int32

-- | Indicates whether the column has been dropped and is not longer valid
[pgAttributeIsDropped] :: PgAttribute -> Bool

-- | Indicates whether the column has a not-null constraint
[pgAttributeIsNotNull] :: PgAttribute -> Bool

-- | Returns the maximum length for an attribute with a variable length
--   type, or <a>Nothing</a> if the length if the type is not variable.
pgAttributeMaxLength :: PgAttribute -> Maybe Int32

-- | A Haskell type for the name of the attribute represented by a
--   <a>PgAttribute</a>
data AttributeName

-- | Converts an <a>AttributeName</a> to a plain old string
attributeNameToString :: AttributeName -> String

-- | A Haskell type for the number of the attribute represented by a
--   <a>PgAttribute</a>
data AttributeNumber

-- | Converts an <a>AttributeNumber</a> to an integer
attributeNumberToInt16 :: AttributeNumber -> Int16

-- | Converts an integer to an <a>AttributeNumber</a>
attributeNumberFromInt16 :: Int16 -> AttributeNumber

-- | Encodes an <a>AttributeNumber</a> to lazy text as a builder
attributeNumberTextBuilder :: AttributeNumber -> Builder

-- | Attoparsec parser for <a>AttributeNumber</a>
attributeNumberParser :: Parser AttributeNumber

-- | Determines whether the attribute represents a system column by
--   inspecting the attribute's <a>AttributeNumber</a>. Ordinary columns
--   have attribute numbers starting at 1.
isOrdinaryColumn :: PgAttribute -> Bool

-- | An Orville <a>TableDefinition</a> for querying the
--   <tt>pg_catalog.pg_attribute</tt> table
pgAttributeTable :: TableDefinition NoKey PgAttribute PgAttribute

-- | The <tt>attrelid</tt> column of the <tt>pg_catalog.pg_attribute</tt>
--   table
attributeRelationOidField :: FieldDefinition NotNull Oid

-- | The <tt>attname</tt> column of the <tt>pg_catalog.pg_attribute</tt>
--   table
attributeNameField :: FieldDefinition NotNull AttributeName

-- | The <tt>atttypid</tt> column of the <tt>pg_catalog.pg_attribute</tt>
--   table
attributeTypeOidField :: FieldDefinition NotNull Oid

-- | The <tt>attlen</tt> column of the <tt>pg_catalog.pg_attribute</tt>
--   table
attributeLengthField :: FieldDefinition NotNull Int16

-- | The <tt>attisdropped</tt> column of the
--   <tt>pg_catalog.pg_attribute</tt> table
attributeIsDroppedField :: FieldDefinition NotNull Bool

-- | Builds a <a>FieldDefinition</a> for a field with type
--   <a>AttributeNumber</a>
attributeNumberTypeField :: String -> FieldDefinition NotNull AttributeNumber

-- | The <tt>oid</tt> field found on many (but not all!)
--   <tt>pg_catalog</tt> tables
oidField :: FieldDefinition NotNull Oid

-- | Builds a <a>FieldDefinition</a> with the given column name that stores
--   an <tt>oid</tt> value.
oidTypeField :: String -> FieldDefinition NotNull Oid

-- | A description of selected items from a single PostgreSQL database.
--   <a>describeDatabaseRelations</a> can be used to load the descriptions
--   of request items.
data DatabaseDescription
DatabaseDescription :: Map (NamespaceName, RelationName) RelationDescription -> DatabaseDescription
[databaseRelations] :: DatabaseDescription -> Map (NamespaceName, RelationName) RelationDescription

-- | A description of a particular relation in the PostgreSQL database,
--   including the attributes of the relation.
data RelationDescription
RelationDescription :: PgClass -> Map AttributeName PgAttribute -> Map AttributeNumber PgAttributeDefault -> [ConstraintDescription] -> [IndexDescription] -> Maybe PgSequence -> RelationDescription
[relationRecord] :: RelationDescription -> PgClass
[relationAttributes] :: RelationDescription -> Map AttributeName PgAttribute
[relationAttributeDefaults] :: RelationDescription -> Map AttributeNumber PgAttributeDefault
[relationConstraints] :: RelationDescription -> [ConstraintDescription]
[relationIndexes] :: RelationDescription -> [IndexDescription]
[relationSequence] :: RelationDescription -> Maybe PgSequence

-- | A description of a particular constraint in the PostgreSQL database,
--   including the attributes and relations that it references.
data ConstraintDescription
ConstraintDescription :: PgConstraint -> Maybe [PgAttribute] -> Maybe ForeignRelationDescription -> Maybe [PgAttribute] -> ConstraintDescription
[constraintRecord] :: ConstraintDescription -> PgConstraint
[constraintKey] :: ConstraintDescription -> Maybe [PgAttribute]
[constraintForeignRelation] :: ConstraintDescription -> Maybe ForeignRelationDescription
[constraintForeignKey] :: ConstraintDescription -> Maybe [PgAttribute]

-- | A description of a relation in the PostgreSQL database that is
--   referenced by a foreign key constraint, including the namespace that
--   the relation belongs to.
data ForeignRelationDescription
ForeignRelationDescription :: PgClass -> PgNamespace -> ForeignRelationDescription
[foreignRelationClass] :: ForeignRelationDescription -> PgClass
[foreignRelationNamespace] :: ForeignRelationDescription -> PgNamespace

-- | A description of an index in the PostgreSQL database, including the
--   names of the attributes included in the index and the <a>PgClass</a>
--   record of the index itself (NOT the <a>PgClass</a> of the table that
--   the index is for).
data IndexDescription
IndexDescription :: PgIndex -> PgClass -> [IndexMember] -> IndexDescription
[indexRecord] :: IndexDescription -> PgIndex
[indexPgClass] :: IndexDescription -> PgClass
[indexMembers] :: IndexDescription -> [IndexMember]

-- | A description of an index member in the PostgreSQL database. If they
--   member is a simple attribute, the <a>PgAttribute</a> for that is
--   provided. If it is an index over an expression, no further description
--   is currently provided.
data IndexMember
IndexAttribute :: PgAttribute -> IndexMember
IndexExpression :: IndexMember

-- | Lookup a relation by its qualified name in the <tt>pg_catalog</tt>
--   schema.
lookupRelation :: (NamespaceName, RelationName) -> DatabaseDescription -> Maybe RelationDescription

-- | Lookup a relation by its qualified name in the <tt>pg_catalog</tt>
--   schema. If the relation is not of the expected kind, <a>Nothing</a> is
--   returned.
lookupRelationOfKind :: RelationKind -> (NamespaceName, RelationName) -> DatabaseDescription -> Maybe RelationDescription

-- | Find an attribute by name from the <a>RelationDescription</a>
lookupAttribute :: AttributeName -> RelationDescription -> Maybe PgAttribute

-- | Find an attribute default from the <a>RelationDescription</a>
lookupAttributeDefault :: PgAttribute -> RelationDescription -> Maybe PgAttributeDefault

-- | Describes the requested relations in the current database. If any of
--   the relations do not exist, they will not have an entry in the
--   returned description.
--   
--   Each <a>RelationDescription</a> will contain all the attributes that
--   currently exist for that relation, according to the
--   <tt>pg_catalog</tt> tables.
describeDatabaseRelations :: MonadOrville m => [(NamespaceName, RelationName)] -> m DatabaseDescription


-- | Facilities for performing some database migrations automatically. See
--   <a>autoMigrateSchema</a> as a primary, high level entry point.
module Orville.PostgreSQL.AutoMigration

-- | This function compares the list of <a>SchemaItem</a>s provided against
--   the current schema found in the database to determine whether any
--   migration are necessary. If any changes need to be made, this function
--   executes. You can call <a>generateMigrationPlan</a> and
--   <a>executeMigrationPlan</a> yourself if you want to have more control
--   over the process, but must then take care to ensure that the schema
--   has not changed between the two calls. This function uses an
--   PostgreSQL advisory lock to ensure that no other calls to
--   <a>autoMigrateSchema</a> (potentially on other processes) attempt to
--   modify the schema at the same time.
autoMigrateSchema :: MonadOrville m => [SchemaItem] -> m ()

-- | A <a>SchemaItem</a> represents a single item in a database schema such
--   as a table, index or constraint. The constructor functions below can
--   be used to create items from other types (such as
--   <a>TableDefinition</a>) to put them into a list to be used with
--   <a>autoMigrateSchema</a>.
data SchemaItem

-- | Constructs a <a>SchemaItem</a> from a <a>TableDefinition</a>. @since
--   1.0.0.0
[SchemaTable] :: TableDefinition key writeEntity readEntity -> SchemaItem

-- | Constructs a <a>SchemaItem</a> that will drop the specified table if
--   it is found in the database. @since 1.0.0.0
[SchemaDropTable] :: TableIdentifier -> SchemaItem

-- | Constructs a <a>SchemaItem</a> from a <a>SequenceDefinition</a>.
--   @since 1.0.0.0
[SchemaSequence] :: SequenceDefinition -> SchemaItem

-- | Constructs a <a>SchemaItem</a> that will drop the specified table if
--   it is found in the database. @since 1.0.0.0
[SchemaDropSequence] :: SequenceIdentifier -> SchemaItem

-- | Returns a one-line string describe the <a>SchemaItem</a>, suitable for
--   a human to identify it in a list of output.
--   
--   For example, a <a>SchemaItem</a> constructed via <tt>schemaTable</tt>
--   gives <tt>Table &lt;table name&gt;</tt>.
schemaItemSummary :: SchemaItem -> String

-- | A <a>MigrationPlan</a> contains an ordered list of migration steps.
--   Each one is a single DDL statement to make a specific database change.
--   The steps are ordered such that dependencies from earlier steps will
--   be in place before a later step is executed (e.g. new columns are
--   added before foreign keys referring to them).
--   
--   While most steps are executed together in a single transaction this is
--   not possible for indexes being created concurrently. Any such steps
--   are executed last after the transaction for the rest of the schema
--   changes has been successfully committed.
data MigrationPlan

-- | Compares the list of <a>SchemaItem</a>s provided against the current
--   schema found in the database and returns a <a>MigrationPlan</a> that
--   could be executed to make the database schema match the items given.
--   
--   You can execute the <a>MigrationPlan</a> yourself using
--   <a>executeMigrationPlan</a> convenience function, though
--   <a>autoMigrateSchema</a> is usually a better option because it uses a
--   database lock to ensure that no other processes are also using
--   <a>autoMigrateSchema</a> to apply migrations at the same time. If you
--   use <a>generateMigrationPlan</a> and <a>executeMigrationPlan</a>
--   separately you are responsible for ensuring that the schema has no
--   changed between the time the plan is generated and executed yourself.
generateMigrationPlan :: MonadOrville m => [SchemaItem] -> m MigrationPlan

-- | Returns all the <a>MigrationStep</a>s found in a <a>MigrationPlan</a>
--   together in a single list. This is useful if you merely want to
--   examine the steps of a plan rather than execute them. You should
--   always use <a>executeMigrationPlan</a> to execute a migration plan to
--   ensure that the transactional steps are done within a transaction
--   while the asynchronous steps are done afterward outside of it.
migrationPlanSteps :: MigrationPlan -> [MigrationStep]

-- | Executes a <a>MigrationPlan</a> that has be previously devised via
--   <a>generateMigrationPlan</a>. Normally all the steps in a migration
--   plan are executed in a transaction so that they will all be applied
--   together successfully or all rolled-back if one of them fails. Any
--   indexes using the <a>Asynchronous</a> creation strategy cannot be
--   created this way, however, because PostgreSQL does not allow
--   <tt>CREATE INDEX CONCURRENTLY</tt> to be used from inside a
--   transaction. If a <a>MigrationPlan</a> includes any indexes whose
--   creation strategy is set to <a>Asynchronous</a>, Orville will begin
--   the creation of those indexes after the rest of the migration steps
--   have been committed successfully. This function will return before
--   PostgreSQL has fineshed creating those indexes. You should check on
--   the status of indexes created this way manually to ensure they were
--   created successfully. If they could not be, you can drop them and
--   Orville will re-attempt creating them the next time migration is
--   performed.
executeMigrationPlan :: MonadOrville m => MigrationPlan -> m ()

-- | A single SQL statement that will be executed in order to migrate the
--   database to the desired result. You can use
--   <a>generateMigrationPlan</a> to get a list of these yourself for
--   inspection and debugging.
data MigrationStep

-- | A <a>MigrationDataError</a> will be thrown from the migration
--   functions if data necessary for migration cannot be found.
data MigrationDataError

-- | Executes an Orville action with a PostgreSQL advisory lock held that
--   indicates to other Orville processes that a database migration is
--   being done an no others should be performed concurrently.
withMigrationLock :: MonadOrville m => m a -> m a

-- | Raised if <a>withMigrationLock</a> cannot acquire the migration lock
--   in a timely manner.
data MigrationLockError
instance Orville.PostgreSQL.Raw.RawSql.SqlExpression Orville.PostgreSQL.AutoMigration.MigrationStep
instance GHC.Classes.Ord Orville.PostgreSQL.AutoMigration.StepType
instance GHC.Classes.Eq Orville.PostgreSQL.AutoMigration.StepType
instance GHC.Show.Show Orville.PostgreSQL.AutoMigration.MigrationDataError
instance GHC.Exception.Type.Exception Orville.PostgreSQL.AutoMigration.MigrationDataError


-- | This module provides function that can be used to implement
--   <tt>MonadOrvilleControl</tt> for monads that implement
--   <tt>MonadUnliftIO</tt>. For example,
--   
--   <pre>
--   module MyMonad
--     ( MyMonad
--     ) where
--   
--   import qualified Control.Monad.IO.Unlift as UnliftIO
--   import qualified Orville.PostgreSQL as O
--   import qualified Orville.PostgreSQL.UnliftIO as OrvilleUnliftIO
--   
--   newtype MyMonad =
--     ...
--     deriving (UnliftIO.MonadUnliftIO)
--   
--   instance O.MonadOrvilleControl MyMonad where
--     liftWithConnection = OrvilleUnliftIO.liftWithConnectionViaUnliftIO
--     liftCatch = OrvilleUnliftIO.liftCatchViaUnliftIO
--     liftMask = OrvilleUnliftIO.liftMaskViaUnliftIO
--   </pre>
module Orville.PostgreSQL.UnliftIO

-- | liftWithConnectionViaUnliftIO can be use as the implementation of
--   <tt>liftWithConnection</tt> for <tt>MonadOrvilleControl</tt> when the
--   <a>Monad</a> implements <tt>MonadUnliftIO</tt>.
liftWithConnectionViaUnliftIO :: MonadUnliftIO m => (forall a. (conn -> IO a) -> IO a) -> (conn -> m b) -> m b

-- | liftCatchViaUnliftIO can be use as the implementation of
--   <tt>liftCatch</tt> for <tt>MonadOrvilleControl</tt> when the
--   <a>Monad</a> implements <tt>MonadUnliftIO</tt>.
liftCatchViaUnliftIO :: MonadUnliftIO m => (forall a. IO a -> (e -> IO a) -> IO a) -> m b -> (e -> m b) -> m b

-- | liftMaskViaUnliftIO can be use as the implementation of 'liftMask for
--   <tt>MonadOrvilleControl</tt> when the <a>Monad</a> implements
--   <tt>MonadUnliftIO</tt>.
liftMaskViaUnliftIO :: MonadUnliftIO m => (forall b. ((forall a. IO a -> IO a) -> IO b) -> IO b) -> ((forall a. m a -> m a) -> m c) -> m c
